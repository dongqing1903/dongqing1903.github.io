---
title: 数据结构 - C版
comments: false
tags: 数据结构
categories:
	- [笔记, 专业笔记, 基础知识, 数据结构]
description: >-
  本笔记主要讲解了基础数据结构和高级数据结构以及基于C语言的代码实现，主要包括顺序表、链表、队列、栈、树与二叉树、排序算法、查找算法、优先队列、森林与并查集、二叉排序树、AVL树、红黑树、字典树、字符匹配算法、哈夫曼编码。
abbrlink: b0f49719
date: 2021-11-05 22:45:20
---









## 字符串

### 1、字符串匹配

#### 1.1、问题

![image-20211111224419474](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211111224419474.png)

#### 1.2、解决方法

##### 1.2.1、暴力匹配算法

-   **时间复杂度**：最好`O(n)`，最差`O(n * m)`

-   **算法思想**：依次对齐**模式串**和**母串**的每一位，直到完全匹配。

-   **代码演示**：

    ```c
    int brute_force(const char *s, const char *t) {
        int s_size = s.size(), t_size() = t.size();
        for (int i = 0; i < s_size - t_size + 1; i++) { //母串：减枝(i < s_size - t_size + 1)
            int flag = 0;
            for (int j = 0; t[j]; j++) { //模式串
                if (s[i + j] == t[j]) continue;
                flag = 1;
                break;
            }
            if (flag == 0) return 1; //匹配成功
        }
        return -1; //匹配失败
    }
    ```

##### 1.2.2、KMP算法

-   **时间复杂度**：`O(m + n)`

-   **算法思想**：

    1.  **基础补充**：

        -   **前缀**：字符串的任意首部
        -   **后缀**：字符串的任意尾部
        -   **真前缀**：不包含尾部的前缀
        -   **真后缀**：不包含首部的后缀

    2.  **算法引导**：

        **暴力算法**是匹配不成功时，每次将**模式串**后移`1`位和母串重新对齐，再将模式串和母串进行比对。**KMP算法**是在暴力算法的基础上进行改进，通过将**模式串**预处理得出**最长相等前后缀表**`next数组`，在和主串匹配不成功时，可以根据`next数组`得出最长匹配前后缀，从而移动模式串重新对齐母串。

        **具体分析如下**：

        ![image-20211112164606738](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211112164606738.png)

        -   如上图，母串`S`和模式串`T`在`5,6`的位置匹配失败，模式串`T`中的`3,4`是相等的前、后缀部分，模式串`T`可直接后移`7`的大小，由于`3 == 4 && 2 == 4`，推出`2 == 3`，所以模式串`T'`和母串`S`就不需要从头开始匹配，可以直接从模式串`8`和母串`5`开始匹配，由此就减少**暴力算法**中一次移动一步的次数，具体推导过程见[海贼科技 - 胡船长的证明](https://pan.baidu.com/s/1SNujD65uXdFflSHPfQKCFw)（提取码：1234）。

        -   问题一：`7`的大小是多少

            由模式串的前缀`3`和后缀`4`相等的最大长度`k`决定，移动距离为`i - k - 1`。

        -   问题二：如何保证不漏

            `4`尽可能长，达到最长，同时`3 == 4`，`3`为最长匹配前缀，`4`为最长匹配后缀

        -   问题三：模式串如何预处理

            模式串的每一位之前都应该预处理出类似`3,4`这种最长匹配前后缀的长度信息

    3.  **`next[i]`数组的确定**：

        **定义**：当位置`i`匹配成功，但`i+1`位置失配时，模式串中**最长**前缀的**最后一个字符**的下标

        **代码实现**：

        ```c
        /*
         * 4个步骤：
         *	1、初始化
         * 	2、前后缀不同的情况
         *	3、前后缀相同的情况
         * 	4、更新next
         */
        
        // 初始化
        next[0] = 0; //next数组用来标记当前位置之前有多大长度的相同前缀后缀
        int j = 0; // j指向前缀末尾的下一位
        int i = 1; // i指向后缀末尾的下一位
        for ( ; t[i]; i++) {
        	// 前后缀不同的情况 
            // 当i, j发生冲突时，要看发生冲突的前一位j - 1，回退到next[j - 1]的位置
            while (j != 0 && t[i] != t[j]) j = next[j - 1];
            // 前后缀相同的情况
            if (t[i] == t[j]) j += 1;
            // 更新next
            next[i] = j;
        }
        ```

-   **代码实现**

    ```c
    void getNext(int *next, const char *t) {
        next[0] = 0;
        for (int j = 0, i = 1; t[i]l i++) {
            while (j != 0 && t[i] != t[j]) j = next[j - 1];
            if (t[i] == t[j]) j += 1;
            next[i] = j'
        }
    }
    
    int KMP(const char *s, const char *t) {
        int next[s.size()];
        getNext(next, t);
        for (int i = 0, j = 0; s[i]; i++) {
            while (j != 0 && s[i] != t[j]) j = next[j - 1];
            if (s[i] == t[j]) j += 1;
            if (t[j] == 0) return i - j + 1;
        }
        return -1;
    }
    ```

    





