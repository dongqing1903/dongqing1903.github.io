---
title: C++学习笔记
comments: false
tags:
  - 笔记
  - 语言
categories:
  - 笔记
    - 专业笔记
    - 基础知识
    - 语言
abbrlink: ad4f1e09
date: 2021-11-16 10:27:00
description: 本笔记主要记录C++特有的基础和C++标准库中的知识点，包括变量和基本类型，字符串、向量和数组，表达式，语句，函数，类，容器，模板与泛型编程，动态内存，继承与多态，异常以及编程规范等。
---

# 从C到C++

## 1、C的超集

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211119093821786.png" alt="image-20211119093821786" style="zoom:80%;" />

-   **`C++`继承了`C`的绝大部分关键字，而不是语法特性，比如`struct`，`C++`中`struct`是类实现的，`struct`内部是可以定义方法的，而`C`中的`struct`内部是不可以定义方法的。**
-   **`Lambda表达式`支持函数式编程**
-   **`模板`支持泛型编程**

>   **说明**：
>
>   -   **学习重点：`异常处理、类和对象、模板、Lambda`**
>   -   **检验学习：`STL`**
>   -   **学习步骤：按照编程范式分门别类的学习语法特性**

## 2、编程范式

**编程范式：指导我们如何设计程序去实现相关的功能**

![image-20210616215419980](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20210616215419980.png)

-   **面向过程编程：用函数封装功能**
-    **面向对象编程：用类和对象实现功能**
-   **泛型编程：用`模板`实现功能**
-   **函数式编程：用`Lambda表达式`实现功能**

# C++基础

## 2、变量和基本类型

### 2.1、变量

>   **说明**：`变量 == 对象`

#### 2.1.1、变量定义

##### 2.1.1.1、初始化

**初始化的含义**：创建变量时赋予其一个初始值

**赋值的含义**：把对象的当前值擦除，而以一个新值来替代

>   **注意**：区分初始化和赋值，初始化不是赋值

**C++中初始化对象的方式**：

-   默认初始化：

    ```c++
    // T是类型
    T 对象; // 不能使用 T 对象()，这是函数的声明
    new T // new创建变量
    new T() // 自定义类型如果有相应的默认构造函数即可
    ```

-   直接初始化：

    ```c++
    T 对象(实参列表); // 内置数据类型都支持，并且一般支持一个参数，自定义类型如果有相应的构造函数即可
    T 对象(其他对象); // 内置数据类型都支持，并且一般支持一个参数，自定义类型如果有相应的构造函数即可
    T 对象{实参列表}; // 内置数据类型都支持，并且一般支持一个参数，自定义类型如果有相应的构造函数即可，另外支持聚合体的初始化
    T 对象 = 实参; // 内置数据类型都支持，并且只支持一个参数，自定义类型如果有相应的的构造函数即可，并支持隐式类型转换
    T 对象 = {参数列表}; // 内置数据类型都支持，并且一般支持一个参数，自定义类型如果有相应的构造函数即可，并支持隐式类型转换，另外支持聚合体的初始化
    ```

    >   **说明**：聚合体有如下两类：
    >
    >   -   数组类型：数组、vector、array
    >   -   满足如下条件的类类型(通常是结构体或联合体)：
    >       -   没有私有或保护的非静态数据成员
    >       -   没有用户提供的构造函数
    >       -   没有基类
    >       -   没有虚函数
    >
    >   **聚合体的初始化可以使用列表初始化**，比如`int a[12] = {1, 2, 3, 4, 5};`

**C++中提供的几种不同的初始化方式，它们之间基本是等价的，可以同时相互替换，但以下三种情况除外**：

-   使用拷贝初始化(`=`)时，只能提供一个初始值
-   如果提供的是<span id="leineichushizhihuakuohao">类内初始值</span>，只能使用拷贝初始化或使用花括号的形式初始化
-   <span id="shiyongliebiaochushihua">如果提供的是初始元素值的列表，只能把初始值都放在**花括号**里进行列表初始化，不能放在圆括号里</span>

##### 2.1.1.2、列表初始化

```c++
int units_sold = {0};
int units_sold{0};
```

当用于内置类型的变量时，**如果使用列表初始化且初始值存在丢失信息的风险，编译器将报错，`int a{3.1415}, int b = {3.1415}`**

##### <span id="morenchushihua">2.1.1.3、默认初始化</span>

内置类型变量的默认初始化的初始值**由定义的位置决定**：

-   全局变量初始化为0，局部静态变量初始化为0
-   定义在函数体内部的内置类型变量将不被初始化，未被初始化的内置类型变量的值是**未定义**的，对此操作会引发错误

**每个类各自决定其初始化对象的方式**。

##### 2.1.1.4、变量声明和定义的关系

变量声明规定了变量的类型和名字，**定义还申请存储空间**，也可以为变量赋初始值。

**声明而非定义**变量：`extern 类型 变量名`

**定义变量**：`类型 变量名 [ = 初始值 ]`

```c++
extern int i; // 声明而非定义i
int j; // 声明并定义j
int k = 0; //声明并定义初始化k
```

>   **注**：
>
>   -   声明而非定义变量时，**一定不能显示地初始化变量**
>   -   任何包含了显示初始化的声明即成为定义，`extern int j = 0;`也是定义
>   -   在函数体内部，如果初始化一个由`extern`标记的变量，将引发错误
>   -   变量只能被定义一次，但可以被声明多次

### 2.2、复合类型

#### 2.2.1、引用

**引用**：为`对象`起别名

一般初始化变量时，初始值会被拷贝到新建的对象中。**定义引用时，程序把引用和初始值`绑定`在一起**，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起，因此**无法令引用重新绑定到另外一个对象，引用必须初始化**

对引用的一切操作，都是对引用所绑定对象的操作

允许在一条语句中定义多个引用，`每个`**引用标识符都必须以&开头**

<span id="yinyongdechushihuaguize">除了以下两种特殊情况</span>，其他所有**引用的类型都要和与之绑定的对象`严格匹配`，而且只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起**

-   常量引用：

    ```c++
    double r = 34.45;
    const int &ri = r; // 正确：引用类型与绑定对象类型不一致，同时引用是const类型的，对象是普通类型，ri的值为34
    const int &si = 43; // 正确：引用与字面值绑定
    ```

-   在继承关系中，可以把基类的指针或引用绑定到派生类对象上。


**引用本身不是一个对象**，不能定义引用的引用

#### 2.2.2、指针

**指针与引用的区别**：

-   指针本身就是一个`对象`，允许对指针赋值和拷贝，而且在指针的生命周期内可以**先后指向几个不同的对象**
-   指针**无须在定义时赋初值**，在块作用域内定义的指针如果没有被初始化，将拥有一个**不确定**的值

允许在一条语句中定义多个指针变量，`每个`**变量前面都必须有符号\***

指针存放某个`对象`的地址，:question:因为引用不是对象，没有实际地址，不能定义指向引用的指针:question:，但指针是对象，存在对指针的引用

```c++
int i = 42;
int *p; 
int *&r = p; // r是对指针p的引用  
r = &i; // 正确
*r = 0;
```

>   **Tips**：对于上例中多重指针和引用的r，从`右往左阅读`，**离变量最近的`符号`(&)对变量的类型有最直接的影响**，因此r是一个引用，**声明符的其余部分用以确定`&r`的类型**，符号\*说明r引用是一个指针，int指出r引用是一个int指针

除了以下两种特殊情况，其他所有**指针的类型都要和与之指向的对象**`严格匹配`：

-   常量指针、指向常量的指针
	
    ```c++
    double r = 34.45;
    const double *ri = &r; // 正确：指针类型与指向对象类型不一致，指针是const类型的，对象是普通类型
    double *const p = &r; // 正确：
    ```
    
-   在继承关系中，可以把基类的指针或引用绑定到派生类对象上。


解引用操作仅适用于**确实指向了某对象的有效指针**

**空指针**的定义方法：

```c++
int *p1 = nullptr; // 字面值nullptr可以转换成任意其他类型的指针类型，C++11引入的
int *p2 = 0; // 字面值0
int *p3 = NULL; // 从C语言引入的，需要包含头文件cstdlib
```

`void*`可以存放任意对象的地址，**不能直接操作`void*`指针所指的对象，需要转换成已知类型的指针**

```c++
int *arr = (int *)malloc(3 * sizeof(int));
```

通过`*`的个数可以区分指针的级别，`**`表示指向指针的指针，`***`表示指向指针的指针的指针

### 2.3、处理类型

#### 2.3.1、类型别名

**普通类型别名**定义的方式：

```c++
// 方法一
typedef double wages; // wages是double的同义词

// 方式二
using SI = Sales_item; // SI是Sales_item的同义词
```

**指针的类型别名**定义的方式：

```c++
typedef char *pstring; // pstring是char*的同义词
const pstring cstr = 0; // cstr的类型是常量的指针，而不是说cstr是一个常量指针，pstring是一个指针，const pstring就是常量的指针
char a = 'a';
const pstring p = &a;
const pstring *ps = &p; // ps是一个指针，ps所指向的对象是一个指向const char指针类型的指针

```

>   **注意**：:star::star:此处不能理解成`const char *cstr = 0`，pstring的基本类型是**指针**，如果是**char \***，\*成为声明符的一部分，**const char**成为基本数据类型。

#### 2.3.2、auto类型说明符

`auto`让编译器通过初始值来推算变量的类型，所以**auto定义的变量必须有初始值**

当`引用`被用来初始化`auto`变量时，编译器会**以引用对象的类型作为auto的类型**

```c++
int i = 0, &r = i;
auto a = r; // a的类型是i的类型
```

`auto`会忽略**顶层const**，**底层const**会保留下来，如果希望推断出的auto的类型是一个**顶层const，需要明确指出const**

```c++
const int ci = i, &cr = ci;
auto b = ci; // b是一个整数，ci的顶层const被忽略
auto c = cr; // c是一个整数，cr是ci的别名，ci是顶层const被忽略，对于cr来说是底层const，但此处是使用引用cr，实际使用的就是被引用对象本身，要区分开cr的定义还是使用
auto d = &i; // &i是一个地址，d是一个指针
auto e = &ci; // ci是一个常量，&ci是指向常量的指针，是底层const，e是一个指向常量的指针

const auto f = ci; // 明确指定顶层const类型

// 将引用的类型设为auto
auto &g = ci; // g是一个整形常量引用
```

><span id="shangyijiedeshuomingzhongdeliwai">**说明**</span>：:star:引用从来都是作为**其所指对象的同义词**出现(**可以直接看作所指对象**)，在decltype中有一个[例外](#decltypedetelidifang)

#### 2.3.3、decltype类型指示符

`decltype`：选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，**却不实际计算表达式的值**

```c++
decltype(f()) sum = x; // sum的类型是f()的返回类型
```

如果表达式是一个`变量`，`decltype`返回变量的类型(**包括顶层const和引用在内**)

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // ci的类型是const int，x的类型也是const int
decltype(cj) y = x; // cj的类型是const int &，y的类型也是const int &，此处和通常情况情况不一样，一般引用在使用时，使用是被引用对象本身，此处不是
```

:star::star:<span id="decltypedetelidifang">上例</span>`decltype(cj) y = x;`就是[上一节的说明中说的例外](#shangyijiedeshuomingzhongdeliwai)

如果表达式是一个`表达式`，`decltype`返回表达式结果对应的类型，有些表达式将返回引用类型作为左值使用，**:star:注意下例中的3种特殊情况:star:**：

```c++
int i = 42, *p = &i, &r = i;
// 对应使用引用的特殊的情况，r是引用，decltype的结果就是引用，a的类型是int&
decltype(r) a = i; 
// 特殊情况一
decltype(r + 0) b; // 正确：r+0表达式的结果是一个整形数值，所以decltype的结果是int
// 特殊情况二
decltype(*p) c; // 错误：decltype(*p)的结果是int&，c需要赋初值
// 特殊情况三
decltype((i)) d; // 错误：d是int&，必须初始化
```

-   特殊情况一：如果想让结果类型是`r`所指的类型`int`，可以把`r`作为表达式的一部分，如`r + 0`，这样表达式的结果就是一个具体值而非一个引用
-   特殊情况二：如果表达式的内容是`解引用操作`，则**decltype将得到引用类型**，因为解引用指针可以得到指针指向的对象，可以给该对象进行赋值，是一个左值
-   特殊情况三：如果`decltype`使用的是不加括号的变量，得到的结果就是该变量的类型；如果**给`变量`加上一层或多层括号**，编译器会把它当作一个**表达式**，`decltype`返回的结果是`引用类型`

### 2.4、const限定符

#### 2.4.1、初始化和const

const对象一旦创建后其值就不能再改变，**const对象必须初始化**

只能在const类型的对象上执行**不改变其内容**的操作

```c++
int i = 43;
const int ci = i; // const变量初始化没有限制，变量或者常量都可以
```

**默认状况下，const对象仅在文件内有效**，当需要在多个文件间使用同一个`const变量`时，对于const变量**不管是声明还是**`定义`都添加`extern`关键字

#### 2.4.2、const的引用

**对常量的引用(常量引用)**：将**引用**绑定到**const对象**上，对常量的引用不能被用作**修改它所绑定的对象**

```c++
const int ci = 43;
const int &rl = ci;
```

对于**普通引用**只能用与其所引用对象一致的类型进行初始化

对于**常量引用**，在初始化时允许用**任意表达式**作为初始值，只要该表达式的结果能转换成引用的类型即可，尤其允许一个常量引用绑定**非常量**的对象、字面值或表达式，这种情况的实现原理如下：

```c++
double dval = 3.14;
const int &ri = dval;
// 内部实现原理
const int temp = dval; // 由浮点数生成一个临时的整型常量
const int &ri = temp;  // 让ri绑定这个临时量
// 如果ri不是常量引用的话，就可以通过ri去修改临时量temp，是没有意义的。
```

>   **说明**：
>
>   -   常量的引用仅仅对**引用可参与的操作**做出了限定(`不可以通过引用修改被引用的对象`)，对于**引用的对象本身**是不是一个常量未作限定
>   -   引用不是对象

#### 2.4.3、const和指针

**指向常量的指针**：与常量引用类似，不能用于改变其所指对象的值

```c++
const double pi = 3.1415;
const double *ptr = &pi; 
```

**指针是对象，引用不是对象，允许把指针本身定为常量**

**常量指针**必须初始化，而且一旦初始化完成，它的值(**存放在指针中的那个地址**)就不能再改变了。

```c++
// 把*放在const关键字之前用以说明指针是一个常量
int errNumb = 0;
int *const curErr = &errNumb;
const double pi = 3.1415;
const double *const pip = &pi;
// 从右向左读，可以弄清声明的含义
const double *const pip = &pi;
// 从右往左读，第一个声明符是const，表明pip是一个常量对象
// 对象的类型由声明符的其他部分确定，const double *说明pip是一个指向double类型常量的指针
// 总的来说：pip是一个指向常量对象的常量指针
```

>   **说明**：
>
>   -   **指向常量的指针**仅仅对**指针可参与的操作**做出了限定(`不可以通过指针修改被指向的对象`)，对于**指针指向的对象本身**是不是常量未作限定
>   -   **常量指针**说明指针本身是常量，并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于**所指对象**的类型
>   -   注意区分`指向常量的指针`和`常量指针`

#### 2.4.4、顶层const

指针本身是一个对象，又可以指向另一个对象，对于**指针**来说：

-   **顶层const**：指针本身是常量
-   **底层const**：指针所指向的对象是常量

更一般的结论：

-   **顶层const**：使得**被修饰的**`变量本身`无法改变的const
-   **底层const**：其他的通过指针或引用等`间接途径`来限制目标内容不可变的const，**常量引用都是底层const**

**当执行对象的拷贝操作时，拷入拷出的对象必须具有相同的** :one:`底层const资格`或者:two:`两个对象的数据类型能够转换`

```c++
int i = 0;
const int ci = 42;  // ci是顶层const
const int *p2 = &ci;  // 指向常量的指针，底层const
const int *const p3 = p2; // p3是底层const、顶层const，
int *p = p3; // 错误：p3包含底层const，而p没有，违背第1点
p2 = p3; // 正确：p2和p3都包括底层const
p2 = &i; // 正确：p2和&i都不包含底层const，但是&i可以转换成const int *类型
int &r = ci; // 错误：普通的int&不能绑定到int常量上，const int不能转化成int，违背第2点
```

#### 2.4.5、constexpr和常量表达式

**常量表达式**：值不会改变并且在**编译过程**就能得到计算结果的表达式

**一个对象(或表达式)是不是常量表达式由`数据类型`和`初始值`共同决定**

```c++
const int max_files = 20; // 是
const int limit = max_files + 1; // 是
int staff_size = 27; // 不是，staff_size值可以发生改变
const int sz = get_size(); // 不是，get_size()在编译过程不能确定
```

**`constexpr`变量一定是常量，必须用`常量表达式`初始化**

*算数类型、引用和指针都属于字面值类型*，**一个`constexpr`指针的初始值必须是`nullptr`或`0`或`存储于某个固定地址中的对象`(全局变量、局部静态变量的地址)，一个`constexpr`引用的初始值必须是`某个固定地址中的对象`**

`constexpr`仅对指针有效，与指针所指的对象无关，**constexpr把它所定义的对象置为`顶层const`，所以constexpr指针既可以指向常量也可以指向非常量**

```c++
const int *p = nullptr; // p为指向常量的指针
constexpr int *q = nullptr; // q为常量指针
int j = 24; // 全局变量
constexpr int *q = &j; // 指向非常量对象
const int z = 34;
constexpr const int *zr = &z; // 指向常量对象 const int
```

>   **说明**：<span id="zimianzhileixingdedingyi">`字面值类型`</span>是指**编译时就能得到结果的类型**，具体包括算术类型(整形、字符型、布尔类型、浮点型)、引用和指针，自定义类、IO库、string类型不属于该类型。

## 3、字符串、向量和数组

### 3.1、命名空间

#### 3.1.1、命名空间定义

定义形式：

```c++
namespace 命名空间的名字 {
    /*
     * 只要是能出现在全局作用域中的声明就能置于命名空间内，主要包括：
     * 类、变量、函数、模板、其他命名空间
     */
} // 没有;
```

命名空间的名字必须在定义它的作用域内保持**唯一**，**命名空间不能定义在函数或类的内部**

定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问，**类似于外层作用域中的全局变量和内层作用域中的局部变量**；位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间

**命名空间可以不连续**，该特性使得**将几个独立的接口和实现文件组成一个命名空间**，此时命名空间的组织方式类似于自定义类及函数的方式：

-   命名空间的一部分的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中
-   命名空间成员的定义部分则至于另外的源文件中

在程序中某些实体只能**定义**一次，但可以**声明多次**：如**非内联函数、静态数据成员、变量**等，**命名空间中定义的名字也需要满足这一要求**，可以通过上面的方式组织命名空间并达到目的；这种接口和实现分离的机制确保我们所需的**函数和其他名字只定义一次**，而只要是用到这些实体的地方都能看到对于实体名字的**声明**

**位于头文件的代码一般来说不应该使用`using`声明**，因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个`using`声明，那么每个使用了该文件的文件就都会有这个声明，对于某些程序来说，由于不经意间包含了一个名字，反而可能产生始料未及的名字冲突

**不能把`#include`放在命名空间中**

>**说明**：如果在头文件中使用命名空间，在命名空间中只进行相关变量和函数的声明，不能是定义

假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一命名空间定义的名字的简写形式(不需要加前缀)；也可以在命名空间定义的外部定义该命名空间的成员；命名空间对于名字的**声明必须在作用域内**，同时该名字的**定义需要明确指出其所属的命名空间**；和定义在类外部的类成员一样，**一旦看到含有完整前缀的名字，就可以确定该名字位于命名空间的作用域内，可以直接使用命名空间中的成员，但对于函数的返回值需要指定前缀**

```c++
cplusplus_primer::Sales_data cplusplus_primer::operator+(const Sales_data& lhs, const Sales_data& rhs) { }
```

尽管命名空间的成员可以定义在命名空间的外部，**但是这样的定义必须出现在所属命名空间的`外层空间`中，不能在一个不相关的作用域中定义这个运算符**

##### 3.1.1.1、全局命名空间

全局命名空间以`隐式`的方式声明，并且在所有程序中都存在，全局作用域中定义的名字被隐式地添加到全局命名空间中

可以直接通过`::`使用全局作用域的成员

```c++
::member_name
```

##### 3.1.1.2、嵌套的命名空间

**内层**命名空间声明的名字将**隐藏外层**命名空间声明的**同名成员**，在嵌套的命名空间中定义的名字只在内层命名空间中有效，**外层命名空间中的代码要想访问它必须在名字前添加限定符(和全局作用域中不能使用局部作用域中的变量不同)**(只能使用前面的内层命名空间中声明的成员)

##### 3.1.1.3、内联命名空间

内联命名空间中的名字可以被外层命名空间**直接**使用，无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它

在关键字`namespace`前添加关键字`inline`定义内联命名空间，`inline`必须出现在命名空间`第一次定义`的地方，后续再打开命名空间的时候可以写也可以不写`inline`

```c++
inline namespace FifthEd {
    
}
namespace FifthEd { // 隐式内联
    
}
```

##### 3.1.1.4、未命名的命名空间

**未命名的命名空间中定义的变量拥有`静态`生命周期**，它们在第一次使用前创建，并且直到程序结束才销毁

一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件；每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关，在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体；**如果一个头文件中定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体**

定义在未命名的命名空间中的名字可以**直接使用**

**未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同**，如果定义在最外层作用域中，该空间的成员名字一定要与全局作用域中的名字有所区别；一个未命名的命名空间也能嵌套在其他命名空间中，其中的成员可以**通过外层命名空间的名字来访问**

#### 3.1.2、命名空间的使用

##### 3.1.2.1、命名空间的别名

别名的形式：

```c++
namespace 别名 = 命名空间名;
```

**不能在命名空间还没有定义前就声明别名**

##### 3.1.2.2、using声明

一条`using`声明语句中**一次只引入命名空间的一个成员**，`using`声明引入的名字的有效范围：**从`using`声明的地方开始，一直到`using`声明所在的作用域结束为止**；在此过程中，外层作用域的同名实体将被隐藏，未限定的名字只能在`using`声明所在的作用域以及其内层作用域中使用，在有效作用域结束后，必须使用完整的经过限定的名字

一条`using`声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中，在类的作用域中，`using`声明语句**只能指向基类成员**

`using`**声明的名字的作用域与`using`声明语句本身所在的作用域一致，好像`using`声明语句为命名空间的成员在当前作用域内创建了一个别名**

##### 3.1.2.3、using指示

`using`指示必须**使用已经定义好的命名空间的名字**，`using`指示 可以出现在全局作用域、局部作用域、命名空间中，**但不能出现在类的作用域中**

`using`指示具有将命名空间成员提升到**同时包含命名空间本身和`using`指示的最近作用域**，此时会导致二义性冲突，这种冲突是允许存在的，但要想使用必须明确指出名字的版本

```c++
namespace test4{
	int i;                         //位置1
	namespace my{
		namespace my1{
			int i = 2;             //位置2
		}
	}
	namespace myfun{
		void func()
		{
			using namespace my::my1; // 同时包含命名空间和using指示的作用域是test4作用域
			std::cout << "hello:" << i; // 产生二义性
            std::cout << "hello:" << my::my1::i;
		}
	}
}
```

#### 3.1.3、类、命名空间与作用域

对命名空间内部名字的查找遵循常规的查找规则：由内向外依次查找每个外层作用域，外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止，只有位于开放的块中且在**使用点之前**声明的名字才被考虑

**当给函数传递一个`类类型`的对象时，除了在常规的作用域查找外还会查找**`实参类所属的命名空间`

```c++
operator<<(std::cin, s); // 首先在当前作用域查找operator<<函数，然后在外层作用域查找，最后在实参cin，s所在的命名空间std中查找
```

一个另外的未声明的类或函数如果第一次出现在友元声明中，则认为它是最近的外层命名空间的成员

```c++
namespace A {
    class C {
        // 这些函数隐式地成为命名空间A的成员
        friend void f2();
        friend void f(const C&);
    };
}
int main() {
    A::C cobj;
    f(cobj); // 根据cobj实参所属类的命名空间查找
    f2(); // 找不到    
    return 0;
}
```

#### 3.1.4、重载与命名空间

对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行，那么**将在`每个实参类以及实参类的基类`所属的命名空间中搜寻候选函数**

```c++
namespace NS {
    class Quote {};
    void display(const Quote&) {}
}
class Bulk_item : public NS::Quote {}
int main() {
    Bulk_item book1;
    display(book1); // 搜查Bulk_item和Quote类所在命名空间的相关成员
    return 0;
}
```

`using`声明语句声明的只是一个`名字`，而非一个特定的函数，使用`using`声明一个函数时，**该函数的所有版本都被引入到当前的作用域中**

一个`using`声明引入的函数将`重载`**该声明语句所属作用域中已有的其他同名函数**，如果`using`声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明；如果`using`声明所在的作用域中已经有一个函数与新引入的函数**同名且形参列表相同**，则该`using`声明将引发错误；

`using`指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中；和`using`声明不同的是，对于`using`指示来说，**引入一个与已有函数形参列表相同的函数并不会产生错误**，只要指明调用的是命名空间中的函数版本还是当前作用域的版本即可

### 3.2、标准库类型string

#### 3.2.1、定义和初始化string对象

```c++
string s; // 默认构造：生成空的string s
string s(str); // 拷贝构造：创建string str的拷贝
string s(rvstr); // 移动构造：将rvstr的内容搬移到创建的string s中

string s(str, stridx); // 将string str内始于stridx到结尾的部分作为s的初值 
string s(str, stridx, strlen); // 将string str内始于stridx，长度为strlen的部分作为s的初值 
string s(cstr); // 以C语言字符串初始化， const char *
string s(chars, charslen); // 以字符数组前charslen字符初始化
string s(num, c); // 生成一个字符串，包含num个c字符
string s(beg, end); // 以[begin, end)区间内的字符作为字符串s的初始值
string s(initlist); // 以列表中的字符初始化s
```

#### 3.2.2、string对象上的操作

##### 3.2.2.1、构建string的其他方法

![image-20211208000432730](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208000432730.png)

##### 3.2.2.2、改变string的其他方法

![image-20211208000751058](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208000751058.png)

除了接受迭代器的insert和erase版本外，string还提供了接受`下标`的版本

`append`可以在string的末尾追加**字符串、string等**，而`push_back`只能追加`char`字符元素

`replace`操作是调用`erase和insert`的一种简写形式

`assign`函数无须指定要替换string中哪个部分，`assign`总是替换string中的**所有内容**

##### 3.2.2.3、string搜索操作

![image-20211208001635813](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208001635813.png)

![image-20211208001818220](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208001818220.png)

##### 3.2.2.4、compare函数

`compare`是string类的**成员函数**，用法和`strcmp`一致

![image-20211208002255808](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208002255808.png)

##### 3.2.2.5、数值操作(非成员函数)

![image-20211208002505183](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208002505183.png)

要转换为数值的string中第一个非空白符必须是数值中可能出现的字符，可以是`+/-/.`或者`数字`，可以包含`e/E`来表示指数部分

##### 3.2.2.6、其他操作

`getline(is, s)`函数从给定的输入流`is`中读入内容，直到遇到`换行符`为止(**换行符也被读进来了**)，然后将所读的内容存放到s中(**不存换行符**)；`getline`只要一遇到换行符就结束读取操作并返回结果。`getline`函数的返回**它的流参数**

`string::size_type`是一个**无符号类型**的值

```c++
typedef size_t size_type
```

当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须**确保每个加号运算符的两侧的运算对象`至少`有一个时string**

>**注意**：区分string和字符串字面值，字符串字面值是`const char *`类型的，字符串字面值类型能转换成string类型，反之不行

### 3.3、标准库类型vector

vector的元素必须是对象，引用不是对象，元素不能是引用

#### 3.3.1、定义和初始化vector对象

```c++
vector<T> c; // 默认构造函数：空的vector，没有任何元素
vector<T> c(c2); // 拷贝构造函数：
vector<T> c = c2; // 
vector<T> c(rv); // 移动构造函数：
vector<T> c = rv; //

vector<T> c(n); // 利用元素的default构造函数生成一个大小为n的vector 
vector<T> c(n, elem); // 建立一个带下为n的vector，每个元素值都是elem
vector<T> c(beg, end); // 以区间[beg,end)的元素初始化vector c
vector<T> c{initlist}; // 以初始化列表初始化vector c，只能使用花括号，不能使用圆括号
vector<T> c = {initlist}; //
```

如果[使用`列表`初始化](#shiyongliebiaochushihua)，只能将初始值都放在`花括号`里进行列表初始化，而不能放在圆括号里

如果只提供元素的数量而没有设定初始值，只能使用`直接初始化`，是因为相应的构造函数是`explicit`的

``` c++
explicit vector( size_type count, const T& value = T(), const Allocator& alloc = Allocator()); 
```

如果用的是圆括号，一般提供的值是用来**构造(调用相关的构造函数)**对象的

如果用的花括号，一般是用列表初始化对象

对于vector类型来说，如果**初始化时使用花括号**的形式但是**提供的值又不能用来列表初始化**，就要**考虑用这样的值来构造vector对象**，`只能{}转化为()使用，反之不行`

```c++
vector<string> v5{"hi"}; // 列表初始化，构造一个元素
vector<string> v6("hi"); // 错误
vector<string> v7{10}; // 此处相当于 v7(10), v7有10个默认初始化的元素
vector<string> v8{10, "hi"}; // 此处相当于 v8(10, "hi")
```

#### 3.3.2、vector对象上的操作

```c++

```

如果循环体内部包含有**向vector对象添加元素**的语句，不能使用**范围for循环**，**范围for循环语句内不应改变其遍历序列的大小**

使用vector类型的`size_type`时要指定作用域`vector<type>::size_type`，需要指定是由那种类型定义的，需要指明vector对象的类型

不能通过`下标`添加vector对象，vector对象的下标运算符可用于访问**已存在**的元素，而不能用于添加元素

### 3.4、迭代器

迭代器都包含`begin`和`end`两个成员：

-   `begin`：指向第一个元素的迭代器
-   `end`：指向容器`尾元素的下一个位置`

### 3.5、数组

#### 3.5.1、定义和初始化内置数组

数组中元素的个数属于数组的一部分，**编译的时候维度应该是已知的**，维度必须是一个常量表达式

定义数组时，不允许用`auto`关键字由初始值的列表推断类型，数组的元素应为对象，不存在引用的数组

可以对数组的元素进行`列表初始化`，此时允许忽略掉数组的维度

**字符数组**还可以用`字符串字面值`初始化，字符串字面值结尾的`\0`也会拷贝到字符数组中

不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值

**默认情况下，类型修饰符从右向左依次绑定，对于数组而言，由内向外阅读更合适**

```c++
int *ptrs[10]; // 从右向左读：ptrs[10]是一个数组，数组元素的类型是int*
int (*Parray)[10]; // 从内向外读：*Parray是一个指针，指针类型是int[10]
```

#### 3.5.2、访问数组元素

数组也可以使用`范围for`语句

#### 3.5.3、指针和数组

在很多用到**数组名字**的地方，编译器都会自动地将其替换为**一个指向数组`首元素`的指针**，但[sizeof(数组名)](#sizeofshuzu)除外

当使用数组作为一个`auto`变量的初始值时，推断得到的类型是指针而非数组

当使用`decltype`时，推断得到的是数组，不会将数组名转换为指针

```c++
int ia[] = {0, 1, 2, 3, 4, 6};
auto ia2(ia); // ia转化为指针，指向数组ia的第一个元素, ia2是一个指针
decltype(ia) ia3 = {0, 1, 2, 3, 4, 5}; // ia3是一个数组，int[6]类型的数组
```

指针也是迭代器

标准库提供`begin`和`end`函数，这两个函数不是成员函数，使用时需要将数组作为其参数

```c++
int ai[] = {0, 1, 2, 3, 4};
int *beg = begin(ai);
int *end = end(ai);
```

两个指针相减的结果的类型是一种名为`ptrdiff_t`的标准库类型，`ptrdiff_t`是一种**带符号**类型

只要指针指向数组中的元素(或者数组中尾元素的下一个位置)，都可以执行下标运算，此时的下标允许是`负数`

```c++
int *p = &ia[2];
int k = p[0]; // k = ia[2]
int l = p[-2]; // l = ia[0]
```

#### 3.5.4、C风格字符串

如果需要**C风格字符串**，无法直接使用**string**对象来代替它；string提供一个名为`c_star`的成员函数，该函数的返回值是一个C风格的字符串，是一个`const char *`类型的指针；如果执行完`c_str()`函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份

#### 3.5.5、多维数组

使用范围for语句处理多维数组，**除了`最内层`的循环外，其他所有循环的控制变量都应该使用引用**

```c++
for (const auto &row : ia) {
    for (auto col : row) {
        
    }
}
```

## 4、表达式

### 4.1、类型转换

#### 4.1.1、隐式转换

**算术类型之间的隐式转换被设计得尽可能`避免损失精度`**

#### 4.1.2、显式转换

##### 4.1.2.1、static_cast

**任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast**

static_cast的类型转换是在`编译期间转换`的

**使用场景**：

-   原有的自动类型转换，比如`int → double`
-   `void*`指针和具体类型指针之间的转换，比如`void* → int*`
-   有`转换构造函数`或者`类型转换函数`的类与其他类型之间的转换，比如`double → Complex(调用转换构造函数)`

**不适用场景**：

-   两个具体类型指针之间的转换
-   int和指针之间的转换
-   **static_cast也不能去掉表达式的底层const**

```c++
double f = 3.14;
int n = static_cast<int>(f);
int *p1 = static_cast<int*>(malloc(10 *sizeof(int)));
```

##### 4.1.2.2、const_cast

**const_cast只能改变运算对象的**`底层const`，**改变常量属性**，不能改变表达式的类型

```c++
const int n = 100;
int *p = const_cast<int*>(&n); // &n是底层const，指向常量的指针，const_cast去除底层const
```

##### 4.1.2.3、reinterpret_cast

reinterpret_cast转换仅仅是**对二进制位的重新解释**，**不会借助已有的转换规则对数据进行调整**

reinterpret_cast可以认为是 static_cast 的一种补充，**一些 static_cast 不能完成的转换，就可以用reinterpret_cast 来完成**

-   两个具体类型指针之间的转换
-   int和指针之间的转换

```c++
int a = 20;
int *p = &a;
double *pa = reinterpret_cast<double*>(p);
```

>   **说明**：reinterpret_cast主要进行指针类型之间的转换

##### 4.1.2.4、dynamic_cast

`dynamic_cast`可以将一个基类类型强转成派生类类型

`dynamic_cast`运算符的使用形式：

```c++
dynamic_cast<type*>(e) // e必须是一个有效的指针
dynamic_cast<type&>(e) // e必须是一个左值
dynamic_cast<type&&>(e) // e不能是左值
```

`type`**必须**是一个类类型，并且通常情况下该类型应该含有**虚函数**；

`e`的类型必须符合以下三个条件中的任意一个：

-   目标`type`的**公有**派生类
-   目标`type`的**公有**基类
-   目标`type`的类型

如果`dynamic_cast`的转换目标是指针类型并且失败了，结果为0；如果转换目标是引用类型并且失败了，将抛出一个`bad_cast`异常

```c++
Base bp;
Derived *dp = dynamic_cast<Derived*>(bp);
const Derived &d = dynamic_cast<const Derived&>(bp)
```

**可以对一个空指针执行`dynamic_cast`，结果是所需类型的空指针**

### 4.2、sizeof运算符

sizeof运算符满足**右结合律**，所得到的值是一个`size_t`类型的常量表达式

```c++
sizeof (type) 
sizeof expr // 返回表达式结果类型的大小，类似于decltype，不实际计算表达式的值
```

sizeof运算符的结果部分地依赖于其作用的类型：

-   对char或类型为char的表达式执行sizeof运算，结果为1
-   对`引用类型`执行sizeof运算得到`被引用对象`所占空间的大小
-   对`指针`执行sizeof运算得到`指针本身`所占空间的大小
-   对`解引用指针`执行sizeof运算得到`指针指向的对象所占空间`的大小，**指针不需要有效**
-   对`数组`执行<span id="sizeofshuzu">sizeof运算得到`整个数组`所占空间的大小</span>，**sizeof运算不会把数组转化成指针来处理**
-   对`string或vector对象`执行sizeof运算只返回`该类型固定部分的大小`，不会计算对象中的元素占用了多少空间

## 5、语句

### 5.1、范围for语句

**范围for语句的语法形式**：

```c++
// expression必须是一个序列，可以是初始值列表、数组、vector、string等类型的对象，拥有能返回迭代器begin和end成员的类型
// declaration来指代每次循环的序列中的元素，如果需要更改元素值，需要使用引用类型
for (declaration : expression) { 
    statement
}
```

## 6、函数

### 6.1、函数基础

#### 6.1.1、局部对象

##### 6.1.1.1、局部静态对象

局部静态对象在程序执行路径`第一次`经过对象定义语句时初始化，并且直到程序终止才被销毁

如果局部静态变量没有显式的初始值，将执行值初始化，如果是内置类型将被初始化为0

### 6.2、参数传递

#### 6.2.1、传值参数

当初始化一个非引用类型的变量时，**初始值被`拷贝`给变量**，对变量的改动不会影响初始值

#### 6.2.2、const形参和实参

<span id="xingcandedingcengconst">当实参初始化形参时会忽略掉**顶层const**，**形参的顶层const被忽略**，当形参有顶层const时，实参是常量对象或非常量对象都可以</span>

形参是引用类型时，传实参时需要和[引用的初始化规则](#yinyongdechushihuaguize)一样

#### 6.2.3、数组形参

**数组形参的形式**：

```c++
void print(const int*); 
void print(const int []); 
void print(const int [10]); 
```

**管理指针形参的方式**：

-   使用标记执行数组长度：要求数组本身包含一个`结束字符`；对于**字符串或字符数组，是以`\0`为结束字符
-   使用标准库规范：传递指向数组**首元素和尾元素的指针**，比如`void print(int *begin, int *end);`
-   显示传递一个表示数组大小的形参：专门定义一个表示数组大小的形参，比如`void print(int *p, int size);`

##### 6.2.3.1、数组引用形参

[变量可以定义成数组的引用](#bianliangdingyichengshuzudeyinyong)，形参也可以定义成数组的引用

```c++
void print(int (&arr)[10]); // &arr外层的()不能省略

f(int &arr[10]) // 错误：将arr声明成了引用的数组
f(int (&arr)[10]) // 正确：arr是具有10个整数的整形数组的引用
```

这种用法限制了print函数的可用性，只能将**函数作用于大小为10的数组**

##### 6.2.3.2、传递多维数组

```c++
void print(int (*matrix)[10], int size); // size行10列的数组

int *matrix[10]; // 10个指针构成的数组
int (*matrix)[10]; // 指向含有10个整数数组的指针
```

#### 6.2.4、含有可变形参的函数

C++提供两种方法：

-   如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型

```c++
// initializer_list是一个模板类型，用法和vector一样，用于表示某种特定类型的数组
void error_msg(initializer_list<string> il) {
    for (auto beg = il.begin(); beg != il.end(); ++beg) 
        cout << *beg << " ";
    cout << endl;
}
```

-   如果实参的类型不同，可以使用可变参模板
-   省略符形参

```c++
va_list类型 // 获取第一个参数`a`后面的参数，是一个参数指针 `va_arg argptr`
va_start宏 // 定位参数`a`后面的第一个参数的位置 `va_start(argptr, a)`
va_arg宏 // 返回下一个类型匹配的表达式值`va_arg(argptr, 参数类型)`
va_end宏 // 结束整个获取可变参数列表的动作 `va_end(argptr)`
```

### 6.3、返回类型和return语句

在**含有return语句的循环后面应该也有一条return语句**，如果没有的话该程序就是错误的。

返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于**初始化调用点的一个临时量**，该临时量就是函数调用的结果

#### 6.3.1、列表初始化返回值

列表用来对**表示函数返回的临时量**进行初始化，如果列表为空，临时量执行值初始化，否则返回的值由函数的返回类型决定；**和列表初始化变量的使用方法一致，此处初始化函数返回的临时变量**

```c++
// 列表初始化数组类型
vector<int> func1() {
    return {1, 2, 3, 4};
}

// 列表初始化，调用对应的构造函数
class A {
private:
    int a;
    double b;
    char c;
public:
    A(int a, double b, char c) : a(a), b(b), c(c) {}
};
A func1() {
    return {1, 0.3, 'c'}; // 调用构造函数初始化临时变量
}

// 返回内置类型，{}中对多一个值
int func2() {
    return {1};
}
```

#### 6.3.2、返回数组指针

##### 6.3.2.1、使用类型别名

```c++
typedef int arrT[10]; // arrT是类型别名，表示的类型是含有10个整数的数组
using arrT = int[10];

arrT* func(int i); // 返回一个指向含有10个整数的数组指针
```

##### 6.3.2.2、声明一个返回数组指针的函数

数组的维度必须跟在函数名字之后，函数的形参跟在函数名之后且形参列表应该先于数组的维度

```c++
type (*function(parameter))[dimension];
int (*func(int i))[10]; 
```

##### 6.3.2.3、使用尾置返回类型

任何函数的定义都可以使用尾置返回，对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。

```c++
// 尾置返回类型跟在形参列表之后并以->符号开头，原来返回值类型的地方使用auto
auto func(int i) -> int(*)[10]; // 返回的是一个指针，该指针指向含有10个整数的数组
```

##### 6.3.2.4、使用decltype

对返回类型的数组进行decltype操作，将结果作为返回类型

```c++
int odd[] = {1, 2, 3, 4, 5, 6, 7};
decltype(odd)* func(int i);
```

>   **注**：decltype只会返回表达式的类型，decltype(odd)返回的是数组的类型，并不把数组类型转化成指针，需要附加一个*

### 6.4、函数重载

重载函数**只和函数名和形参列表有关，与`返回值的类型`无关**

#### 6.4.1、重载和const形参

[顶层const不影响传入函数的对象](#xingcandedingcengconst)，一个拥有:point_right::point_right:**顶层const的形参无法和另一个没有顶层const的形参**:point_left::point_left:区分开来

如果形参是某种类型的指针或引用，则**通过区分其指向的是常量对象还是非常量对象(底层const)**可以实现函数重载

传递一个**非常量对象**或者**指向非常量对象的指针**时，编译器优先选用**非常量版本**的函数，因为函数匹配采用最精准类型匹配，用非常量对象初始化常量引用需要类型转换，而接收非常量形参的版本则更精确匹配

#### 6.4.2、const_cast和重载

```c++
const string &shorterString(const string &s1, const string &s2);
string &shorterString(string &s1, string &s2) {
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string &>(s2));
    return const_cast<string&>(r);
}
```

#### 6.4.2、重载与作用域

<span id="shengmingzaineicunzuoyongdehanshubingbuhuichongzaishengmingzaiwaicengzuoyongyudehanshu">如果在内层作用域中声明名字，它将:point_right::point_right:**隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名**:point_left::point_left:：</span>

```c++
// 全局作用域
void print(double);
void print(const string &);
void fooBar(int val) {
    int ival;
    // 局部作用域
    void print(int);
    print("value : "); // 错误：void print(const string &)被隐藏了
    print(ival); // 正确：调用void print(int)
    print(3.14); // 正确：调用void print(int)，void print(double)被隐藏掉了
}
```

**在C++中，名字查找发生在类型检查之前**，`print("valur: ")`先查找`print`名字的函数，在内层作用域中查找到`void print(int)`，然后再进行类型检查报错

### 6.5、特殊用途语言特性

#### 6.5.1、默认实参

**一旦某个形参被赋予了默认值，后面所有形参都必须有默认值**

函数调用时实参按其位置解析，**默认实参负责填补调用缺少的`尾部实参`(靠右边的位置)**

>   **Tips**：合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，让经常使用默认值的形参出现在后面

允许多次声明同一个函数，函数的**后续声明只能为之前那些没有默认值的形参添加默认实参**

```c++
string screen(sz, sz, char = ' ');
string screen(sz, sz, char = '*'); // 不能改变已有的默认值
string screen(sz = 24, sz = 45, char);
```

>   **说明**：默认形参可以出现在函数声明或者定义中，但不能同时给形参赋默认值

#### 6.5.2、constexpr函数

定义constexpr函数的方法需要遵循几项约定：

-   函数的**返回值类型及所有的形参**都得是[字面值类型](#zimianzhileixingdedingyi)
-   函数体中必须有且只有一条return语句，也可以包含其他语句，**只要这些语句在`运行时`不执行任何操作就行**

执行初始化任务时，**编译器把对constexpr函数的调用替换成其结果值**，为了能在编译过程中随时展开，constexpr函数被隐式地指定为**内联函数**

constexpr函数的返回值：

-   如果实参是常量表达式，返回值就是常量
-   如果实参是非常量表达式，返回值就不是常量

```c++
constexpr int new_sz() { return 42; }
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; } // 返回值并非一定是常量，取决于实参的类型
```

>   **说明**：constexpr函数需要在函数的开头用constexpr标记

#### 6.5.3、调试帮助

assert宏定义在头文件`cassert`中，assert宏常用于检查`不能发生`的条件

定义`NDBUG`能避免检查各种条件所需的运行时的开销，此时根本不会执行运行时检查

### 6.6、函数指针

函数的类型由`返回类型`和`形参类型`共同决定，与函数名无关

```c++
bool (*pf)(const string &, const string &); // *pf外层的括号必不可少
```

把函数名作为一个值使用时，该函数**自动地转换成指针**，可以直接使用指向函数的指针调用该函数，无需提前解引用指针

```c++
pf = lengthCompare;
pf = &lengthCompare; // 两种写法等价
bool b1 = pf("hello", "jdiehyg");
bool b2 = (*pf)("hello", "jdiehyg");
bool b3 = lengthCompare("hello", "jdiehyg");
```

#### 6.6.1、函数指针形参

##### 6.6.1.1、使用指向函数的指针

```c++
void useBigger(const string &s1, const string &s2, bool pf(const string &, const sring &)); // 自动将pf转化为指向函数的指针
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const sring &));
```

##### 6.6.1.2、使用类型别名

```c++
typedef bool Func1(const string &, const string &); // Func1是函数类型，不是函数指针
typedef decltype(lengthCompare) Func2; // // Func2是函数类型，不是函数指针
typedef bool (*Func3)(const string &, const string &); // Func3是函数指针
typedef decltype(lengthCompare) *Func4; // // Func4是函数指针

void useBigger(const string &s1, const string &s2, Func1); // 自动将Func1转换成函数指针
void useBigger(const string &s1, const string &s2, Func3); 
```

#### 6.6.2、返回指向函数的指针

##### 6.6.2.1、使用类型别名

```c++
using F = int(int*, int);
usinf PF = int(*)(int*, int);
PF f1(int);
F *f1(int);
```

##### 6.6.2.2、使用返回类型尾置

```c++
auto f1(int) -> int (*)(int*, int);
```

##### 6.6.2.3、使用decltype

```c++
string::size_type sumLength(const string&, const string&);
decltype(sumLength) *getFcn(const string &);
```

>   **注**：decltype只返回表达式原本的类型，只会返回函数类型，不会转化成相应的指针类型

## 7、类

**类的基本思想是`数据抽象`和**`封装`：

-   **数据抽象**：是一种依赖于**接口**和**实现**`分离`的编程技术
    -   **类的接口**：包括用户所能执行的操作
    -   **类的实现**：包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数
-   **封装**：实现了类的接口与实现的分离，封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分

两个类的成员完全一样，只要类名不一样就是不同的类

**类的前向声明**：只声明类而暂时不定义这个类

 <span id="buwanquanleixing">**不完全类型**</span>：在声明之后定义之前都属于不完全类型，可以定义指向这种类型的指针或引用，也可以声明(但不能定义)以不完全类型作为参数或返回值的函数

### 7.1、定义抽象数据类型

**类是一种类型，对象是类类型的变量**

#### 7.1.1、成员属性(数据成员)

**数据成员**定义了类的对象的具体内容，**每个对象有自己的一份数据成员拷贝**，修改一个对象的数据成员，不会影响其他的对象的数据成员。

可以为数据成员提供一个[类内初始值](#leineichushizhihuakuohao)，**或放在花括号里**，**或放在等号右边**，`但不能用圆括号`，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被[默认初始化](#morenchushihua)

```c++
class Test {
private:
    //类内初始值
    int a = 0; // 正确
    int b{1}; // 正确
    int c(2); // 错误
};
```

>   **补充**：
>
>   -   类在内存中存储分为**数据区**和**方法区**，每一个对象对应**不同的数据区，而方法区是共享的**
>
>       ![image-20211118220526028](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211118220526028.png)
>
>   -   `sizeof(类名)`只包括**数据区**的存储大小，不包括**方法区**的存储大小，**方法区**的存储大小在编译期就已经确定，创建对象时，不会拷贝**方法区**的内容，只会拷贝一份**数据区**的内容

##### 7.1.1.1、定义一个类型成员

除了定义数据和函数成员之外，类还可以**自定义某种类型在类中的别名**，由类定义的类型别名和其他成员一样存在访问限制，可以是**public**或者**private**

用来**定义类型的成员必须**`先定义后使用`，类型成员通常出现在类开始的地方

在类的作用域之外，**类类型成员则使用**`作用域运算符`访问

```c++
class Screen {
public:
    typedef string::size_type pos;
    // using pos = string::size_type;
};

int main() {
    Screen::pos ht = 24; // 类的作用域之外，类类型成员使用作用域运算符访问
}
```

##### 7.1.1.2、可变数据成员

可以通过在数据成员的声明中加入`mutable`关键字，来实现在`const`**的成员函数**中修改数据成员

**可变**`数据成员`永远不会是`const`的，即使是`const`对象的成员，**一个`const`成员函数可以改变一个可变成员的值**

```c++
class A {
private:
    mutable int i;
public:
    A() = default;
    A(int ii) : i(ii) {}
    void f() const { // const成员函数可以改变可变成员的值
        i = 18; // 正确
        return ;
    }
};
```

#### 7.1.2、成员方法(成员函数)

成员函数的**声明必须在类的内部**，定义既可以在类的内部也可以在类的外部，**定义在类内部**的函数是**隐式的inline函数**

##### 7.1.2.1、`this`指针

成员函数通过一个名为`this`的额外的**隐式参数**来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化`this`

每一个成员函数都隐式含有`this`指针，成员方法在底层中的真实面貌：`void func(this, x)`，参数列表的第一个参数是一个隐藏的参数`this`，**默认赋值为调用的对象**，任何对类成员的直接访问都被看做`this`的隐式引用

因为`this`总是指向**这个**对象，所以`this`是一个**常量指针**，不允许改变`this`中保存的地址

```c
A a;
a.func(123); // 等价于 func(&a, 123); 
             // 成员函数原型：void func(int num) ==>> void func(const A *this, int num)
             // this的类型：const A * 
```

`this`的形参是隐式定义的，任何自定义名为`this`的参数或变量的行为都是非法的

##### 7.1.2.2、const成员函数

默认情况下，`this`的类型是**指向类类型**`非常量版本`的常量指针，因为`this`是隐式的，所以不能直接通过更改`this`的类型来绑定到一个**常量对象**上，在C++中允许**把`const`关键字放在成员函数列表之后来表示`this`是一个`指向常量`的常量指针**，使用`const`的成员函数被称为**常量成员函数**

```C++
void func(int x) const;
```

**常量对象，以及常量对象的引用或指针都`只能`调用常量成员函数**，而`非常量对象`**既可以调用常量成员函数，也可以调用普通成员函数**，对于`非常量对象`**优先**匹配普通成员函数，如果不存在普通成员函数则匹配常量成员函数

一个`const`成员函数如果以引用的形式返回`*this`，那么它的返回类型将是**常量引用**，因为此时的`this`是`const`的

```c++
class A {
public:
    A(int j) : i(j) {}
    const A& func() const { // 返回值类型为常量引用类型
        i = 234;
        return *this;
    }
private:
    mutable int i = 0;
};
```

通过区分成员函数是否是`const`的，可以对成员函数进行重载。非常量版本的函数对于常量对象是不可用的，只能在一个常量对象上调用`const`成员函数，虽然非常量对象可以调用常量版本或非常量版本，但会优先匹配非常量版本

##### 7.1.2.3、类作用域和成员函数

编译器分两步处理类：

-   首先编译成员的声明
-   再编译成员函数体

所以**成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序**

##### 7.1.2.4、在类的外部定义成员函数

成员函数的定义必须和它的声明匹配，包括返回类型、函数名、参数列表，如果是常量成员函数，定义时还需要确定`const`属性，同时类外定义还需要指明类名

```c++
double Sales_data::avg_price() const {}
```

##### 7.1.2.5、令成员作为内联函数

**定义在类内部**的成员函数是**自动inline**的，可以在类的内部把`inline`作为声的一部分显示地声明成员函数，同样的，也可以在类外部用`inline`关键字修饰函数的定义

```c++
class A {
public:
    A(int j) : i(j) {}
    const A& func() const;
private:
    mutable int i = 0;
};
inline const A& A::func() const {
    i = 234;
    return *this;
}
```

>   **说明**：可以同时在声明和定义的地方同时说明`inline`，这是合法的，不过，最好**只在类外部定义的地方说明`inline`**

#### 7.1.3、构造函数

构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数

**创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其`常量`属性**，构造函数在const对象的构造过程中可以向其写值

```c++
class A {
public:
    A(int ii) {
        i = ii;
        j = ii;
    }
    A(int ii, int jj) : i(ii), j(jj) {}
private:
    int i, j;
};

int main() {
    const A a(23);
    const A b(345);
    return 0;
}
```

>   **注**：构造函数不能被声明成`const`的，因为构造函数是用来初始化对象的数据成员，需要更改数据成员，所以不能声明成`const`的

##### 7.1.3.1、合成的默认构造函数

**合成的默认构造函数**：编译器创建的构造函数

只有当类**没有声明任何构造函数**时，编译器才会**自动地生成**默认构造函数

<span id="hechengmorengouzaohanshu">合成的默认构造函数的初始化规则</span>：

-   如果存在类内初始值，用初始值初始化成员
-   否则，[默认初始化](#morenchushihua)

不能依赖合成的默认构造函数的情况：

-   类内有自定义的构造函数，编译器不会生成合成的默认构造函数

-   定义在块中的内置类型或复合类型的对象被默认初始化，它们的值是未定义的
-   **如果类包含其他类类型的成员，并且其他类没有默认构造函数，此时编译器不能为此类生成合成的默认构造函数**:star::star:

如果需要默认构造函数，可以通过在参数列表后面写上`= default`来要求编译器生成构造函数。`= default`既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。在类内使用`= default`，则默认构造函数是**内联**的，在类外使用时，默认是非内联的

```c++
// 类内 = default
class Sales_data {
public:
    Sales_data() = default; //类内声明 定义
private:
    string bookNo;
    unsigned units_sold = 0;
    double revenue = 0;
};

// 类外 = default
class Sales_data {
public:
    Sales_data(); // 类内声明
private:
    string bookNo;
    unsigned units_sold = 0;
    double revenue = 0;
};
Sales_data::Sales_data() = default; // 类外定义
```

##### 7.1.3.2、构造函数初始化列表

初始化列表负责为新创建的对象的一个或几个数据成员赋初值，构造函数初始值是成员名字的一个列表，每个名字后面紧跟**括号(或花括号)**括起来的成员初始值，不同成员的初始化通过**逗号**分隔开来

```c++
Sales_data(const string &s) : bookNo(s), units_sold(0), revenue(0) {}
```

当某个数据成员被构造函数初始值列表忽略时，该成员将在`构造函数体之前`**以[合成默认构造函数](#hechengmorengouzaohanshu)相同的方式隐式初始化**

初始化列表的**初始化顺序**是根据**成员属性的`声明`顺序**有关，与初始化列表的先后顺序无关，初始化列表规定了每一个成员属性的构造形式

>   **注**：最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，**尽量避免使用某些成员初始化其他成员**

**构造函数在`{}`之前就已经初始化完成了**，如果没有初始化列表，在函数体中给成员属性赋值，需要**先初始化再赋值**操作，特别对于`const、引用`类型的**成员属性**会出错，其次就是效率更高。

```c++
// 初始化列表的形式
Data() : __x(100), __y(100), a(34)  //到此初始化已经结束
{
    //赋值操作
}
```

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211119194527170.png" alt="image-20211119194527170" style="zoom:80%;" />

>   **注**：注意区分`const`对象和`const`数据成员在构造时的区别
>
>   -   构造函数在**const对象**的构造过程中可以向其写值
>   -   类的**数据成员类型**如果是`const`或`引用`时，只能通过初始化列表或者类内初始值的方式进行初始化

##### 7.1.3.3、默认实参和构造函数

如果一个构造函数为**所有参数都提供了默认实参**，则实际上也就相当于定义了默认构造函数

##### 7.1.3.4、委托构造函数

**委托构造函数**：使用它所属的其他构造函数执行它自己的初始化过程

在委托构造函数内，成员初始值列表**只有一个唯一的入口，就是类名本身**，类名后面紧跟圆括号括起来的参数列表，**参数列表必须与另外一个构造函数匹配**

```c++
class Sales_data {
public:
    Sales_data(string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt * price) {} // 普通构造函数
    Sales_data() : Sales_data("", 0, 0) {} // 委托构造函数：委托 Sales_data(string s, unsigned cnt, double price)
    Sales_data(string s) : Sales_data(s, 0, 0) {} // 委托构造函数：委托 Sales_data(string s, unsigned cnt, double price)
    Sales_data(istream &is) : Sales_data() { read(is, *this); } // 委托构造函数：委托 Sales_data() : Sales_data("", 0, 0)
};
```

当一个构造函数委托给另一个构造函数时，**受委托的构造函数的初始值列表和函数体被依次执行**，最终将控制权交给**委托者的函数体**

##### 7.1.3.5、默认构造函数的作用

**当对象默认初始化或值初始化时自动执行默认构造函数**

默认初始化发生的情况：

-   在块作用域内不使用任何初始值定义一个非静态变量或数组时
-   当类本身含有类类型的成员且使用合成的默认构造函数时
-   当类类型的成员没有在构造函数初始值列表中显示初始化时

值初始化发生的情况：

-   在数组初始化过程中提供的初始值数量少于数组大小时
-   不使用初始值定义一个局部静态变量时
-   当我们通过书写形如T()的表达式显式地请求值初始化时，T()要执行默认构造函数生成临时变量，再赋值给变量

**默认构造函数的使用**：不需要在对象名后添加`()`，`Sales_data obj`即可

>   **说明**：
>
>   -   值初始化：在定义变量的时候，当场给变量赋值
>   -   默认初始化：在定义变量时，不做赋值操作，系统根据默认规则给变量赋初值
>
>   **Tips**：如果定义了其他构造函数，最好也提供一个默认构造函数

#### 7.1.4、拷贝、赋值和析构

##### 7.1.4.1、转换构造函数

如果**构造函数只接受**`一个实参`，则它实际上定义了转换为此类类型的隐式转换机制

>   **说明**：实参是指在**调用函数**时，函数名后面括号中的参数。如果有多个形参，但**其他形参都有默认值**，转换构造函数也是可以实现的

```c++
class A {
private : 
    int x;
public :
    A(int x) : x(x) {
        cout << this << " : Class A : " << x << endl;
    }
    A(const A &a) {
        cout << this << " : copy from : " << &a << endl;
    }
};
int main() {
    A a = 45; // 调用A(45)创建匿名对象，再将匿名对象拷贝给对象a
    cout << &a << endl;
    a = 78; // 调用A(78)创建匿名对象，再将匿名对象赋值给对象a
    return 0;
}
```

编译器只会自动地执行**一步类型转换**

```c++
// 成员函数 conbine 的原型为 void conbine(const Sales_data&);
item.conbine("9-999-9999"); // 错误：需要用户定义的两种转换
// 分析：
// 第一步："9-999-9999"转换成string类型的临时变量temp
// 第二步：将temp转换成Sales_data类型

string null_book = "9-999-9999";
item.conbine(null_book); // 正确：只进行一步转换
// 分析：
// 第一步：将string类型的变量null_book转换成Sales_data类型
```

类构造函数默认是`implicit`隐式的， `explicit`关键字可以抑制构造函数定义的隐式转换，`explicit`只对一个`实参`的构造函数(**如果构造函数的其他参数都有默认值也可以**)有效。只能**在类内声明构造函数时使用`explicit`关键字，在类外定义时不应重复**

使用`explicit`构造函数时，只能以**直接初始化**的形式使用，**编译器不会`自动转换过程中`使用该函数**

```c++
Sales_data item = null_book; // 错误：编译器不会将string类型的null_book自动转换成Sales_data类型
Sales_data item(null_book); // 正确
```

但可以为转换**显示地使用构造函数**

```c++
Sales_data item = Sales_data(null_book); // 显式地通过构造函数创建临时对象
Sales_data item = static_cast<Sales_data>(null_book); // 使用显示类型转换
```

##### 7.1.4.2、拷贝构造函数

即使定义了其他构造函数，编译器也会**合成一个拷贝构造函数**，合成拷贝构造函数会将参数的`非static`成员逐个拷贝到正在创建的对象中，每个成员的类型决定拷贝形式，对于类类型的成员调用其拷贝构造函数来拷贝

使用**拷贝初始化**时，编译器将右侧运算对象拷贝到正在创建的对象中，如果需要还要进行类型转换，调用转换构造函数

**拷贝初始化发生的情形**：

-   使用`=`给对象赋值

-   将一个对象作为实参传递给一个**非引用**对象的形参
-   从一个返回类型为**非引用**类型的函数返回一个对象
-   用花括号初始化一个数组中的元素或者一个聚合类的成员
-   :question:<span id="charushifangruyigekaobei">某些类类型对其分配的对象使用拷贝初始化</span>:question:

**拷贝构造函数的参数必须是`const的引用`类型的原因**：

-   引用的原因：当实参赋值给形参时，要调用拷贝构造函数，如果参数不是引用类型，就会`无限循环递归`的调用拷贝构造函数
-   const的原因：
    -   兼容绑定匿名对象，匿名对象如果是**右值**的话，只能使用**const引用**接收
    -   逻辑上的限制，拷贝构造函数中不需要改变被拷贝对象
    -   兼容const类型的拷贝

##### 7.1.4.3、拷贝赋值运算符

与拷贝构造函数一样，如果未定义自己的拷贝赋值运算符，编译器会合成拷贝赋值运算符

为了和内置类型的赋值保持一致，赋值运算符通常**返回一个指向其左侧运算对象的引用**

```c++
Foo& operator=(const Foo& a) {}
```

**拷贝赋值运算符的使用场景**：

```c++
A a = 45; // 当=出现在对象的定义语句中时，调用的是拷贝构造函数
a = 78; // 当=出现在变量赋值而非定义语句中时，调用的拷贝赋值运算符
```

##### 7.1.4.4、析构函数

析构函数释放对象使用的资源，并销毁对象的`非static`数据成员

**析构函数没有参数，不能被重载，一个类只能有一个析构函数**

在一个析构函数中，**首先执行函数体然后销毁成员**，成员按初始化顺序的逆序销毁

**隐式销毁**一个**内置指针类型**的成员不会delete它**指向的对象**，而智能指针是类类型，具有自己的析构函数，智能指针成员在析构阶段会被自动销毁；**当指向一个对象的引用或指针离开作用域时，析构函数不会执行**

**调用析构函数的场景**：

-   变量在离开其作用域时被销毁
-   当一个对象被销毁时，其成员被销毁
-   容器被销毁时，其元素被销毁
-   对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
-   对于临时对象，当创建它的完整表达式结束时被销毁

**析构`函数体`自身并不直接销毁成员**，成员在析构函数体之后隐含的析构阶段中被销毁

##### 7.1.4.5、移动构造

新标准的一个最主要的特性时可以**移动而非拷贝对象**的能力，对象被拷贝后就立即销毁时可以用移动来代替拷贝

###### 7.1.4.5.1、右值引用

右值引用必须**绑定到右值**的引用，可以通过&&而不是&来获得右值的引用，右值引用只能绑定到一个**将要销毁**的对象

**左值表达式表示的是一个对象的身份，右值表达式表示的是对象的值**

左值持久，左值表常态：**只要变量有名字，就是左值**，包括**右值引用类型的变量**也是左值

```c++
int &&rr1 = 42;
int &&rr2 = rr1; // 错误：rr1是变量，左值
```

右值短暂，右值表临时：右值要么是字面常量，要么是表达式求值过程中创建的临时值

**左值右值的区分方法**：当代码运行到下一行，如果上一行表达式的值能够通过`单一的变量`访问到就是左值，否则是右值

**左值、右值和左值引用、右值引用无关，一个表达式只与左值右值有关**，**左值、右值是和`作用域`有关的，不同的作用域有可能是左值，有可能是右值**，为了消除作用域导致右值变为左值的情况，可以使用`move   forward`

```c++
void judge2(int x) {}
void judge(int &x) {
    judge2(x);//此处x为左值
    x = 2;
    return 0;
}
void judge(int &&x) { // 左值、右值和作用域有关 此处为右值
    judge2(x);//此处x为左值，左值和左值引用、右值引用无关，x只与左值、右值有关，此处的x判断为左值
    x = 2;
    return 0;
}
```

左值引用：不能绑定到**要求转换的表达式、字面常量或返回右值的表达式**

右值引用：与左值引用相反，不能将右值引用绑定到左值上

返回左值引用的函数，连同**赋值、下标、解引用和`前置`递增/递减运算符**，都是返回左值的表达式，左值引用可以绑定到返回左值表达式的结果上

返回非引用类型的函数，连同**算术、关系、位以及后置递增/递减运算符**，都生成右值，右值引用或const的左值引用绑定到返回右值表达式的结果上

###### 7.1.4.5.2、move和foward

<span id="moveshixianyouzhiyinyongbangdingzuozhiyinyong">`move`可以**将左值转换为对应的右值引用类型**，调用move之后，对于**移后源**对象，**只能对它赋新值或者销毁**，不能使用移后源对象的值</span>

`move`的实现源码：

```c++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    return static_cast<typename remove_reference<T>::type&&>(t);
}
```

**引用的绑定规则**：

```markdown
非常量左值引用（X& ）：只能绑定到X类型的左值对象；
常量左值引用（const X&）：可以绑定到 X、const X类型的左值对象，或X、const X类型的右值；
非常量右值引用（X&&）：只能绑定到X类型的右值；
常量右值引用（const X&&）：可以绑定规定到X、const X类型的右值。
```

**引用的折叠规则**：模板实例化、typedef、auto类型推断中使用折叠规则

```C++
T& & 变为 T&
T& && 变为 T&
T&& & 变为 T&  
T&& && 变为 T&&  
```

总结：

-   所有右值引用折叠到右值引用上仍然是一个右值引用
-   所有的其他引用类型之间的折叠都将变成左值引用

`forward`的实现源码：

```c++
template<class T>
constexpr T&& forward(std::remove_reference_t<T>& arg) noexcept{
    // forward an lvalue as either an lvalue or an rvalue
    return (static_cast<T&&>(arg));
}

template<class T>
constexpr T&& forward(std::remove_reference_t<T>&& arg) noexcept{
    // forward an rvalue as an rvalue
    return (static_cast<T&&>(arg));
}
```

如果x是一个非引用类型，`forward<x>() == forward<x&&>()`都是处理成右值，因为`forward<x>`返回类型是`x&&`，而`x&& && == x&&`

如果x是一个非引用类型，`forward<x&>()`是处理成左值，因为`forward<x>`返回类型是`x&&`，而`x& && == x&`

由源代码可知：`forward`可以将`右值，左值`转换成`右值`，但不能将`右值`转换成`左值`

###### 7.1.4.5.3、移动构造函数和移动赋值运算符

移动构造函数的第一个参数是`右值引用`，与拷贝构造函数一样其他的任何额外的参数都必须有默认实参

**除了完成资源移动，移动构造函数必须确保移后源对象处于这样一个状态——销毁它是无害的**，`一旦资源完成移动，源对象必须不再指向被移动的资源`

```c++
Array(Array &&x) : data(x.data) { //直接改名字
	a.data = nullptr; //将右值名字指向空指针，避免析构时重复析构造成段错误
}
```

编写移动操作时，必须确保将**移后源对象进入一个可析构的状态**，除了将移后源对象置为析构安全的状态之外，移动操作还必须**保证对象仍然有效**，可以安全地为其赋新值或者可以安全地使用而不依赖其当前值，另一方面，**移动操作对移后源对象留下的值没有任何要求，不应该依赖于移后源对象中的数据**

编译器**不会自动合成移动操作**，只有当类没有定义任何自己版本的控制拷贝成员，且类的每个非static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员，如果一个成员时类类型，且该类有对应的移动操作，编译器也能移动这个成员

**定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认地被定义为删除的**

**如果一个类既有移动构造函数也有拷贝构造函数时，如果一个值是`左值`，优先绑定`左值引用`版本(拷贝构造函数)，如果一个值是`右值`，`优先`绑定`右值引用`版本(移动构造函数)**。但**如果一个类只有拷贝构造函数时，不管是左值还是右值，都会调用拷贝构造函数，编译器不会合成移动构造函数，同时`&&`可以绑定到`const &`上**

**一般来说，不需要为函数操作定义一个接收`const X&&`或者是一个普通的`X&`参数的版本，只需要定义`const &`和`X&&`参数的版本即可**，所以移动构造函数的参数是`非const`的，拷贝构造函数的参数是`const`的

```c++
void push_back(const X&);
void push_bakc(X&&);
```

移动赋值运算符也需要遵循[自赋值](#zifuzhi)问题

>   **补充**：拷贝行为包括**拷贝构造函数**和**赋值运算符**

###### 7.1.4.5.4、右值引用和成员函数

如果一个成员函数同时提供拷贝或移动版本，通常**一个版本接受一个指向`const`的左值引用，一个版本接受一个指向非`const`的右值引用；一般来说不需要定义接受一个`const X&&`或一个普通的`X&`参数的版本**

区分移动构造和拷贝的重载函数通常有一个版本接受一个`const T&`，而另一个版本接受一个`T&&`

通常，在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值；可以通过**引用限定符**指出`this`的左值、右值属性，引用限定符只能用于非`static`成员函数，且**必须同时出现在函数的声明和定义中**

对于`&`限定的函数，只能用于左值，对于`&&`限定的函数，只能用于右值

一个函数可以同时用`const`和引用限定，**引用限定必须跟随在`const`限定符之后**

```c++
class Foo {
public:
    Foo &operator=(const Foo&) const &;
};
```

引用限定符可以区分重载版本，**如果定义两个或者两个以上具有相同名字和相同参数列表的成员函数，必须对所有函数都加上引用限定符，或者都不加**

##### 7.1.4.6、三/五法则(:point_right:经验:point_left:)​

<span id="需要自定义的析构函数的类也需要自定义的拷贝和赋值操作">需要自定义的析构函数的类也需要自定义的拷贝和赋值操作</span>

需要自定义的拷贝操作的类也需要自定义的赋值操作，反之亦然

##### 7.1.4.7、使用=default

拷贝构造函数和赋值运算符都可以定义为`=default`，用法和构造函数的用法一致

##### 7.1.4.8、阻止拷贝

将拷贝构造函数或赋值运算符定义**删除的**或者**不可访问的**，可以阻止拷贝

`=delete`**必须**出现在函数`第一次`**声明**的时候，与`=default`的用法不同

**析构函数不能是删除的成员**

<span id="就像其他任何类的情况一样">编译器将合成的成员定义为删除的函数</span>：

-   如果类的**某个成员**的`析构函数`是删除的或不可访问的，则类的合成析构函数被定义为删除的
-   如果类的某个成员的**拷贝构造函数或者析构函数**是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的
-   如果类的某个成员的**拷贝赋值运算符**是删除的或不可访问的，或者**类有一个const的或引用成员**，则类的合成拷贝赋值运算符被定义为删除的
-   如果类的某个成员的**析构函数**是删除的或不可访问的，或者**类有一个引用成员并没有类内初始化器**，或者**类有一个const成员并没有类内初始化器且其类型未显式定义默认构造函数**，则类的默认构造函数被定义为删除的

总结：**如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将定义为删除的**

类可以将**拷贝构造函数和拷贝赋值运算符声明为private**来阻止拷贝，声明成private只能阻止用户代码不能拷贝，但友元函数和成员函数仍旧可以拷贝，所以需要将拷贝构造函数和拷贝赋值运算符**声明成privatede ，并不定义它们**

##### 7.1.4.9、拷贝控制和资源管理

###### 7.1.4.9.1、行为像值的类

类的行为像一个值，意味着它应该有自己的状态，**当拷贝一个像值的对象时，副本和原对象是完全独立的，需要进行深拷贝**

**赋值运算符通常组合了析构函数和构造函数的操作**，类似析构函数，赋值操作会销毁左侧运算对象的资源，类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据，**必须先执行销毁左侧资源操作，再拷贝右侧资源**

<span id="zifuzhi">自定义赋值运算符需要满足</span>：:star::star:**如果将一个对象赋予它自身，赋值运算符必须能正常工作**，通常需要先拷贝参数对象，然后再进行销毁左侧资源:star::star:

```c++
HasPtr& HasPtr::operator=(const HasPtr &rhs) {
	auto newp = new string(*rhs.ps); // 先拷贝参数对象有可能被释放的资源
    delete ps; // 释放左侧资源
    ps = newp; // 拷贝右侧资源
    i = rhs.i;
    return *this;
}
```

**类中成员属性含有`指针、其他类对象`等，需要自定义拷贝构造函数实现深拷贝**

**相关例子**：

```c++
class A {
public :
    int x, y;
}; 

ostream &operator<<(ostream &out, const A &a) {
    out << "(" << a.x << ", " << a.y << ")";
    return out;
}

template<typename T>
class Vector {
public :
    Vector(int n = 100) : n(n), data((T *)calloc(sizeof(T), n)) {} // 避免T类型没有默认构造函数，使用new的话会是未定义的
    Vector(const Vector &a) : n(a.n) { // 有指针成员，需要深拷贝
        data = (T *)malloc(sizeof(T) * n);//此处不能使用new，原因同上
        for (int i = 0; i < n; i++) {
            new(data + i) T(a.data[i]);//new的定位构造，实现副本和原本数据一致，但互不影响
        }
        return ;
    }
    T &at(int ind) { return data[ind]; }
    T &operator[](int ind) { return data[ind]; }
    void output(int m = -1) {
        if (m == -1) m = n;
        cout << "arr " << this << " : ";
        for (int i = 0; i < m; i++) {
            cout << data[i] << " ";
        }
        cout << endl;
        return ;
    }

private:
    int n;
    T *data; 
};
```

###### 7.1.4.9.2、行为像指针的类

行为像指针的类则共享状态，当拷贝一个像指针的对象时，**副本和原对象使用相同的底层数据**

需要使用类似`shared_ptr`中的`引用计数`技术来管理类中的资源，当引用技术为0时，才销毁资源

可以**将`计数器`保存在`动态内存`中**，当拷贝或赋值时，拷贝指向计数器的`指针`，这样副本和原对象会使用相同的计数器

### 7.2、访问控制与封装

在C++中，使用**访问说明符**加强类的封装：

-   定义在**public**说明符之后的成员在**整个程序内**可被访问，**public**成员定义类的接口
-   定义在**private**说明符之后的成员可以被**类的成员函数**访问，但是不能被使用该类的代码访问，**private**部分封装了类的实现细节

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211119212317875.png" alt="image-20211119212317875" style="zoom: 67%;" />

每个访问说明符制定了接下来的成员的访问级别，其**有效范围直到出现下一个访问说明符或者到达类的结尾处为止**

`struct`和`class`的唯一区别：**默认访问权限不一样**，`struct`默认访问权限是`public`，`class`默认访问权限是`private`

>   **Tips**：定义类的所有成员是**public**时，使用`struct`；如果是`private`时，使用`class`

#### 7.2.1、友元

**友元**可以允许其他类或者函数访问**类内非公有成员**，可以在**类内**通过`friend`来声明该类的**友元类或函数**

友元**声明只能出现在类定义的内部，但是在类内出现的具体的位置不限**，友元不是类的成员，不受所在区域的访问控制级别的约束

>   **Tips**：最好在类定义开始或结束前的位置集中声明友元

友元的**声明仅仅指定了访问的权限**，而**非一个通常意义上的函数声明**，如果类的用户能够调用某个友元函数，必须在**类内友元声明之外再专门对函数进行一次声明**

>   **说明**：许多编译器未强制限定友元函数必须在使用之前在类的外部声明，但为了**安全起见最好在使用之前在类的外部声明**

##### 7.2.1.1、类之间的友元关系

如果一个类指定了友元类，则**友元类的成员函数可以访问此类包括非公有成员在内的所有成员**

```c++
class Screen {
    friend class Window_mgr;
};
```

**友元关系不存在传递性**，每个类负责控制自己的友元类或者友元函数

##### 7.2.1.2、令成员函数作为友元

当把一个**成员函数声明成友元**时，必须指出该成员函数**属于哪个类**

```c++
class Screen {
    friend void Window_mgr::clear(ScreenIndex);
};
```

要想令某个成员函数作为友元，必须按照如下方式设计程序：

-   首先定义**Window_mgr**类，其中声明**clear**函数，**但不能定义它**。在clear使用Screen的成员之前**必须先声明Screen**
-   接下来**定义**Screen，包括对于clear的友元声明
-   最后定义clear，此时clear函数才可以使用Screen的成员

```c++
class Screen; // 1、前向声明Screen类
class Window_mgr { // 2、定义Window_mgr类
public:
    using ScreenIndex = vector<Screen>::size_type;
    void clear(ScreenIndex); // 3、只声明clear函数
private:
    vector<Screen> screens;
};

class Screen { // 4、定义Screen类
private:
    typedef string::size_type pos;
    friend void Window_mgr::clear(ScreenIndex); // clear友元声明
public:
    size_t access_ctr;
    Screen(pos s, pos b, string c) : cursor(s), height(b), contents(c) {}
private:
    pos cursor;
    pos height;
    string contents;
};
void Window_mgr::clear(ScreenIndex i) { // 定义clear
    Screen &s = screens[i];
    s.contents = string(s.height * 2, ' ');
}
```

>   **注**：
>
>   -   重载函数要声明为友元，必须逐个声明为友元
>   -   友元函数不能直接访问类内成员，只能**访问对象的成员**

##### 7.2.1.3、友元声明和作用域

**类和非成员函数的声明不是必须在它们的友元声明之前**。当一个名字第一次出现在一个友元`声明`中时，隐式地假定改名字在当前作用域中是可见的

**如果是在类的内部定义友元函数，也必须在类的外部提供相应的声明使得函数可见**，如果成员函数用到友元函数，友元函数的**类外声明**必须在**成员函数调用友元函数之前出现**，如果是类内调用，需要在类作用域之前声明

```c++
void func();
struct x {
public:
    x(int a) : s(a) {}
    friend void f() { // 类内定义友元函数
        x sd;
    	cout << sd.s << endl;
    }
    x() { f(); } // 类内调用友元函数，需要在类作用域之前声明友元函数
    void g();
    void h();
private:
    int s;
};
void x::g() { return f(); }; // 错误：f还没被声明
void x::h() { return f(); }; // 正确
```

>   **说明**：
>
>   -   如果友元函数中**通过对象**用到类的成员，友元函数的声明和类成员的声明之间的相对位置无关
>   -   **如果类的成员用到友元函数，友元函数必须在`类定义之前`声明或者在`成员函数类外定义之前`定义**，总之，要保证友元函数要在成员函数定义之前可见

### 7.3、类的其他特性

#### 7.3.1、类的作用域

在类的作用域之外，普通数据和函数成员只能由**对象、引用或者指针**使用`成员运算符`访问，类的`类型成员`**使用`作用域`运算符访问，跟在运算符之后的名字都必须是对应类的成员**

在类的外部，成员的名字都被**隐藏起来**，一旦遇到类名，定义的剩余部分(参数列表、函数体，**但不包括函数返回类型**)就在类的作用域之内了，可以**直接**使用类内的其他成员

```c++
// 在Window_mgr::之后，就处于类内，ScreenIndex可以直接使用
void Window_mgr::clear(ScreenIndex i) { 
    Screen &s = screen[i]; // Window_mgr类内的screen[i]成员直接访问
    s.contents = string(s.height * s.width, ' ');
}
```

函数的返回类型通常出现在**函数名之前**，在类外部定义成员函数时，**返回类型中使用的名字都位于类作用域之外，`返回类型必须指明是哪个类的成员`**

```c++
class Window_mgr {
public:
    ScreenIndex addScreen(const Screen&);
};
// 在类外定义成员函数
Window_mgr::ScreenIndex // 返回类型使用的名字位于类外，必须指明属于哪个类   
Window_mgr::addScreen(const Screen& s) {}
```

##### 7.3.1.1、名字查找与类的作用域

**名字查找**(寻找与所用名字最匹配的声明过程)的过程：

-   首先，在名字所在的块中寻找其声明语句，**只考虑在名字的使用`之前`出现的声明**
-   如果没找到，继续查找外层作用域
-   如果最终没找到匹配的声明，则程序报错

类的**定义**分两步处理：

-   首先，编译成员的声明 
-   直到类全部可见后才编译函数体  ===>>>>  成员函数可以使用类内任何数据成员

对于类内**成员函数**，解析其中名字的方式(**只适用于成员函数的名字查找**)：

-   首先，在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才被考虑
-   如果在成员函数内没找到，则在类内继续查找，**类的所有成员都可以被考虑**<区别之处>
-   如果类内也没找到该名字的声明，在成员函数之前的作用域内继续查找


上述的方式只适用于成员函数中(`函数体`)使用的名字，**声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见**

```c++
typedef double Money;
string bal;
class Account {
public:
    Money balance() { return bal; } // 
private:
    Money bal; // Money在使用之前，需要可见
};
```

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211120153656589.png" alt="image-20211120153656589" style="zoom:80%;" />

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211120154111789.png" alt="image-20211120154111789" style="zoom:80%;" />

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211120153904546.png" alt="image-20211120153904546" style="zoom:80%;" />

一般来说，内层作用域可以重新定义外层作用域的名字，即使该名字已经在内层作用域使用过。**然而在类中，如果成员使用了外层作用域中的某个名字，而这个名字代表一种类型，则类内不能在之后重新定义该名字**

>   **Tips**：类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后

如果类内、类外还有相同的变量名，可以通过`this->`或`类名::`来指明使用的是类内变量

```c++
void Screen::dummy_fcn(pos height) {
    cursor = width * this->height;
    cursor = width * Screen::height;
}
```

可以通过作用域运算符来指定哪个区域的名字：

-   全局作用域：`::变量名`
-   其他类：`类名::成员名`

当**成员定义在类的外部**时，名字查找的第三步不仅要考虑定义之前的全局作用域中的声明，**还需要考虑在成员函数`定义之前`的全局作用域中的声明**

```c++
int height;
class Screen {
public:
    typedef string::size_type pos;
    void setHeight(pos);
    pos height = 0;
};
Screen::pos verify(Screen::pos); // verify对Screen类的定义是不可见的
void Screen::setHeight(pos var) { // 成员函数定义之前的全局作用域中声明了verify
    height = verify(var);
}
```

#### 7.3.2、聚合类

当一个类满足如下条件时，这个类是聚合的：

-   所有成员都是public的
-   没有定义任何构造函数
-   没有类内初始值
-   没有基类，也没有virtual函数

聚合类具有特殊的初始化语法形式，可以使用**花括号括起来的成员初始值列表来初始化聚合类的数据成员**

```c++
Data vall = {0, "Anna"};
```

**初始值的顺序必须与声明的顺序一致**，与初始化数组元素的规则一样，不允许初始值列表的元素个数超过类的成员数量

#### 7.3.3、字面值常量类

**数据成员都是`字面值类型`的`聚合类`是字面值常量类**，对于非聚合类来说，符合下述要求，也是一个字面值常量类：

-   数据成员都必须是[字面值类型](#1.1.4.4、constexpr和常量表达式)
-   类必须**至少含有一个constexpr构造函数**
-   如果一个数据成员含有**类内初始值**，则**内置类型成员的初始值必须是一条`常量表达式`**；或者如果成员属于某种类类型，则初始值必须使用**成员自己的constexpr构造函数**
-   类必须使用**析构函数的默认定义**

尽管构造函数不能是`const`的，但是**字面值常量类的构造函数可以是`constexpr`函数**。`constexpr`构造函数可以声明成`= default`的形式，否则`constexpr`构造函数必须既符合构造函数的要求(不能包含返回语句)，又要符合`constexpr`函数的要求(能拥有的唯一可执行语句就是返回语句)，所以**constexpr构造函数体应该是空的**。

使用前置关键字`constexpr`就可以声明一个`constexpr`构造函数

```c++
class Debug {
public:
    constexpr Debug(bool b = true) : hw(b), io(b), other(b) {}
    constexpr Debug(bool h, bool i,, bool o) : hw(b), io(b), other(b) {}
private:
    bool hw;
    bool io;
    bool other;
};
```

`constexpr`构造函数必须**初始化所有数据成员**，可以通过初始值或者使用constexpr构造函数或者一条常量表达式的形式

`constexpr`构造函数用于生成`constexpr`对象以及`constexpr`函数的参数或返回类型

#### 7.3.4、:star:类的静态成员(类成员、类属性)

##### 7.3.4.1、声明静态成员

在成员的声明之前加上关键字`static`使得其与类类型关联在一起，静态成员可以是`public`或者`private`的，静态数据成员的类型可以是常量、引用、指针、类类型等

**类的静态成员存在于任何对象之外**，对象中不包含任何与静态数据成员有关的数据。静态成员函数也不与任何对象绑定在一起，不包含`this`指针，**静态成员函数不能声明为const的**，不能在静态成员函数体内使用`this`指针

```c++
class Account {
public:
    static double rate() { return interestRate; }
    static void rate(double);
private:
    string owner;
    double amount;
    static double interestRate;
    static double initRate();
};
```

##### 7.3.4.2、使用静态成员成员

使用**作用域运算符**直接访问静态成员：

```c++
double r = Account::rate(); // 使用作用域运算符访问静态成员
```

虽然**静态成员**不属于类的某个对象，但仍然可以**使用类的对象、引用或者指针来访问静态成员**：

```c++
Account ac1;
Account *ac2 = &ac1;
// 因为静态成员属于类，是所有类的对象共享的，所以可以访问
r = ac1.rate(); // 通过对象的引用访问
r = ac2->rate(); // 通过对象的指针访问
```

**成员函数不用通过作用域运算符就能直接使用静态成员**

##### 7.3.4.3、定义静态成员

当在类外定义静态成员函数时，不能重复`static`关键字，`static`只能出现在类内部的声明语句，**指向类外部的静态成员时，必须指明成员所属的类名**

```c++
void Account::rate(double newRate) { }
```

类似于全局变量，静态数据成员定义在任何函数之外，一旦被定义，就将一直存在于程序的整个声明周期中

静态数据成员不属于任何对象，不能通过构造函数初始化

-   一般来说，不能在类内初始化静态成员，必须在类的外部定义和初始化每一个静态成员，一个静态成员只能定义一次
-   特殊情况：
    1.  `const整数类型(bool,char,int,short,long等)`的静态数据成员`可以`使用**类内初始值来初始化，`也可以`类外定义和初始化**
    2.  :star::star:`constexpr`静态成员`必须`使用**类内初始值来初始化**

```c++
// 一般情况：类内声明，类外定义初始化
class Account1 {
private:
    static double interesrRate;
};
double Account1::interestRate = 3.2;

// 特殊情况：
class Account2 {
    // static const int period = 30; // const整数类型可以使用类内初始值初始化
    static const int period;
};
const int Account2::period = 30;

class Account3 {
    static constexpr int period = 30; // constexpr类型只能使用类内初始值初始化
};
```

如果某个静态成员的应用场景仅限于编译器可以替代它的值的情况，则一个初始化的const或constexpr不需要分别定义。相反，**如果将它用于值不能替代的场景中，则该成员必须有一条定义语句**

**如果在类的内部提供了一个初始值，则成员的`定义不能再指定一个初始值`了**

```c++
class Account {
public:
    static const int s = 12; // 类内指定了初始值
};
const int Account::s; // 类外定义不能再指定初始值
```

静态数据成员可以是[不完全类型](#buwanquanleixing)，静态数据成员的类型可以是它**所属的类类型**，而非静态数据成员则受到限制，只能声明成它所属类的指针或引用

静态成员可以作为**默认实参**，非静态成员不能作为默认实参

## 9、顺序容器

顺序容器为程序员提供了**控制元素存储和访问顺序**的能力，这种顺序不依赖于元素的值，而是**与元素加入容器时的位置**相对应

### 9.1、顺序容器概述

![image-20211207185608218](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207185608218.png)

`array`的大小是固定的，其他容器都提供高效、灵活的内存管理，可以添加和删除元素，扩张和收缩容器的大小

`string`和`vector`将元素保存在**连续的内存空间**中，支持`下标`来快速访问元素，但在容器**中间**添加和删除元素非常费时，需要移动所有在插入或删除位置之后的元素，有时还需要**分配额外的存储空间**，每个元素都得移动到新的存储空间

`list`和`forward_list`可以随意添加和删除元素，但不支持随机访问，**比`vector、deque、array`的额外内存开销要大**

`deque`支持**快速访问**，在容器中间插入和删除元素的代价高，但**在容器`两端`插入和删除元素代价低**

`array`**不支持添加和删除元素已经更改容器大小的操作**，`forward_list`**没有`size`操作**

### 9.2、容器库概览

顺序容器几乎可以保存任意类型的元素，**可以为不支持特定操作需求的类型定义容器，但只能使用那些没有特殊要求的容器操作**

#### 9.2.1、迭代器

与容器一样，迭代器有着公共的接口：如果一个迭代器提供某种操作，那么所有提供相同操作的迭代器对这个操作的实现方式是相同的。

**迭代器支持的运算**：

![image-20211207193251630](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207193251630.png)

**迭代器范围**：是由两个迭代器表示，两个迭代器分别指向同一个容器中的元素或者`尾元素之后`的位置(`end`)，采用的是`左闭右开`区间

![image-20211207192640212](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207192640212.png)

`begin`生成指向第一个元素位置迭代器，`end`生成指向尾元素之后位置的迭代器；迭代器`begin、end`必须**指向相同的容器**

带`r`开头的迭代器返回`反向`迭代器，以`c`开头的迭代器返回`const`迭代器

**当`auto`和`begin、end`结合使用时，获得的迭代器类型依赖于容器类型(`const`或`非const`)，但以`c`开头的版本总是能够获得`const_iterator`的，而不管容器的类型是什么**

**所有的迭代器操作不会生成元素，只能生成元素的引用**

>   **注**：`forward_list`容器的迭代器不支持`--`操作

##### 9.2.1.1、插入迭代器

插入器是一种**迭代器适配器**，接受一个容器，生成一个迭代器，能实现向给定容器添加元素；当通过一个插入迭代器进行**赋值时**，该迭代器**调用容器操作**来向给定容器的指定位置**插入**一个元素

**插入迭代器的操作**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208163158514.png" alt="image-20211208163158514" style="zoom: 67%;" />

**插入器的种类**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208163557975.png" alt="image-20211208163557975" style="zoom: 67%;" />

只有在容器支持`push_back, push_front, insert`的情况下，才可以使用相对应的插入器

当调用`inserter(c, iter)`时，得到一个迭代器，使用这个迭代器时，会将元素插入到`iter`原来所指向的元素之前的位置

```c++
auto it = inserter(c, iter);
*it = val; // 等价于 it = val
///////    等价操作   ///////
it = c.insert(it, val);
++it
```

##### 9.2.1.2、iostream迭代器

`istream_iterator`读取输入流，`ostream_iterator`向一个输出流写数据。这些迭代器将它们对应的流**当作一个特定类型的元素序列**来处理，通过使用流迭代器，可以用泛型算法从流对象读取数据以及向其写数据

###### 9.2.1.2.1、istream_iterator操作

当创建流迭代器时，必须**指定迭代器将要读写的对象类型**，`istream_iterator`要读取的类型必须定义了输入运算符，当创建一个`istream_iterator`时，可以将它绑定到一个流；如果**默认初始化**`istream_iterator`迭代器，创建一个可以当作**尾后值**使用的迭代器

```c++
istream_iterator<int> int_it(cin); // 指明要读写的对象类型int，绑定到输入流cin上
istream_iterator<int> int_eof; // 尾后迭代器
```

可以用`istream_iterator`从标准输入读取数据

```c++
istream_iterator<int> in_iter(cin);
istream_iterator<int> in_eof;
while (in_iter != in_eof) {
    vec.push_back(*in_iter++); // 从标准输入读取数据
} 
vector<int> vec1(in_iter, in_eof);
```

`istream_iterator`的操作：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208175709004.png" alt="image-20211208175709004" style="zoom:67%;" />

###### 9.2.1.2.2、ostream_iterator操作

可以对任何具有输出运算符`<<`的类型定义`ostream_iterator`，当创建一个`ostream_iterator`时，可以提供(可选的)第二参数，它是一个字符串，在**输出每个元素后都会打印此字符串**，此字符串必须是一个**C风格字符串**，**必须将`ostream_iterator`绑定到一个指定的流**，不允许**空的或表示尾后位置**的`ostream_iterator`

**ostream_iterator操作**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208181408222.png" alt="image-20211208181408222" style="zoom:67%;" />

```c++
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec) {
    *out_iter++ = e;
    // out_iter = e; // 使用 = 时，会将值写入到所绑定的流中
    // *out_iter = e; // *out_iter, out_iter++, ++out_iter都是一样的效果
}
```

>   **说明**：对于插入迭代器和输出流迭代器的`*、++`操作都是无效的，因为使用`=`时，可以直接将元素插入到容器或流中；

##### 9.2.1.3、反向迭代器

反向迭代器是在容器中**从尾元素向首元素反向移动**的迭代器，**递增**一个反向迭代器会移动到**前一个元素**，**递减**一个迭代器会移动到**下一个元素**，除了`forward_list`外，其他容器都支持反向迭代器，可以通过成员函数`rbegin, rend, crbegin, crend`获取反向迭代器

只能从既支持`++`也支持`--`的迭代器来定义反向迭代器，不能从一个`流迭代器`创建反向迭代器

`reverse_iterator`的`base`成员函数可以**将反向迭代器转换为普通迭代器**，使用反向迭代器，遍历顺序总是从后往前，使用普通迭代器，遍历顺序总是从前往后

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208183522198.png" alt="image-20211208183522198" style="zoom:67%;" />

#### 9.2.2、容器类型成员

![image-20211207192459063](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207192459063.png)**使用这些类型，需要显示使用`类名::`**

#### 9.2.3、容器的定义和初始化

![image-20211207195658431](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207195658431.png)

除了`array`外，其他所有容器的默认构造函数都会创建一个指定类型的`空容器`

创建**一个容器**为另一个容器的**拷贝**，**两个容器的类型及其元素类型必须相等**；

当**传递迭代器参数**来拷贝一个范围时，不要求**容器类型**必须相同，并且新容器和原容器的**元素类型**可以不同，**只要能将拷贝的元素转换为要初始化的容器的元素类型即可**

`顺序容器`还提供了接受**一个容器大小和一个(可选的)元素初始值**，如果不提供元素初始值，标准库会创建一个**值初始化器**。如果元素类型是内置类型或者具有默认构造函数的类类型，可以只为构造函数提供一个容器大小的参数，**如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个`显式的`元素初始值(用来调用相关的构造函数)**

与内置数组一样，`array`的**大小**也是类型的一部分，当定义一个`array`时，除了指定元素类型，还要指定容器大小

```c++
array<int, 3>
```

默认构造的`array`是非空的，包含了与其大小一样多的元素，这些元素都被`默认初始化`；如果对`array`进行列表初始化，不够的部分会进行`值初始化`

**不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制，但要求类型和大小必须相等**

#### 9.2.4、赋值和swap

![image-20211207202444102](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207202444102.png)

可以用`花括号`包围的值列表对`array`进行**初始化**，但**不允许进行赋值**

`assign`允许从一个**不同的但相容**的类型赋值，或者从**容器的一个子序列**赋值，`assign`操作用参数指定的元素(的拷贝)替换左边容器中的**所有元素**

```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; // 错误：容器类型不同
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

`seq.assign(n, t)`接收一个整型值和元素值，用指定数目(**数目可以多于原来的数目**)具有相同给定值的元素替换容器中原有的元素

```c++
list<string> slists(1); // 1个元素，为空string
slists.assign(10, "Hiya"); // 10个元素，每个都是Hiya
```

`swap`操作交换两个**相同类型**容器的内容，**交换两个容器内容的操作保证会很快，是因为元素本身并未交换，只是交换了两个容器的内部数据结构**

**元素不会移动意味着，除`string`外，指向容器的迭代器、引用、指针在swap操作之后都不会失效，仍然指向swap`操作之前`所指向的元素，但是，在swap之后，这些元素已经属于不同的容器了**；

**swap两个`array`会真正交换它们的元素，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换**

**对`string`调用swap会导致迭代器、引用、指针失效**

>   **Tips**：统一使用非成员版本的`swap(a, b)`

#### 9.2.5、容器大小操作

![image-20211207205336900](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207205336900.png)

#### 9.2.6、关系运算符

**`每个容器类型`都支持相等运算符**，关系运算符**左右两边的运算对象必须是`相同类型的容器`，且必须保存`相同类型的元素`**

![image-20211207205938015](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207205938015.png)

容器的相等运算符实际上是使用元素的==运算符实现比较的，而**其他关系运算符是使用元素的`<`运算符**；**如果元素类型不支持所需运算符，那么`保存这种元素的容器`就不能使用相应的关系运算**

### 9.3、顺序容器操作

#### 9.3.1、向顺序容器添加元素

![image-20211207210828380](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207210828380.png)

##### 9.3.1.1、使用push_back, push_front

除了`array, forward_list`外，每个顺序容器(包括string)都支持`push_back`

`list、forward_list、deque`支持`push_front`，其他容器不支持

>   **说明**：`push_front、push_back`插入的是**元素**，对于`string`插入的是`char`类型

##### 9.3.1.2、在容器中的特定位置添加容器

![image-20211207213236993](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207213236993.png)

**如果传递给insert一对迭代器，它们不能指向添加元素的目标容器**

`insert`成员函数的返回值都是指向所插入的**第一个元素的迭代器**

当用一个对象来初始化容器，或将一个对象插入到容器中时，实际上放入到容器中的是对象的[一个拷贝](#charushifangruyigekaobei)

`emplace、emplace_front、emplace_back`这些操作是`构造`而不是拷贝元素，当调用`push, insert`成员函数时，将元素类型的对象拷贝到容器中，调用一个`emplace`成员函数时，则是将参数传递给**元素类型的构造函数**，`emplace`使用这些参数在容器管理的内存空间中直接构造元素

`emplace`函数的**参数必须与元素类型的构造函数相匹配**

#### 9.3.2、访问元素

![image-20211207220118583](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207220118583.png)

包括`array`在内的每个**顺序容器**都有一个`front`成员函数，除`forward_list`外的所有顺序容器都有一个`back`成员函数，这两个操作分别**返回首元素和尾元素的引用**

```c++
auto val1 = c.front();
auto val2 = *c.begin(); // val1和val2都是第一个元素的拷贝
auto val3 = c.back();
auto val4 = *(--c.end()); // val3和val4都是最后一个元素的拷贝，但不适用于forward_list容器
```

>   **注**：如果容器为空，调用成员函数`front、back`将发生段错误，类似于使用越界的下标

#### 9.3.3、删除元素

![image-20211207220419875](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207220419875.png)

删除`deque`中除首尾元素之外的任何元素都会使所有迭代器、引用、指针失效；指向`vector或string`中删除点`之后`位置的迭代器、引用、指针都会失效

#### 9.3.4、特殊的forward_list操作

在一个单向链表中，没有简单的方法来获取一个元素的前驱，所以在一个`forward_list`中添加或删除元素的操作是**通过改变`给定元素之后`的元素来完成的**

`forward_list`没有提供`insert、emplace、erase`操作，而提供下面的操作：

![image-20211207221647497](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207221647497.png)

`forward_list`容器的所有插入和删除操作的返回值都指向`前驱`位置，对于`***_after`操作中指定的位置都不能是`end()`，否则是未定义的

#### 9.3.5、改变容器的大小

`resize`操作接受一个**可选的**元素值参数，用来初始化添加到容器中的`新元素`，如果未提供此参数，`新元素`进行`值初始化`，如果容器保存的是类类型元素，且resize向容器添加新元素，必须提供初始值或者提供默认构造函数

![image-20211207222513286](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207222513286.png)

#### 9.3.6、容器操作可能使迭代器失效

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207222850871.png" alt="image-20211207222850871" style="zoom:67%;" />

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207223414843.png" alt="image-20211207223414843" style="zoom: 67%;" />

当添加或删除vector或string的元素后，或在deque中首元素之外任何位置添加或删除元素后，原来的`end()`返回的迭代器总会失效，需要在循环程序中反复调用`end()`，而不能在循环之前保存`end()`返回的迭代器

### 9.4、vector对象是如何增长的

标准库实现者采用了可以**减少容器空间重新分配次数**的策略，当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间(2倍扩容法)

![image-20211207230934643](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207230934643.png)

只有当需要的内存空间**超过**当前容量时，reserve调用才会改变vector的容量，reserve**至少**分配与需求一样大的内存空间

如果需求大小**小于或等于**当前容量，reserve什么也不做，容器也不会退回内存空间

resize成员函数**只改变容器中元素的数目**，而不是容器的容量

调用`shrink_to_fit`只是一个请求，标准库并不保存退还内存

**每个vector实现都可以选择自己的内存分配策略，但必须遵守的一条原则是：只有当`迫不得已`时才可以分配新的内存空间**

### 9.5、容器适配器

顺序容器的适配器：`stack、queue、priority_queue`

**一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样**，一个容量适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型

#### 9.5.1、定义一个适配器

每个适配器都定义两个构造函数：

-   默认构造函数创建一个空对象
-   接受一个`容器`的构造函数拷贝该容器来初始化适配器

```c++
deque<int> deq;
stack<int> stk(deq); // 从deq拷贝元素到stk
```

**默认情况下，`stack, queue`都是基于`deque`实现的，`priority_queue`是基于`vector`实现的**

在创建一个适配器时可以将一个命名的**顺序容器**作为第二个类型参数

```c++
stack<string, vector<string>> str_stk2;
```

**对于一个给定的适配器，可以使用哪些容器是有限制的，所有的适配器都要求`容器有添加、删除元素和访问尾元素`的能力**，不能用`array`和`forward_list`来构造适配器

#### 9.5.2、栈适配器

`stack`只要求`push_back, pop_back, back`操作，可以使用`vector, deque, list`来构造stack

**栈的操作**：

![image-20211208004702497](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208004702497.png)

#### 9.5.3、队列适配器

`queue`只要求`push_front, pop_back, back, front`操作，可以使用`deque, list`来构造queue

**队列的操作**：

![image-20211208004752551](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208004752551.png)

`priority_queue`只要求`front, push_back, pop_back, 随机访问能力`操作，可以使用`vector, deque`来构造priority_queue

## 10、泛型算法

### 10.1、概述

大多数算法都定义在头文件`algorithm`和`numeric`中

一般情况下，算法并**不直接操作容器**，而是遍历**由两个迭代器指定的一个元素范围**来进行操作

**迭代器令算法不依赖于容器，但算法依赖于元素类型的操作**，例如`find`算法用元素类型的`==`运算符完成每个元素与给定值的比较

**算法永远不会执行容器的操作，不会改变底层容器的大小，不会`直接`添加、删除元素**

### 10.2、初始泛型算法

#### 10.2.1、只读算法

##### 10.2.1.1、accumulate算法

`accumulate`算法定义在头文件`numeric`中，用来求一组数据的和；

```c++
/*
 * accumulate接受三个参数：
 * 		前两个参数指出需求和的元素的范围
 *		第三个参数是和的初值
 * 返回值的类型由第三个参数的类型决定
 * 第三个参数也决定使用哪个加法运算符
 */
int sum = accumulate(vec.begin(),vec.end(), 0); 
```

`accumulate`将第三个参数作为**求和起点**，**序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型**

```c++
string sum = accumulate(v.cbegin(), c.cend(), ""); // 错误：""是const char *类型，字符串字面值没有+运算符
string sum = accumulate(v.cbegin(), c.cend(), string("")); // 正确 
```

##### 10.2.1.2、equal算法

`equal`算法用于确定两个序列是否保存相同的值，只有**所有元素相等**，才返回`true`，否则返回`false`

```c++
/*
 * equal接受三个参数：
 *		前两个表示第一个序列的范围
 * 		第三个表示第二个序列的首元素
 */
equal(r.cbegin(), r.cend(), s.cbegin()); // 返回值为bool类型
```

`equal`是通过迭代器完成操作，可以通过调用`equal`来比较**两个不同类型**的容器中的元素，而且元素也不必一样，只要能通过`==`来比较两个元素类型即可

`equal`假定第二个序列**至少与第一个序列一样长**，以第一个序列为基准，比较完第一个序列的所有元素就停止比较操作

```c++
string s1 = "asdfgh";
string s2 = "asdfghjkl";
int a1 = equal(s1.cbegin(), s1.cend(), s2.cbegin()); // 结果为true，s1所有元素与s2对应位置的元素都相等
int a2 = equal(s2.cbegin(), s2.cend(), s1.cbegin()); // 结果为false，s2后面的元素在s1中没有对应的元素
```

>   **说明**：只接受一个**单一迭代器**来表示**第二个序列**的算法，都假定第二个序列**至少**与第一个序列一样长

#### 10.2.2、写容器元素的算法

一些算法将新值赋予序列中的元素，必须**保证序列原大小`至少不小于`要求算法写入的元素数目**

一些算法会自动向输入范围写入元素，这些算法本质上并不危险，最多写入与给定序列一样多的元素

##### 10.2.2.1、back_inserter

插入迭代器是一种向容器添加元素的迭代器，通常情况，通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素，而**通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被`添加`到容器中**

`back_inserter`是一个函数，定义在头文件`iterator`中，**接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器**，当通过此迭代器赋值时，赋值运算符会调用`push_back`将一个具有给定值的元素添加到容器中

```c++
vector<int> res;
auto it = back_iterator(res);
*it = 42; // res中添加一个元素42
```

常常使用`back_iterator`来创建一个迭代器，作为算法的目的位置来使用

```c++
vector<int> vec;
fill_n(back_iterator(vec), 10, 0);
```

##### 10.2.2.2、拷贝算法

拷贝算法是一个向目的位置迭代器指向的输出序列中的元素写入数据的算法

```c++
/*
 * copy算法接受三个参数：
 *		前两个参数表示一个输入范围
 *		第三个参数表示目的序列的起始位置，目的序列
 * 返回的是目的位置迭代器(递增后)的值
 */
int a1[] = {0, 1, 2, 3, 4, 5};
int a2[sizeof(a1) / sizeof(int)];
auto ret = copy(begin(a1), end(a1), a2); // 把a1的内容拷贝给a2
```

多个算法都提供所谓的`拷贝(_copy)`版本，这些算法计算新元素的值，但**不会将它们放置在输入序列的末尾，而是创建一个`新序列`保存这些结果**

##### 10.2.3、重排容器元素的算法

##### 10.2.3.1、sort算法

`sort`算法接受两个迭代器，表示要排序的元素范围

##### 10.2.3.2、unique算法

`unique`算法重排输入序列，将**相邻的重复项消除**，`unique`算法不会改变容器的大小，并返回一个**指向不重复值范围末尾**的迭代器，此位置之后的元素仍然存在，但这些值是未定义的

### 10.3、定制操作

#### 10.3.1、向算法传递函数

`谓词`是一个`可调用`的**表达式**，其返回结果是一个能用作条件的值；标准库算法所使用的谓词分为两类：一元谓词(只接受单一参数)、二元谓词(接受两个参数)；**接受谓词参数的算法，对输入序列中的元素调用谓词**，元素类型必须能转换为谓词的参数类型

根据**算法接受一元谓词还是二元谓词**，**传递给算法的谓词必须严格接受一个或两个参数**

#### 10.3.2、lambda表达式

对于一个对象或表达式，如果可以**对其使用调用运算符**，则称它是可调用的；**可以向一个算法传递`任何类型`的可调用对象**

可调用对象可以是**函数、函数指针、重载函数调用运算符的类、lambda表达式**

一个`lambda`表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数，与任何函数类似，一个`lambda`具有一个返回类型、一个参数列表、一个函数体，但与函数不同，**lambda可能定义在函数内部**

```c++
[capture list](parameter list) -> return type { function body }
```

`capture list`是一个lambda**所在函数中定义的`局部变量`的列表**，lambda必须**使用尾置返回来指定返回类型**，可以忽略参数列表和返回类型，但**必须永远包含捕获列表和函数体**，如果忽略括号和参数列表等价于**指定一个空参数列表**，如果忽略了返回类型，lambda根据函数体中的代码推断出返回类型

lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符

```c++
auto f = [] { return 42; }
cout << f() << endl;
```

##### 10.3.2.1、向lambda传递参数

与普通函数不同，**lambda不能有默认参数**，因此lambda调用的实参数目必须与形参数目相等

##### 10.3.2.2、使用捕获列表

虽然一个lambda可以出现在一个函数中，使用其局部变量，但只能使用**那些明确指明的变量**；一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量，但**可以直接使用定义在当前函数之外的名字或者当前函数中的局部static变量**

当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型，**当向一个函数传递一个lambda时，同时定义了一个新类型和该类的一个对象**，传递的参数就是此编译器生成的类类型的未命名对象

使用`auto`定义一个用lambda初始化的变量时，**就是定义了一个从lambda生成的类型的对象**

默认情况下，从lambda生成的类都包含一个**对应该lambda所捕获的变量的数据成员**，lambda的数据成员也在lambda对象创建时被初始化

lambda的变量捕获可以是值或引用：

-   值捕获：采用值捕获的前提是变量可以**拷贝**，与参数不同，**被捕获的变量的值是在lambda`创建`时拷贝，而不是调用时拷贝**，因此随后对变量的修改不会影响到lambda内对应的值
-   引用捕获：必须确保被引用的对象**在lambda执行的时候是存在的**，对于不可以拷贝的`ostream`，引用是必须的；如果**函数返回一个lambda**，则函数不能返回一个局部变量的引用类似，此lambda也**不能包含引用捕获**
-   隐式捕获：应在捕获列表中写一个`&`或`=`来指示编译器推断捕获列表

可以混合使用显式捕获和隐式捕获，捕获列表的**第一个元素**必须是一个`&`或`=`，并且显式捕获的变量必须使用与隐式捕获不同的方式：

-   如果隐式是引用方式，显式必须采用值方式
-   如果隐式是值方式，显式必须采用引用方式

##### 10.3.2.3、可变lambda

默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果希望能改变一个被捕获的变量的值，就必须在**参数列表首**加上关键字`mutable`

一个引用捕获的变量是否可以修改依赖于此引用指向的是一个const类型还是非const类型

>   **说明**：值捕获只是得到捕获变量值的拷贝，是不能通过捕获变量名修改变量值，除非是`mutable`修饰的；但引用捕获得到捕获变量本身，是否可以改变取决于捕获对象本身是否是`const`的

##### 10.3.2.3、lambda是函数对象

当编写一个`lambda`后，编译器将该表达式翻译成一个**未命名类的未命名对象**，在lambda表达式产生的类中**含有一个重载的函数调用运算符**

默认情况下，lambda不能改变它捕获的变量，因此在默认情况下，由lambda产生的类当中的**函数调用运算符是一个const成员函数**，如果lambda被声明为可变的，则调用运算符就不是const的了

当一个lambda表达式通过**引用捕获变量**时，编译器可以直接使用该引用而**无须在lambda产生的类中将其存储为数据成员**；相反，通过**值捕获的变量**被拷贝到lambda中，这种lambda产生的类**必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数(定义相关参数的构造函数)，令其使用捕获的变量的值来初始化数据成员**

```c++
auto wc = [sz](const string &s) { return a.size() >= sz; }

// lambda表达式对应的类
class SizeComp {
public:
    // >>>>>> 没有默认构造函数 <<<<<<<
    SizeComp(size_t n) : sz(n) {} // 定义相关参数的构造函数
    bool operator()(const string &s) const {
        return s.size() >= sz;
    }
private:
    size_t sz; // 值捕获产生对应的数据成员
};
```

:star: :star:**lambda表达式产生的类`不含默认构造函数、赋值运算符及默认析构函数`(百分百没有)，是否含有默认的拷贝、移动构造函数通常要视捕获的数据成员类型而定**:star: :star:

>   **说明**：由于lambda表达式没有默认构造函数，在容器中使用自定义的比较函数时，定义相关变量的时候需要指定`初始化器`来调用拷贝构造函数
>
>   ```c++
>   // cmp是lambda表达式
>   // decltype(cmp)获得lambda表达式的类型
>   // a(cmp)使用初始化器调用拷贝构造函数
>   set<string, decltype(cmp)> a(cmp); 
>   ```

#### 10.3.3、参数绑定

如果lambda的捕获列表为空，通常可以用函数来代替它；对于捕获局部变量的lambda，用函数替换就没有那么容易了

`bind`函数定义在头文件`functional`中，可以将`bind`看作一个通用的**函数适配器**，它可以接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表

```c++
/*
 * callable：是一个可调用对象
 * arg_list：参数列表，对应给定的callable的参数
 * 当调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数
 */
auto newCallable = bind(callable, arg_list);
```

`arg_list`中的参数可能包含如`_n`的名字，其中`n`是一个整数，这些参数是`占位符`，表示`newCallable`的参数，它们占据了传递给`newCallable`的参数的**位置**，数值`n`表示生成的可调用对象中参数的位置

```c++
/*
 * check6是一个可调用对象，接受一个string类型的参数
 * 并用此string和6来调用check_size
 */
auto check6 = bind(check_size, _1, 6); // _1是指传递给check6参数的第一个参数
```

`_n`定义在`std::placeholders`的命名空间中，使用`_n`时，需要指明命名空间

##### 10.3.3.1、bind的参数

可以用`bind`修正参数的值，更一般的，可以**用`bind`绑定给定可调用对象中的参数或重新安排其顺序**

```c++
// g是一个由两个参数的可调用对象
auto g = bind(f, a, b, _2, c, _1); // 生成一个新的可调用对象g
```

```c++
// 按单词长度由短至长排序
sort(w.begin(), w.end(), isShorter);
// 按单词长度由长至短排序
sort(w.begin(), w.end(), bind(isShorter, _2, _1)); // 重排参数顺序
```

默认情况下，`bind`的那些不是占位符的参数被`拷贝`到`bind`返回的可调用对象中；如果传递给`bind`一个对象而不是拷贝它，必须使用标准库`ref`函数，函数`ref`返回一个对象，**包含给定的引用，此对象是可以拷贝的**

```c++
ostream& print(ostream& os, const string &s, char c) {
    return os << s << c;
}
// 错误：bind拷贝其参数，不能拷贝一个ostream
auto i = bind(print, os, _1, '');
// 正确：
auto ii = bind(print, ref(os), -1, '');
```

### 10.4、泛型算法结构

任何算法的最基本的特性是它**要求其迭代器提供哪些操作**，C++标准指明了泛型和数值算法的每个迭代器参数的**最小类别**，**每个迭代器参数的能力必须与规定的最小类别`至少`相当**

**迭代器类别**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208183729889.png" alt="image-20211208183729889" style="zoom:67%;" />

**迭代器支持的操作**：

-   ![image-20211208185225933](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185225933.png)
-   ![image-20211208185103301](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185103301.png)
-   <img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185413679.png" alt="image-20211208185413679" style="zoom:67%;" />
-   <img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185507489.png" alt="image-20211208185507489" style="zoom:67%;" />
-   <img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185704848.png" alt="image-20211208185704848" style="zoom:67%;" />

### 10.5、算法形参模式

**大多数算法的形参形式**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208190014898.png" alt="image-20211208190014898"  />

如果`dest`是一个直接指向容器的迭代器，算法将输出数据写到容器中已存在的元素内；一般`dest`被绑定到一个`插入迭代器`或是一个`ostream_iterator`，可以保证空间足够用

### 10.6、特定容器算法

对于`list`和`forward_list`，应该**优先使用成员函数版本的算法**而不是通用算法

**链表特有的成员函数**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208190927778.png" alt="image-20211208190927778" style="zoom:67%;" />

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208191250488.png" alt="image-20211208191250488" style="zoom:67%;" />

## 11、关联容器

关联容器**支持高效的关键字查找和访问**，两个主要的关联容器类型是`map`和`set`

-   map中的元素是一些`关键字-值对`：关键字起**索引**的作用，值则表示与索引相关联的数据
-   set中每个元素只包含一个关键字，支持高效的关键字查询操作，检查一个给定的关键字是否在set中

有序容器是使用`红黑树`来组织元素，无序容器使用`哈希函数`来组织元素，`map, muiltimap`定义在头文件`<map>`中，`set, nultiset`定义在头文件`<set>`中，无序容器定义在头文件`<unordered_map>, <unordered_set>`中

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208200648344.png" alt="image-20211208200648344" style="zoom:67%;" />

### 11.1、关联容器概述

#### 11.1.1、定义关联容器

当定义一个`map`时，必须指明**关键字类型和值类型**；当定义一个`set`时，必须指明**关键字类型**；对于`set`，元素类型就是关键字的类型，对于`map`来说，元素类型包括关键字类型和值类型，将**关键字-值对**包围在花括号中`{key, value}`来构成一个元素

-   每个关联容器都定义了默认构造函数，它创建一个指定类型的**空容器**；
-   可以将关联容器初始化为另一个**同类型容器的拷贝**
-   从一个**值范围**来初始化关联容器，只要这些值可以转化为容器所需类型即可
-   通过**{}列表**进行值初始化

一个`map, set`中的关键字必须是唯一的，容器`multimap, multiset`中的关键字可以不唯一

#### 11.1.2、关键字类型的要求

##### 11.1.2.1、有序容器的关键字类型

对于**有序容器**(`map, set, multimap, multiset`)，**关键字类型必须定义元素比较的方法**，默认情况下标准库使用关键字类型的`<`运算符来比较两个关键字；在集合类型中，关键字类型就是元素类型，在映射类型中，关键字类型是元素第一部分的类型

**有序容器的关键字类型需满足**：

-   两个关键字不能同时**小于等于**对方，如果`k1 <= k2`，那么`k2`绝不能`<= k1`
-   如果`k1 <= k2`，且`k2 <= k3`，那么`k1 <= k3`
-   如果存在两个关键字，任何一个都不**小于等于**另一个，那么这两个关键字是**等价**的

**总之，关键字的类型必须能明确将两个元素分出大小来，是严格弱序的**

##### 11.1.2.2、使用关键字类型的比较函数

用来组织一个容器中元素的操作的类型也是该容器类型的一部分，必须在定义关联容器类型时提供此操作的类型

在`<>`中出现的每个类型，就仅仅是一个**类型(`是类型而不是对象`)**而已，**只有在创建容器时，才会以构造函数参数的形式提供真正的比较操作，也就是说如果这个比较函数的类型没有默认构造函数，在定义关联容器对象时需要比较函数的类型的对象来初始化**

```c++
bool compareIsbn(const Sales_date &lhs, const Sales_date &rhs) {
    return lhs.isbn() < rhs.isbn();
}
multiset<Sales_date, decltype(compareIsbn)*> bookstore(compareIsbn); // 用compareIsbn来初始化
```

#### 11.1.3、pair类型

`pair`定义在头文件`<utility>`中，一个`pair`保存两个数据成员，`pair`是一个用来生成特定类型的模板；当创建一个`pair`时，必须**提供两个类型名**，`pair`的数据成员将具有对应的类型

`pair`的**默认构造函数**对数据成员进行`值初始化`，也可以为每个成员提供初始化器

```c++
pair<string, int> anom; // anom对应的初始值为{"", 0}
pair<string, int> line{"Jame", 23}; 
```

`pair`的数据成员时`public`的，两个成员分别命名为`first`和`second`，可以使用普通的成员访问符号访问它们

```c++
anom.first = "ahfe";
anom.second = 34;
```

**`pair`上的操作**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208231645502.png" alt="image-20211208231645502" style="zoom:67%;" />

### 11.2、关联容器操作

#### 11.2.1、关联容器额外的类型别名

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208231852628.png" alt="image-20211208231852628" style="zoom:67%;" />

对于`set`，`key_type, value_type`是一样的，`set`中保存的值就是关键字；对于`map`，元素是**关键字-值对**，每个元素是一个`pair`对象，**由于不能改变一个元素的`关键字`，因此这些`pair`的关键字部分是`const`的**

需要使用**作用域运算符**来提取一个类型的成员

```c++
map<string, string>::key_type
```

#### 11.2.2、关联容器迭代器

当**解引用一个关联容器迭代器**时，得到一个类型为容器的`value_type`(元素类型)的值的引用

`set`的迭代器是`const`的，和`map`一样不能改变元素关键字的值，可以用一个`set`迭代器来读取元素的值，但不能修改

可以通过`begin(), end()`遍历关联容器

**通常不对关联容器使用泛型算法**，关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法

关联容器可以用于只读取元素的算法，关联容器定义了自己的`find`成员，它通过给定的关键字直接获取元素，比`泛型find`快得多

在实际编程中，如果我们真要对一个关联容器使用算法，**要么是将它作为一个源序列，要么作为一个目的位置**；可以用`泛型copy`算法将元素从一个关联容器拷贝到另一个序列，可以调用`inserter`将一个插入器绑定到一个关联容器，通过使用`inserter`可以将关联容器当作一个目的位置来调用另一个算法

#### 11.2.3、添加元素

**关联容器的`insert`操作**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208235127990.png" alt="image-20211208235127990" style="zoom:67%;" />

对一个`map`进行插入操作时，必须记住元素类型是`pair`，对于想要插入的数据，并没有一个现成的`pair`对象，可以在参数列表中创建一个`pair`对象

```c++
c.insert({word, 1});
c.insert(make_pair(word, 1));
c.insert(pair<string, int>(word, 1));
c.insert(map<string, int>::value_type(word, 1));
```

#### 11.2.4、删除元素

**关联容器的删除操作**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209002119895.png" alt="image-20211209002119895" style="zoom:67%;" />

关联容器提供一个额外的`erase`操作，接受一个`value_type`参数，删除所有匹配给定关键字的元素，**返回实际删除的元素数量**，对于保存不重复关键字的容器，`erase`的返回值总是`0`或`1`

#### 11.2.5、map的下标操作

`map, unordered`容器提供了下标运算符和一个对应的`at`函数，不能对一个`multimap, unordered_multimap`进行下标操作，因为这些容器中可能存在多个值与一个关键字相关联

**如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化**，由于下标运算符可能插入一个新元素，只可以对`非const`的map使用下标操作

![image-20211209003238708](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209003238708.png)

通常情况下，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的；**当对`map`进行下标操作时，会获得一个`mapped_type`，当解引用一个`map`迭代器时，会得到一个`value_type`对象**；与其他下标运算符相同，`map`的下标运算符返回一个左值

#### 11.2.6、访问元素

对于不重复关键字的容器，可以使用`find, count`，对于重复关键字的容器，`count`还会统计有多少个元素有相同的关键字

**关联容器的查找操作**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209100306057.png" alt="image-20211209100306057" style="zoom:67%;" />

**对`map`使用`find`代替下标操作**

```c++
if (c.find(k) != c.end()) {
    //
}
```

如果一个`multimap, multiset`中有多个元素具有给定关键字，则这些元素**在容器中会`相邻`存储**(因为是有序的)；如果在`multimap, multiset`中查找关键字所有的元素，可以通过`find, count`结合使用

```c++
auto cnt = c.count(k);
auto iter = c,find(k);
while (cnt--) {
    /* 相关操作 */
    iter++;
}
```

或者通过`lower_bound, upper_bound`，如果关键字在容器中，`lower_bound`返回迭代器将指向**第一个具有给定元素的位置**，而`upper_bound`返回的迭代器将指向**最后一个匹配给定关键字的元素之后的位置**，如果关键字不在容器中，`lower_bound, upper_bound`返回相等的迭代器

```c++
auto iterBegin = c.lower_bound(k);
auto iterEnd = c.upper_bound(k);
while (iterBegin != iterEnd) {
	/* 相关操作 */
    iterBegin++;
}
```

或者通过`equal_range`，由于无序关联容器中关键字相等的元素都会在同一个桶中，所以无序关联容器也可以使用

```c++
auto pos = c.equal_range(k);
auto iterBegin = pos.first;
auto iterEnd = pos.second;
while (iterBegin != iterEnd) {
    /* 相关操作 */
    iterBegin++;
}
```

### 11.4、无序容器

4个无序关联容器**不是使用比较运算符来组织元素，而是使用一个`哈希函数`和关键字类型的`==`运算符**

无序容器可以使用`哈希管理操作`，无序关联容器也可以使用有序关联容器的`find, insert`等操作

无序容器在存储上组织为一组桶，每个桶保存零个或多个元素，**无序容器使用一个哈希函数将元素映射到桶**；为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶，容器将具有一个特定哈希值的所有元素都保存在相同的桶中；**如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中**，因此无序容器的性能依赖于哈希函数的质量和桶的数量和大小

**无序容器管理操作**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209103347407.png" alt="image-20211209103347407" style="zoom:67%;" />

默认情况下，无序容器使用关键字类型的`==`运算符来比较元素，还是用一个`hash<key_type>`类型的对象来生成每个元素的哈希值；标准库为**内置类型、string、指针类型、智能指针类型**提供了`hash`模板，可以直接定义**关键字是内置类型(包括指针类型)、string、智能指针类型的无序容器**

但是**不能直接定义关键字类型为自定义类类型的无序容器**，自定义类类型必须提供自己的`hash`模板版本，也可以提供函数来替代`==`运算符和哈希值计算函数

```c++
unordered_multiset<sales_data, decltype(haster)*, decltype(eqop)*>
```

## 12、动态内存

###  12.1、动态内存

##### 12.1.1、使用new动态分配的和初始化对象

`new`无法为其分配的对象命名，只能返回一个**指向该对象的指针**

**动态分配对象的初始化方式**：

-   **默认情况下，动态分配的对象是默认初始化的**，意味着内置类型或组合类型的对象的值是未定义的，而类类型对象将用默认构造函数进行初始化
-   使用**直接初始化方式**
    -   使用传统的构造方式(`圆括号`)，**调用类型的构造函数来初始化**
    -   使用列表初始化(`花括号`)
-   使用**值初始化**：在类型名后跟一对`空括号`
    -   值初始化只对`内置类型`有意义，对于内置类型，默认初始化的对象的值是未定义的，而使用值初始化的对象的值是有定义的
    -   对于自定义类型，不管使用值初始化还是默认初始化，最终都会调用类的默认构造函数来完成初始化

```c++
// 默认初始化
string *ps = new string; // ps指向的对象是未定义的
int *pi = new int;

// 直接初始化
int *pi = new int(1024);
int *qi = new int{34};
string *str = new string(10, '9'); // 使用string的构造函数初始化对象
vector<int> *vec = new vector<int>{0, 1, 2, 3, 4, 5};

// 值初始化
int *pi = new int(); // 适用于内置类型
```

<span id="autofenpeishuzu">如果使用`()`包围的初始化器，可以是使用`auto`从初始化器来推断想要分配的对象的类型，但括号中仅有`单一`**初始化器**才可以</span>

```c++
auto p1 = new auto(obj); // auto的推断结果和obj的类型一致
```

`new`可以分配**const对象**，但必须进行**初始化**，对于定义了**默认构造函数的**`类类型`，可以隐式初始化，而**其他类型的对象**(内置类型)只能显式初始化，new返回的指针是一个`指向const的指针`

##### 12.1.2、定位new运算符

一般来说，使用new申请空间时，是从系统的堆中分配空间。申请所得的空间的**位置**是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在程序员**指定的特定内存**创建对象，这就是所谓的`定位new`操作 

定位new运算符**直接使用传递给它的地址**，它不负责判断哪些内存单元已被使用，也不查找未使用的内存块

```c++
// place_address必须是一个指针
new (place_address) type 
new (place_address) type(initializers)
new (place_address) type[size]
new (place_address) type[size]{initializer list}

// example 1
int mem[100];
for (int i = 0; i < 100; i++) {
    new (mem + i) int(i); // 给mem数组每一个元素赋值
}
// example 2
char mem[100];
int *pi = new (mem) int;
```

##### 12.1.3、new和数组

`new`分配一个对象数组，要**在类型名之后跟一对方括号，指明要分配的对象的数目**，方括号中的大小必须是`整形`，**但不必是常量，可以用任意表达式来指定大小**；new分配要求数量的对象并返回指向`第一个`对象的指针，不能对动态数组调用`begin`或`end`，也不能使用`范围for`

```c++
int *pia = new int[get_size()];
// 用表示数组类型的类型别名来分配一个数组 
typedef int arrT[42];
int *p = new arrT;
```

**动态分配对象的数组初始化方式**：

-   默认情况下，new分配的对象，不管是单个分配的还是数组中，都是默认初始化的
-   对数组中的元素进行值初始化：在大小之后跟一对**空括号**，但**不能在括号中给出初始化器**，不能使用[auto分配数组](#autofenpeishuzu)
-   使用初始化列表

```c++
int *pia = new int[10]; // 10个未初始化的int
int *pia2 = new int[10](); // 10个值初始化为0的int
int *pia3 = new int[10]{0, 1, 2, 3, 4};
```

>   **说明**：动态数组的大小允许为0，但没有实际意义，能够定义长度为0的数组，但不能解引用

##### 12.1.4、释放动态内存

传递给delete的指针必须**指向动态分配的内存，或者是一个`空指针`**，释放一块非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的

动态分配的const对象的值不能被改变，但它本身是可以被销毁的，只要delete指向const对象的指针即可

```c++
const int *pci = new const int(1024);
delete pci;
```

**由`内置指针`(而不是智能指针)管理的动态内存在被显式释放前一直都会存在**

>**Tips**：避免空悬指针的方法：在指针即将要离开其作用域之前释放掉它所关联的内存，这样就没有机会继续使用指针了。如果需要保留指针，可以在delete之后，将nullptr赋值给指针

释放动态数组需要在指针前加上一对`空方括号`，数组中的元素被**逆序销毁**

```c++
delete [] pi;
// 销毁使用类型别名定义的动态数组
typedef int arrT[42];
int *p = new arrT;
delete [] p; // 即使用的是类型别名定义的动态数组，销毁时也需要[]
```

#### 12.2、智能指针

##### 12.2.1、shared_ptr类

`shared_ptr`类也是一个模板类，类似于`vector`，**模板参数为指针可以指向的类型**

**智能指针shared_ptr的初始化方式**：

-   默认初始化的智能指针中保存着一个空指针
-   使用标准库**函数**`make_shared`，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的`shared_ptr`
-   使用new返回的指针初始化智能指针：接收指针参数的智能指针构造函数是`explicit`的，不能将内置指针隐式转换为一个智能指针，必须**使用直接初始化形式**

```c++
shared_ptr<string> p1 = make_shared<string>(10, '9'); // 调用make_shared<string>时传递的参数必须与string的构造函数相匹配
shared_ptr<string> p2 = make_shared<string>(); // 值初始化
auto p3 = make_shared<string>(); // 使用auto

// new指针初始化智能指针
shared_ptr<int> p4(new int(1024)); // 正确：使用直接初始化
shared_ptr<int> p4 = new int(1024); // 错误：不能隐式转换
```

**shared_ptr的相关操作**：![image-20211129220029072](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211129220029072.png)

**智能指针的使用方式和普通指针一样**，解引用以及使用智能指针作为判断条件等

**拷贝一个shared_ptr，计数器都会递增，给shared_ptr`赋予一个新值`或是shared_ptr被销毁，计数器都会递减，当计数器为0时，自动释放所管理的对象**

**将一个shared_ptr赋予另一个shared_ptr会`递增`赋值号`右侧`的shared_ptr的引用计数，而`递减`赋值号`左侧`shared_ptr的引用计数**

shared_ptr的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存

>**说明**：引用计数的递减操作都是在析构函数中进行的，并在析构函数中判断当引用计数为0时，就释放相应的内存

:question:如果将shared_ptr存放在容器中，随后重排容器，而后不再需要全部元素，而只使用其中一部分，需要用erase删除不再需要的那些元素:question:

使用动态内存的场景：

-   程序不知道自己需要使用多少对象：容器类
-   程序不知道所需对象的准确类型
-   程序需要在多个对象间共享数据

默认情况下，一个**用来初始化智能指针的普通指针必须指向动态内存**，因为智能指针默认使用delete释放它所关联的对象，**可以将智能指针绑定到一个指向其他类型的资源的指针上，必须提供自己的操作来提到delete**

```c++
void end_connection(connection *p); // 自定义释放操作
shared_ptr<connection> p(&c, end_connection); // 用自定义释放操作end_connection代替默认的delete
```

当将一个shared_ptr绑定到一个**普通指针**时，就将内存的管理责任交给了这个shared_ptr，不应该在使用**内置指针**来访问shared_ptr所指向的内存

智能指针类型的`get()`函数返回一个`内置指针`，指向智能指针管理的对象，使用get返回的指针的代码不能delete这个指针，**不要用get初始化另一个智能指针或者为另一个智能指针赋值**

**如果使用智能指针，即使程序块过早结束(异常)，智能指针类也能确保在内存不再需要时将其释放**；使用**内置指针**管理内存，在new之后在对象delete之前发生了异常，则内存不会被释放

shared_ptr不直接支持管理动态数组，需要**提供自己定义的删除器**，shared_ptr未定义下标运算符，必须**使用get获取一个内置指针，通过内置指针访问元素**

```c++
shared_ptr<int> sp(new int[10], [](int *p){ delete[] p; });
*(sp.get() + 3) = 45;
sp.get()[3] = 45;
```

##### 12.2.2、unique_ptr类

与多个shared_ptr指针可以指向同一个对象不同，只能有一个unique_ptr指针指向一个对象，**当unique_ptr被销毁时，所指向的对象也被销毁**

定义一个unique_ptr时，需要将其绑定到一个**new返回的动态指针**上，由于一个unique_ptr拥有它指向的对象，unique_ptr**不支持普通的拷贝或赋值操作**，可以通过`release`或`reset`将指针的所有权从一个(非const)unique_str转移给另一个unique，release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值，**如果不用智能指针来保存release返回的指针，需要手动释放资源**

```c++
// release成员返回unique_ptr当前保存的指针并将其置为空
unique_ptr<string> p2(p1.release()); // release将p1置为空 
// reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针，如果unique_ptr不为空，它原来指向的对象被释放
p2.reset(); // 释放p2指向的对象
p2.reset(p3.release()); // 释放p2指向的对象，将所有权从p3转移给p2
```

**可以拷贝或赋值一个`将要被销毁`的unique_ptr**，比如局部对象的拷贝，函数返回值等

unique_ptr管理删除器的方式与shared_ptr不同，需要在**尖括号中unique_ptr指向类型之后提供删除器类型**，在创建或reset这种unique_ptr类型的对象时，**必须**提供一个指定类型的可调用对象(删除器)

```c++
unique_ptr<objT, delT> p(new objT, fcn); // <objT, delT>中提供删除器类型，p(new objT, fcn)必须提供可调用的删除器
```

可以使用`unique_ptr`智能指针管理new分配的数组，必须在尖括号中对象类型后面跟一对`[]`，当unique_ptr指向一个数组时，不能使用点或箭头成员运算符，只能使用`下标运算符`来访问数组中的元素，因为unique_ptr指向的是一个数组而不是单个对象

```c++
unique_ptr<int[]> up(new int[10]);
up[2] = 34; // 只能使用下标运算符
```

**unique_ptr的相关操作**：

![image-20211129220213030](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211129220213030.png)

![image-20211129220128817](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211129220128817.png)

##### 12.2.3、weak_ptr

weak_ptr是一种不控制所指向对象生存期的智能指针，指向一个由`shared_ptr`管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的`引用计数`。

**创建weak_ptr时，必须用shared_ptr来初始化**

```c++
shared_ptr<int> p = make_shared<int>(43);
weak_ptr<int> wp(p); // weak_ptr必须用shared_ptr对象来初始化
```

由于对象有可能不存在，不能直接使用weak_ptr直接访问对象，必须调用`lock`来检查weak_ptr指向的对象是否存在；如果存在，`lock`函数返回一个指向对象的`shared_ptr`

```c++
if (shared_ptr<int> np = wp.lock()) { // lock返回shared_ptr智能指针
    
}
```

**weak_ptr的相关操作**：

![image-20211129220257506](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211129220257506.png)

## 13、重载运算与类型转换

重载运算符函数的**参数数量**与该运算符作用的**运算对象数量**一样多，一元运算符有一个参数，二元运算符有两个参数；对于二元运算符来说，**左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数**；如果一个运算符函数是**成员函数**，则它的第一个运算对象绑定到隐式的`this`指针上

对于一个运算符函数来说，它**或者是类的成员，或者至少含有一个类类型的参数**，意味着当运算符作用域内置类型的运算对象时，无法改变该运算符的含义

**只能重载已有的运算符**，而无权发明新的运算符号；对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致

**可被重载的运算符**：

![image-20211209194201559](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209194201559.png)

也可以像调用其他成员函数一样**显式地调用成员运算符函数**

```c++
date1.operator+(date2);
date1 + date2;
```

如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209195321943.png" alt="image-20211209195321943" style="zoom: 80%;" />

运算符重载函数定义成成员函数还是非成员函数的标准：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209195732605.png" alt="image-20211209195732605" style="zoom:80%;" />

### 13.1、输入和输出运算符

#### 13.1.1、重载输出运算符<<

输出运算符的第一个形参是一个**非常量`ostream`对象的引用**，是因为向流写入内容会改变其状态，其次是**无法复制一个`ostream`对象**；第二形参一般是一个**常量的引用**；`operator<<`一般要返回它的`ostream`对象

**输出运算符尽量减少格式化操作**

**输入输出运算符必须是非const的**

如果**自定义IO运算符，必须将其定义成非成员函数**，IO运算符通常需要读写类的非公有数据成员，**IO运算符一般被声明为**`友元`

#### 13.1.2、重载输入运算符>>

输入运算符的第一个形参是运算符将要读取的**流的引用**，第二个形参是要读入到的**(非常量)对象的引用**，该运算符返回**某个给定流的引用**

**输入运算符必须处理输入可能失败的情况，而输出运算符不需要**

### 13.2、算术和关系运算符

通常情况下，**把算术和关系运算符定义成`非成员函数`以允许对左侧或右侧的运算对象进行转换**，因为这些运算符一般不需要改变运算对象的状态，**形参都是常量的引用**

算术运算符通常会计算它的两个运算对象并得到一个新值，这个新值有别于任意一个运算对象，常常**位于局部变量之内，操作完成后返回该局部变量的副本作为其结果**；如果类定义了算术运算符，则一般也会定义一个对应的复合赋值运算符，此时最有效的方式是使用复合赋值来定义算术运算符

#### 13.2.1、相等运算符

相等运算符和不相等运算符中的一个应该把工作委托给另外一个，意味着`!=`需要通过`==`来实现

```c++
bool operator!=(const A& a, const A& b) {
    return !(a == b); // 用==实现!=
}
```

#### 13.2.2、关系运算符

通常情况下关系运算符应该：

-   定义顺序关系，必须有**明确的顺序关系**
-   如果类同时含有`==`运算符的话，则定义一种关系令其与`==`保持一致，如果两个对象`!=`，则一个对象一定`<`另一个对象

通过定义`<`，从而`>, <=, >=`都是可以通过`<`得出的

### 13.3、赋值运算符

除了前面的**形参是类对象的引用赋值运算符**外，还可以以使用**别的类型**作为右侧运算对象，和前面的赋值运算符一样，其他重载的赋值运算符也**必须先释放当前的内存，再创建一片新空间**，不同的是，该运算符不需要检查对象向自身的赋值

**不管形参的类型是什么，赋值运算符都必须定义为成员函数**

复合赋值运算符也要返回其**左侧运算对象的引用**

### 13.4、下标运算符

**下标运算符必须是成员函数**

下标运算符通常以**所访问元素的引用**作为返回值，最好同时定义下标运算符的常量版本和非常量版本，当作用于一个**常量对象**时，下标运算符返回**常量引用**

```c++
string& operator[](int n) {
    return elements[n];
}
const string& operator[](int n) const { // 常量版本返回常量引用
    return elements[n];
}
```

### 13.5、递增和递减运算符

**前置运算符**应该返回递增或递减后对象的**引用(左值)**，而后置运算符应该返回**对象的原值**，返回形式是**一个值而非引用**

**后置版本接受一个额外的`int`类型的形参(无须命名)**，当使用后置运算符时，编译器为这个形参提供一个值为0的实参，这个形参唯一的作用就是区分前置版本和后置版本的函数

对于后置版本来说，在**递增、减对象之前需要首先记录对象的状态**，好用来作为返回值返回

```c++
StrBlobPtr& operator++() { // 前置++版本：返回递增后对象的引用
    ++curr;
    return *this;
}
StrBlobPtr operator++(int) { // 后置++版本：返回原对象的值
    StrBlobPtr ret = *this;
    ++*this;
    return ret;
}
```

如果显式的调用后置运算符，需要为**它的整型参数传递一个值**

```c++
p.operator++(0); // 调用后置++：可以传任何值
p.operator++(); // 调用前置++
```

>   **说明**：前置++需要判断有效性，后置++一般不需要，因为后置++通过前置++实现

### 13.6、成员访问运算符

**解引用运算符返回的是引用，箭头运算符返回的是指针**

箭头运算符`必须`是类的成员，解引用运算符通常也是类的成员

```c++
string& operator*() {
    return this->cur;
}
string* operator->() {
    return *this->operator*();
}
```

### 13.7、函数调用运算符

如果类重载了函数调用运算符，则可以**像使用函数一样使用该类的**`对象`

**函数调用运算符必须是成员函数**，一个类可以定义多个不同版本的的调用运算符，相互之间应该在参数数量或类型上有所区别

如果类定义了调用运算符，则该类的对象称作**函数对象**

#### 13.7.1、标准库定义的函数对象

标准可定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符，这些类都被定义成模板的形式，使用时**需要指定具体的应用类型**

**标准库函数对象**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209222107978.png" alt="image-20211209222107978" style="zoom:67%;" />

标准库规定其函数对象对于**指针**同样适用，之前介绍过比较两个无关指针将产生未定义的行为，可以适用标准库的函数对象来比较，比较的是实际地址的先后顺序

关联容器适用`less<key_type>`对元素排序，因此可以定义一个**指针**的`set`或者在`map`中适用**指针作为关键值**而无须直接声明`less`

#### 13.7.2、可调用对象与function

C++中有几种可调用的对象：**函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类**

和其他对象一样，可调用的对象也有类型；**调用形式指明了`调用返回的类型`以及传递给调用的`实参类型` ，一种调用形式对应一个函数类型**

##### 13.7.2.1、标准库function类型

**function的操作**：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209224331385.png" alt="image-20211209224331385" style="zoom:67%;" />

`function`是一个模板，创建一个具体的`function`类型时必须提供该`function`类型能够表示的对象的调用形式

```c++
int add(int a, int b) {
    return a + b;
}
function<int(int, int)> f1 = add;
```

##### 13.7.2.2、重载的函数与function

不能直接将重载函数的名字存入`function`类型的对象中，容易产生二义性

```c++
int add(int, int);
Sales_data add(const Sales_data &, const Sales_data &);
map<string, function<int(int, int)>> binops;
binops.insert({"+", add}); // add不知道调用哪一个
```

可以通过**函数指针**而非函数名来消除二义性

```c++
int add(int, int);
Sales_data add(const Sales_data &, const Sales_data &);
int (*fp)(int, int) = add;
map<string, function<int(int, int)>> binops;
binops.insert({"+", fp}); // 调用int(int,int)的add
```

### 13.8、重载、类型转换与运算符

#### 13.8.1、类型转换运算符

**类型转换运算符**是类的一种特殊成员函数，它负责**将一个类类型的值转换成其他类型**；类型转换运算符可以**面向任意类型(void除外)进行定义**，只要该类型**能作为函数的返回类型**，因此不允许转换成数组或函数类型，但允许转换成指针(包括数组指针及函数指针)或引用类型

类型转换运算符**既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数**；类型转换运算符通常不应该改变转换对象的内容，一般被**定义成const成员**

```c++
operator type() const { }
```

因为类型转换运算符是**隐式执行**的，无法给这些函数传递实参，也就**不能在类型转换运算符的定义中使用任何形参**；虽然类型转换函数不负责指定返回类型，但实际上**每个类型转换函数都会返回一个对应类型的值**

#### 13.8.2、显式的类型转换运算符

```c++
int i = 42;
cin << i; // 
```

上述代码中试图将输出运算符作用于输入流，因为`istream`没有定义`<<`，但此代码中使用`istream`的`bool`类型转换运算符将`cin`转换为`bool`，而这个`bool`值会提升为`int`并用作内置的左移运算符的左侧运算对象，也就相当于`1 << 42`

防止异常情况发生，需要定义**显式的类型转换运算符**；和显式的构造函数一样，编译器也不会将一个显式的类型转换运算符用于隐式类型转换；只能通过**显式的强制类型转换**才可调用类型转换运算符

:star::star:如果**表达式被用作条件**，则编译器会**将显式的类型转换自动执行**:star::star:：

<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211210001332969.png" alt="image-20211210001332969" style="zoom:67%;" />

**无论何时在条件中使用流对象，都会使用为IO类型定义的**`operator bool`

#### 13.8.3、避免有二义性的类型转换

如果类中包含一个或多个类型转换，则**必须确保在类类型和目标类型之间只存在唯一一种转换方式**，否则会产生二义性

**产生多重转换路径的两种情况**：

-   两个类定义相同的类型转换：A类定义了一个接受B类转换构造函数，同时B类定义了一个接受A类转换构造函数，它们提供了相同的类型转换

-   类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起

    ```C++
    struct A {
        A(int = 0);
        A(double);
        operator int() const;
        operator double() const;
    };
    void f2(long double);
    A a;
    f2(a); // 二义性错误：不确定调用哪一个类型转换，int，double都能转换为long double
    long lg;
    A a2(lg); // 二义性错误：不确定调用哪一个类型转换，long double能转换为int或者double
    ```

通常情况下，**不要为类定义相同的类型转换，也不要在类中定义两个或两个以上转换源或转换目标是算术类型的转换**

**类型转换与运算符的使用经验**：

-   不要令两个类执行相同的类型转换：如果A类中有一个接受B类对象的构造函数，那么B类就不能定义转换目标为A类的类型转换运算符
-   避免转换目标是内置算术类型的类型转换，特别是已经定义了一个转换成算术类型的类型转换时，接下来
    -   不要再定义接受算术类型的重载运算符
    -   不要定义转换到多种算术类型的类型转换

**总之，除了显示地向`bool`类型的转换之外，应该尽量避免定义类型转换函数并尽可能地限制那些`显然正确`的非显式构造函数**

当通过类类型的对象进行函数调用时，只考虑该类的成员函数，而**当在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是非成员函数**，两者都在考虑的范围

**如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题**

## 14、面向对象程序设计

### 14.1、定义基类和派生类

#### 14.1.1、定义基类

在C++语言中，基类必须将它的两种成员函数区分开来：

1.  一种是基类希望其派生类进行覆盖的函数

2.  一种是基类希望派生类直接继承而不要改变的函数

对于第1种，基类通过将其定义成**虚函数**，使用**指针或引用**调用**虚函数**时，该调用将被**动态绑定**，根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类，**是根据所绑定的对象类型决定执行虚函数的版本**

任何**构造函数**之外的**非静态函数**都可以是虚函数，关键字`virtual`只能**出现在`类内部`的声明语句之前**而不能用于类外部的函数定义；**如果基类把一个函数声明称虚函数，则该函数在派生类中`隐式地`也是虚函数**

成员函数如果没有被声明成虚函数，则其解析过程发生**在编译时**(和普通函数一样，编译期就已确定)**而非运行时**(只有虚函数的解析发生在运行期，需要根据所绑定的对象来判断调用哪个版本的虚函数)

**派生类的成员**(而不是派生的对象)能访问基类的`公有和受保护的`成员，而**不能访问私有成员**

**基类通常都应该定义一个`虚析构函数`，即使该函数不执行任何实际操作也是如此**

#### 14.1.2、定义派生类

派生类必须通过使用`类派生列表`明确指出它是从哪个(哪些)基类继承而来的，类派生列表的形式是：

```c++
/*
 * 首先是一个冒号
 * 后面紧跟访问说明符：public, private, protected
 * 最后紧跟以逗号分隔的基类列表
 */
class Base {};
class A : public Base {};
```

**派生类必须将其继承而来的成员函数中`需要覆盖`的那些重新声明**，[虚函数不总是需要覆盖的](#xuhanshubuzongshixuyaofugaide)

##### 14.1.2.1、访问说明符

访问说明符的作用是**控制派生类从基类继承而来的成员是否对`派生类的用户`可见**；如果一个**派生是公有的**，则**基类的`公有成员`也是派生类的组成部分**；**能将`公有`派生类型的对象绑定到基类的引用或指针上，不能是`私有或受保护的`派生类型**

##### 14.1.2.2、派生类中的虚函数

**<span id="xuhanshubuzongshixuyaofugaide"> 派生类`经常(但不总是)`覆盖它继承的虚函数</span>，如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会`直接继承`其在基类中的版本**

派生类可以在它覆盖的函数前使用`virtual`关键字，也可以不使用；可以通过**在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字`override`显式地注明它使用某个成员函数覆盖了它继承的虚函数**

##### 14.1.2.3、派生类对象及派生类向基类的类型转换

一个派生类对象包含多个组成部分：

-   含有派生类**自己定义的**(非静态)成员的子对象
-   与该派生类**继承的基类对应**的子对象

**因为派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当成基类对象来使用，能将`基类的指针或引用`绑定到派生类的`基类部分`上**，这种转换叫**派生类到基类的**类型转换，编译器会隐式地执行派生类到基类的转换  **<前提是公有继承>**

```c++
struct A {};
struct B : public A {};
struct C : protected A {};
struct D : private A {};
int main() {
    A &a = b; // 正确
    A &a1 = c; // 错误
    A &a2 = d; // 错误
}
```

##### 14.1.2.4、派生类的构造函数

派生类必须使用**基类的构造函数**来初始化它的基类部分，派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的，派生类的构造函数是**通过初始化列表将实参传递给基类的构造函数的**，**每个类控制它自己的成员初始化过程**

```c++
Bulk_quote(string & book, double p, size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc) {}
```

除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化；如果想使用其他的基类构造函数，需要**以类名加圆括号内的实参列表的形式为构造函数提供初始值**，这些实参能够帮助编译器决定应该选用哪个构造函数来初始化派生类对象的基类部分

首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

##### 14.1.2.5、派生类使用基类的成员

派生类的**类内成员**(*对象是否可访问还与派生的访问说明符有关*)可以访问基类的公有成员和受保护成员，**派生类的作用域是嵌套在基类的作用域之内的**，对于派生类的一个成员来说，使用派生类成员的方式和使用基类成员的方式没什么不同

**每个类负责定义`各自的`接口，要想与`类的对象`交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此**，因此，派生类对象不能直接初始化基类的成员，通过调用基类的构造函数来初始化从基类继承而来的成员

##### 14.1.2.6、继承与静态成员

如果基类定义了一个静态成员，则在**整个继承体系中只存在该成员的唯一定义**，不论从基类派生出来多少个派生类，对于每个静态成员都只存在唯一的实例

静态成员遵循通用的访问控制规则，如果基类中的成员是`private`的，则派生类无权访问它；如果静态成员是可访问的，**既能通过基类使用也能通过派生类使用**

```c++
struct Base {
protected:
    static void statmen();
};
struct Derived : private Base { // 此处private只对外部Derived的对象有影响
    void f(const Derived& derived_obj) {
        Base::statmen(); // 正确
        Derived::statmen(); // 正确
        derived_obj.statmen(); // 正确：protected对于派生类的类内成员是可以访问的，此处dervied_obj出现在类内，是可以访问protected的statmen()成员，但不能通过Base的对象访问Base类中的protected对象
    }
};
```

##### 14.1.2.7、派生类的声明

派生类的声明中只包含类名但**不能包含它的派生列表**，派生类列表以及与定义有关的细节必须与类的主体一起出现

```c++
class Quote {};
class Bulk_quote : public Quote; // 错误：声明不能包含派生列表
class Bulk_quote; // 正确
```

##### 14.1.2.8、被用作基类的类

如果想将某个类用作基类，则该类必须**已经定义而非仅仅声明**，一个类不能派生它本身

每个类都会继承直接基类的所有成员，对于一个最终的派生类来说，会包含直接基类的子对象以及每个间接基类的子对象 

```c++
struct A {
protected:
    int a = 8;
};

struct C : protected A { // 此处的protected并不影响C的派生类
protected:
    int c = 9;
};

struct D : private C {
    void output() {
        cout << a << c << endl; // 正确：所有的继承都与派生访问说明符无关
    }
};
```

##### 14.1.2.9、防止继承的发生

在类名后跟一个关键字`final`可以防止继承发生

```c++
class NoDerived final {}; // NoDerived不能作基类
class Base {};
class Last final : Base {}; // Last不能作基类 
class Bad : Last {}; // 错误
class Bad2 : NoDerived {}; // 错误
```

#### 14.1.3、类型转换与继承

通常情况下，如果把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则；**存在继承关系的类是一个例外：可以将基类的指针或引用绑定到派生类对象上**

和内置指针一样，智能指针类也支持派生类向基类的类型转换

当使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型**与该表达式表示对象的**动态类型**区分开来，表达式的静态类型**在编译时总是已知的**，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到**运行时**才可知

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致，以静态类型为准

**不存在基类向派生类的转换**，因为派生类除了包含基类的部分，还包含自己的部分；**即使一个基类的指针或引用绑定在一个派生类对象上，也不能执行基类向派生类的转换**

```c++
Bulk_quote bulk;
Quote *itemP = &bulk;
Bulk_quote *bulkP = itemP; // 错误：不能将基类转换成派生类
```

**派生类向基类的自动转换只对`指针或引用`类型有效，在`派生类类型和基类类型`之间不存在这样的转换**

因为拷贝构造函数、赋值运算符、移动构造函数都接受引用作为参数，所以派生类向基类的转换允许给这些成员函数传递一个派生类的对象，但**因为这些成员函数不是虚函数**，实际运行时还是执行基类自己的相关成员函数，而不是派生类的成员函数

当用派生类对象为一个基类对象初始化或赋值时，**只有派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分将被忽略掉**

### 14.2、虚函数

通常情况下，如果不适用某个函数，则无须为该函数提供定义，但是**虚函数必须提供定义，不管它是否被用到了**

**动态绑定只有当通过`指针、引用`调用虚函数时才会发生，当通过一个具有普通类型(非引用非指针)的表达式调用函数时，在`编译时`就会将调用的版本确定下来**

**基类中的虚函数在派生类中隐含地也是一个虚函数**，一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的**形参类型必须与被它覆盖的基类函数完全一致，同样的返回类型也必须一致，但如果虚函数的返回类型是类本身的指针或引用时，上述规则将无效**，比如如果D由B派生得到，则基类的虚函数可以返回`B*`而派生类的对象可以返回`D*`，这样的返回值类型要求从D到B的类型转换是可访问的

虚函数也可以拥有**默认实参**，如果某次调用使用了默认实参，则该**实参值由本次调用的`静态类型`决定**；如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，**即使实际运行的是派生类中的函数版本也是如此**，**传入派生类函数**的将是**基类函数定义的默认实参**

在某些情况下，希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本，可以使用**作用域运算符**来实现这一目的

```c++
double undiscounted = baseP->Quote::net_price(42); // 不管baseP实际指向的对象类型到底是什么，都会强制调用Quote类的net_price函数
```

>   **注意**：如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析成**对派生类版本的自身调用**，从而导致无限递归

### 14.3、抽象基类

和普通的虚函数不一样，**纯虚函数无须定义**，可以在函数体的位置书写`= 0`就可以将一个虚函数说明为纯虚函数，`= 0`只能出现在**类内部的虚函数声明语句中**；可以为纯虚函数提供定义，不过**函数体必须定义在类的外部**，不能在类的内部为一个`= 0`的函数提供函数体

```c++
double net_price(size_t) const = 0;
```

含有(或未经覆盖直接继承)纯虚函数的类是**抽象基类**，抽象基类负责定义接口，而后续的其他类可以覆盖该接口；**不能(直接)创建一个抽象基类的对象，可以定义抽象基类的派生类的对象，前提是这些类覆盖了基类中的纯虚函数**，如果抽象基类的派生类没有给出自己的纯虚函数的定义，则派生类也是抽象基类

### 14.4、访问控制与继承

受保护的成员：

-   和私有成员一样，受保护的成员对于类的用户来说是不可访问的

-   和公有成员一样，受保护的成员对于**派生类的成员和友元**来说是可访问的

-   <span id = “teshuqingkuangjichengyupaisheng">**派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，不能在派生类中通过基类对象访问基类的`protected`成员**，派生类对于一个基类对象中的受保护成员没有任何访问特权</span>

    ```c++
    class Base {
    protected:
        int prot_mem;
    };
    class Sneaky : public Base {
        friend void clobber(Sneaky &); // 能访问Sneaky::prot_mem
        friend void clobber(Base &); // 不能访问Base::prot_mem
        int j;
    };
    void clobber(Sneaky &s) { s.j = s.prot_mem = 0; } // 正确
    void clobber(Base &b) { b.prot_mem = 0; } // 错误
    ```

:point_right::point_right:**派生类的成员和友元**只能访问`派生类对象`中的基类部分的受保护成员，对于普通的`基类对象`中的成员不具有特殊的访问权限 **<在派生类的成员函数中，只能通过派生类对象来访问基类的受保护的成员，不能通过基类对象去访问>**:point_left::point_left:

某个类对其继承而来的成员的访问权限受到两个因素影响：

-   在基类中该成员的访问说明符
-   派生类的派生列表中的访问说明符

**派生访问说明符对于`派生类的成员(及友元)`能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与`基类中的访问说明符`有关 <此处只对派生类的类体中的成员而言，而不是派生类对象而言的>**

**派生访问说明符的目的是控制`派生类用户`(包括派生类的派生类在内)对于基类成员的访问权限**

派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：

-   只有当D`公有地`继承B时，`用户代码`才能使用**派生类向基类的转换**；如果D继承B的方式是`受保护的或私有的`，则用户代码`不能`使用该转换
-   不论D以什么方式继承B，D的`成员函数和友元`(派生类内)都能使用派生类向基类的转换；**派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的  **<只与基类的成员访问权限有关，与派生访问权限无关>
-   如果D继承B的方式是`公有的或受保护`的，则**D的派生类的成员和友元可以使用D向B的类型转换**；反之如果D继承B的方式是私有的，则不能使用

**总结**：

-   子类对父类的访问权限：取决于父类中成员的权限设置，与继承权限无关，此处有个[特殊情况](#teshuqingkuangjichengyupaisheng)

    |               |       public       |     protected      |      private       |
    | ------------: | :----------------: | :----------------: | :----------------: |
    |    **public** | :white_check_mark: | :white_check_mark: | :white_check_mark: |
    | **protected** | :white_check_mark: | :white_check_mark: | :white_check_mark: |
    |   **private** |        :x:         |        :x:         |        :x:         |

-   类外对子类中继承自父类部分的访问权限：取决于继承权限和父类中成员的权限

    |               |    public     |   protected   |   private   |
    | ------------: | :-----------: | :-----------: | :---------: |
    |    **public** |  **public**   | **protected** | **private** |
    | **protected** | **protected** | **protected** | **private** |
    |   **private** |      :x:      |      :x:      |     :x:     |

    `protected`只是对于派生类的类内成员来讲是可以访问的，对于派生类的用户对象是最少是`protected`，不可以访问的

**友元关系不能继承**，基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员

```c++
class Base {
    friend class Pa1;
protected:
    int prot_mem;
};
class Pa1 {
public:
    int f(Base b) { return b.prot_mem; } // 正确
    int f1(Sneaky s) { return s.j; } // 错误
    int f2(Sneaky s) { return s.prot_mem; } // 正确
};
```

`Paul`是`Base`的友元，所以`Paul`能够访问`Base`对象的成员，这种**可访问性包括了`Base`对象内嵌在其派生类对象中**的情况；也就是说，**`Paul`可以访问`Base`以及`Base`所有派生类中的继承自基类的部分**

当一个类将另一个类声明为友元时，这种友元关系**只对做出声明的类有效**，那么这个**友元类的基类或派生类**不具有特殊的访问能力

<span id="类内`using`声明的一般规则同样适用于重载函数的名字">通过在派生类的内部使用`using`声明语句，可以将该类的直接或间接基类中的**任何可访问成员(非私有成员)**标记出来，`using`声明语句中的**名字的访问权限由`using`声明语句`之前`的访问说明符**来决定，如果一条`using`声明语句出现在类的`private`部分，则该名字只能被类的成员和友元访问，如果`using`声明语句位于`public`部分，则类的所有用户都能访问它，如果`using`声明语句位于`protected`部分，则该名字对于成员、友元和派生类都是可访问的</span>

```c++
class Base {
public:
    size_t size() const { return n; }
protected:
    size_t n;
};
class Derived : private Base {
public:
    // 默认情况下继承来的size()和n是对于类外成员来讲是Derived的私有成员
    using Base::size; // 类内、类外成员都能访问它
protected:
    using Base::n; // 派生类类内成员、类内成员、友元都能访问
};
```

默认情况下，使用`class`关键字定义的派生类是私有继承的，使用`struct`关键字定义的派生类是公有继承的

```c++
class Base {};
struct D1 : Base {}; // 默认是public继承
class D2 : Base {}; // 默认是private继承
```

### 14.5、继承中的类作用域

#### 14.5.1、在编译时进行名字查找

当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，**如果一个名字在派生类的作用域之内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义**

一个对象、引用或指针的**静态类型决定了该对象的哪些成员是可见的**，即使静态类型和动态类型不一致，能使用哪些成员仍然由`静态类型`决定的；`静态类型`决定编译器查找该成员的**起始位置**，只会向上查找，先在该类中查找，如果没有再在基类中查找，不会向下查找

#### 14.5.2、名字冲突与继承

和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域(派生类)的名字将隐藏定义在外层作用域(基类)的名字

可以通过作用域运算符来使用一个被隐藏的基类成员

```c++
struct Derived : Base {
    int get_base_mem() { return Base::mem; } // 指示编译器从Base作用域开始查找mem，确定了开始查找的位置后，遇到的第一个mem就是结果
};
```

>   **Tips**：除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字

**函数调用的解析过程**：调用`p->mem()`或`obj.mem()`

-   首先确定`p,obj`的**静态类型**
-   在`p,obj`的静态类型对应的类中查找`mem`，如果找不到，则**依次在直接基类中不断查找直至到达继承链的顶端**，如果找遍了该类及其基类仍谈找不到，则编译器将报错
-   一旦找到`mem`，就进行常规的类型检查，已确认对于当前找到的`mem`，本次调用是否合法
-   假设合法，则编译器将根据调用是否是虚函数而产生不同的代码：
    -   如果`mem`是虚函数且通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的那个版本，依据是对象的动态类型
    -   如果`mem`不是虚函数或者通过对象而非引用或指针进行的调用，则编译器将产生一个常规函数调用

#### 14.5.3、名字查找先于类型检查

[声明在内存作用域的函数并不会重载声明在外层作用域的函数](#shengmingzaineicunzuoyongdehanshubingbuhuichongzaishengmingzaiwaicengzuoyongyudehanshu)，因此定义在派生类中的函数也不会重载其基类中的成员，如果派生类的成员与基类的某个成员**同名**，则派生类将在作用域内`隐藏`(不是覆盖，**只有函数名、形参列表、返回值相同才是覆盖**)该基类成员，即使派生类成员和基类成员的形参列表不一样，基类成员也仍然会被隐藏掉 **<名字查找先于类型检查>**

**基类与派生类中的虚函数必须有相同的形参列表**

```c++
class Base {
public:
    virtual int func();
};

class D1 : public Base { 
public:
    // 由于没有定义和基类虚函数int func()相同类型的函数，此处func将隐藏从基类继承来的虚函数，只是隐藏而不是覆盖
    // 由于基类对派生类来讲属于外层作用域，当调用func时，会优先匹配int func(int)类型的函数，但是从基类继承而来的虚函数还是存在的
    // D1类中含有2个fcn函数：虚函数fcn，自定义的int func(int)
    int func(int); 
};

class D2 : public D1 {
public:
    // 虽然D1类中的func(int)把基类的虚函数隐藏了，但还是存在的
    int func(); // 覆盖Base的虚函数fcn
};

int main() {
    Base bobj;
    D1 d1obj;
    D2 d2obj;
    
    Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj;
    bp1->func(); // 虚调用，将在运行时调用Base::fcn
    bp2->func(); // 虚调用：将在运行时调用Base::fcn，此时虚函数是存在于D1的，是直接继承Base的，而没有被覆盖
    bp3->func(); // 虚调用：将在运行时调用D2::fcn，D2定义的fcn覆盖了虚函数
    return 0;
}
```

和其他函数一样，成员函数无论是否是虚函数都能被重载，派生类可以覆盖(从基类继承来的)重载函数的0个或多个实例<**这样派生类中只能调用被负载的函数，其他没被负载的将被**`隐藏`>；如果派生类希望所有的(从基类继承来的)重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖(全部使用继承自基类的重载函数)

有时一个类仅需要覆盖重载集合中的一些而非全部函数(没被覆盖的需要继承下来，并且不被隐藏)，此时，不得不覆盖基类中的每一个版本；除此之外，可以**为重载的成员提供一条`using`声明语句**，这样就不需要覆盖基类中的每一个重载版本了

`using`声明语句**指定一个名字而不指定形参列表**，所以一条基类成员函数的`using`声明语句就可以**把该函数的`所有重载实例`加到派生类作用域中，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义**

[类内`using`声明的一般规则同样适用于重载函数的名字](#类内`using`声明的一般规则同样适用于重载函数的名字)，**基类函数的每个实例在派生类中都必须是可访问的，需要声明在`public`下**，对派生类没有定义的重载版本的访问实际上是对`using`声明点的访问

### 15.6、构造函数和拷贝控制

#### 15.6.1、虚析构函数

由于通过基类的指针可以指向基类或者派生类，发生指针的静态类型与被删除对象的动态类型不符的情况；**通过在基类中将析构函数定义成为虚函数以确保执行正确的析构函数，确保根据动态绑定的类型执行相应的析构函数**

**虚析构函数的虚属性也会被继承**，所以无论派生类使用合成的析构函数还是自定义的析构函数，都将是虚析构函数

**如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为**

[前面介绍](#需要自定义的析构函数的类也需要自定义的拷贝和赋值操作)，如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作；基类的析构函数并不遵循上述准则，一个基类**总是需要析构函数**，而且它能将析构函数设定为虚函数，此时该析构函数为了成为虚析构函数而令内容为空，显然无法由此推断该基类是否需要赋值运算或拷贝构造函数

**如果一个类定义了析构函数，即使它通过`=default`的形式使用了合成的版本，编译器也不会为这个类合成移动操作**

#### 15.6.2、合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作；**这些合成的成员还负责使用`直接基类`中对应的操作对一个对象的`直接基类部分`进行初始化、赋值或销毁操作**，但要求相应的成员应该是可访问的并且不是一个删除的函数

对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类，该直接基类优惠销毁他自己的直接基类，以此类推直至继承链的顶端

[就像其他任何类的情况一样](#就像其他任何类的情况一样)，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数,，此外，某些定义基类的方式也可能导致有的派生成员成为被删除的函数：

![image-20211215000841534](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211215000841534.png)

**大多数基类都会定义一个虚析构函数，因此默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作**；如果确实需要执行移动操作时**应该首先在基类中进行`显式地`定义，并且同时需要显式地定义拷贝操作，接着派生类将自动获得合成的移动操作**，除非派生类中含有排斥移动的成员

#### 15.6.3、派生类的拷贝控制成员

派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员(使用基类的拷贝构造和移动构造函数)，派生类的赋值运算符也必须为其基类部分的成员赋值(使用基类的赋值运算符)

和构造函数及赋值运算符不同的是，**析构函数只负责销毁派生类自己分配的资源**，派生类对象的基类部分也是自动销毁的

**定义派生类的拷贝或移动构造函数**：

```c++
class Base {};
class D : public Base {
    D(const D& d) : Base(d) {} // 拷贝构造
    D(const D&& d) : Base(move(d)) {} // 移动构造
    D& operator=(const D &rhs) { // 赋值运算符
        Base::operator=(rhs);
        return *this;
    }
};
```

在默认情况下，基类默认构造函数初始化派生类对象的基类部分；如果想拷贝或移动基类部分，则**必须在派生类的构造函数初始值列表中`显式地`使用基类的拷贝或移动构造函数**，派生类的赋值运算符必须显式地为其基类部分赋值，基类的赋值运算符不会自动调用

**如果构造函数或析构函数调用了某个虚函数，则执行与构造函数或析构函数`所属类型相对应的`虚函数版本，`不会`发生动态绑定**；派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。

>   **Tips**：一般不要在构造函数和析构函数中调用虚函数

#### 15.6.4、继承的构造函数

派生类能够重用其**直接基类定义**的构造函数；**类不能继承默认、拷贝和移动构造函数**，如果派生类没有直接定义这些构造函数，则编译器将为将为派生类合成它们；**`派生类继承基类构造函数的方式`是提供一条注明了(直接)基类名的`using`声明语句**

```c++
class Base {};
class Derived {
public:
    using Base::Base; // 继承Base的构造函数
};
```

通常情况下，`using`声明语句只是令某个名字在当前作用域内可见，而当作用于构造函数时，`using`声明语句将令编译器产生代码，对于基类的每一个构造函数，编译器都生成一个与之对应的(**形参列表相同的**)派生类构造函数

```c++
derived(parms) : base(args) {} // 形参列表和基类的完全相同，派生类自己的数据成员将被默认初始化
```

和普通成员的`using`声明不一样，**一个构造函数的`using`声明不会改变该构造函数的访问级别**，不管`using`声明出现在哪里，基类的私有构造函数在派生类中还是私有构造函数，公有的还是公有，受保护的还是受保护的

一个`using`声明的语句不能指定`explicit`或`constexpr`，如果基类的构造函数是`explicit, constexpr`的，则继承的构造函数也拥有相同的属性

当一个基类构造函数含有默认实参时，**这些实参并不会被继承**，相反，**派生类将获得多个继承的构造函数**，其中每个构造函数分别**省略掉一个含有默认实参的形参**

如果基类含有几个构造函数，除了两个例外，大多数时候派生类会继承所有这些构造函数：

-   派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本
-   默认、拷贝和移动构造函数不会被继承，这些构造函数按照正常规则被合成，**继承的构造函数不会被作为用户定义的构造函数来使用，则还会生成一个合成的默认构造函数**

### 15.7、容器与继承

使用容器存放继承体系中的对象时，必须采用`间接`存储的方式，**存放基类的指针(智能指针)**，指针所指对象的动态类型可以是基类类型或派生类类型

```c++
vector<shared_ptr<Base>> base;
base.push_back(make_shared<Derived>(derived));
```

### 15.8、多重继承

每个基类包含一个可选的访问说明符，如果访问说明符被忽略了，则关键字class对应的默认访问说明符是private，关键字struct对应的是public

多重继承的派生列表只能包含**已经被定义过**的类，而且这些类不能是final的

多重继承的派生类的构造函数初始值只能初始化它的**直接基类**，派生类的构造函数初始值列表将实参分别传递给每个直接基类，基类的构造顺序与**派生类列表中的基类的出现顺序**保持一致

派生类可以从它的一个或几个基类中继承构造函数，但如果从多个基类中继承了相同的构造函数(形参列表完全相同)，程序将产生错误；否则**派生类必须为该构造函数定义自己的版本**，同时还需要**显式地定义**默认构造函数

派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的

多重继承的派生类如果定义了自己的拷贝、赋值构造函数和赋值运算符，则必须在***完整的对象上***执行拷贝、移动或赋值操作；只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作，在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作

#### 15.8.1、类型转换与多个基类

在多重继承中，也可以令某个**可访问**基类的指针或引用直接指向一个派生类对象

#### 15.8.2、多重继承下的类作用域

查找过程沿着继承体系自底向上进行，直到找到所需的名字，派生类的名字将隐藏基类的同名成员；在多重继承中，相同的查找过程在所有**直接基类**中**同时**进行，如果名字在多个基类中都被找到，则对该名字的使用将产生二义性，但可以通过添加前缀信息调用

### 15.9.虚继承

虚继承的目的是令某个类做出声明，承诺愿意共享它的基类，共享的基类子对象成为**虚基类**，**不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象**

**虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身**

指定虚基类的方法：在派生列表中添加关键字`virtual`

```c++
class Raccoon : public virtual ZooAnimal {};
```

**不论基类是不是虚基类，派生类(或派生的派生类)对象都能被可访问基类的指针或引用操作**

**虚基类成员的可见性**：

-   因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被(派生的派生类)直接访问，并不会产生二义性；
-   如果虚基类只被一条派生路径覆盖，则仍然可以直接访问被覆盖的成员，此时访问到的就是直接基类中成员，而不是虚基类的成员；
-   如果成员被多个基类覆盖，则一般情况下派生类必须为该成员自定义一个版本，否则会产生二义性

![image-20211219144139382](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211219144139382.png)

#### 15.9.1、构造函数与虚继承

**在虚派生中，虚基类是由最底层的派生类初始化**

含有虚基类的对象的构造顺序：首先使用提供给**最底层**基类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其初始化

**虚基类总是先于非虚基类构造**

一个类可以有多个虚基类，这些虚的子对象按照它们在派生列表中出现的顺序从左到右依次构造；编译器**按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类，如果有，则先构造虚基类，然后按照声明的顺序依次构造其他非虚基类**

```c++
class ZooAnimal {};
class Bear : public virtual ZooAnimal {};
class Raccon : public virtual ZooAnimal {};
class Character {};
class BookCharacter : public Character {};
class ToyAnimal {};
class TeddyBear : public BooKCharacter, public Bear, public virtual ToyAnimal {};
TeddyBear tb;
// tb的构造顺序
// 按照TeddyBear的直接基类声明的顺序对其依次检查，看是否有虚基类
// BooKCharacter没有，Bear有，ToyAnimal有
ZooAnimal();
ToyAnimal();
// 按照声明的顺序依次构造非虚基类
Character();
BookCharacter();
Bear();
TeddyBear();
```

合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值，和往常一样，对象的销毁顺序与构造顺序正好相反

## 16、模板与泛型编程

### 16.1、定义模板

#### 16.1.1、函数模板

函数模板的定义形式

```c++
template <模板参数列表>
函数定义
```

在函数模板的**定义**中，**模板参数列表不能为空**

模板参数表示类或函数定义中用到的**类型或值**，使用模板时，可以隐式或显式地指定**模板实参**，将其绑定到模板参数上

调用函数模板时，`编译器`用函数实参来推断模板实参，用推断出来的模板实参来实例化一个特定版本的函数

函数模板可以声明为`inline`或`constexpr`的，`inline、constexpr`说明符放在模板参数列表之后，返回类型之前

```c++
template <typename T> inline T min(const T&, const T&);
```

##### 16.1.1.1、类型参数

可以**将类型参数看作类型说明符**，像内置类型或类类型说明符一样使用，类型说明符可以用来**指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换**

```c++
template <typename T>
T foo(T* p) {
    T tmp = *p;
    
    return tmp;
}
```

**类型参数前必须使用关键字`class`或`typename`**，两者可以随便搭配着用

```c++
template <typename T, U>  // 错误：每个类型参数前都要使用关键字
T calc(const T&, const U&);
```

##### 16.1.1.2、非类型参数

非类型参数表示一个**值**而非一个类型，通过**特定的类型名**而非关键字`class、typename`来指定非类型参数

当一个模板被实例化时，**非类型参数**被一个用户提供的或编译器推断出的值所代替，这些值必须是**常量表达式**，从而允许编译器在**编译时**实例化模板

一个非类型参数可以是**整型、指向对象或函数类型的指针、(左值)引用**，绑定到**非类型整型参数**的实参必须是一个**常量表达式**，绑定到**指针或引用的非类型参数**的实参必须**具有静态的生存期**，指针参数也可以用`nullptr、0`来实例化

模板非类型参数是一个常量值，在需要常量表达式的地方，可以使用非类型参数，例如指定数组的大小

>   **说明**：模板的实例化是在编译器进行的

#### 16.1.2、类模板

类模板以关键字`template`开始，后跟**模板参数列表**，在类模板及其成员的定义中将模板参数当作替身，代替使用模板时用户需要提供的类型和值

```c++
template <typename T> // 定义模板
class Blob {};

Blob<int> blob; // 使用模板
```

与函数模板不同，**编译器不能为类模板推断模板参数类型**，使用类模板**必须使用`显式模板实参`，在模板名后的尖括号中提供额外信息**，用来代替模板参数的模板实参列表；但**在类模板的作用域内，可以直接使用模板名而不提供实参**；如果**在类外定义其成员，直到遇到类名才表示进入类的作用域，函数的返回值位于类的作用域之外**

```c++
template <typename T>
class BlobPtr {
public:
    BlobPtr() {}
    BlobPtr& operator++(); // 模板作用域内，直接使用模板名，而不用指定显式模板实参
};
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++() {
    //可以直接使用BlobPtr，不需要指定显式实参
}
```

**一个类模板的每个实例都形成一个`独立`的类**

:point_right::point_right:**类模板的名字不是一个类型名**:point_left::point_left:，类模板用来实例化类型，而一个**实例化的类型总是包含模板参数**的，所以只有实例化的模板才是类型

```c++
vector<int> res; // vector<int>是类型
```

##### 16.1.2.1、类模板的成员函数

成员函数既可以在类模板内部定义，也可以在类模板外部定义；类模板的**每个实例都有自己版本的成员函数**，类模板的成员函数具有和模板相同的模板参数，所以

-   **定义在类模板之外的成员函数必须以关键字`template`开始，后接类模板参数列表**；
-   同时还需要说明成员属于哪一个类，从一个模板生成的类的名字中必须包含模板实参，当定义一个成员函数时，**模板实参和模板形参相同**

```c++
template <typename T> // 需要指明模板参数
ret-type Blob<T>::member-name(parm-list) {} // 需要指明该函数属于哪一个类，类名包含模板实参，模板实参和模板形参相同 Blob<T>
```

构造函数也属于成员函数，类模板外部定义也需要和成员函数的要求一样

默认情况下，**一个类模板的成员函数只有当程序用到它时才进行实例化**；如果一个成员函数没有被使用，则它不会被实例化；这一特性使得某种类型不能完全符合模板操作的要求，仍能用该类型实例化类

##### 16.1.2.2、类模板和友元

如果一个类模板包含一个非模板友元，则友元被授权可以访问**所有模板实例**；如果友元自身是模板，可以授权给所有友元模板实例，也可以授权给特定实例

###### 16.1.2.2.1、一对一友好关系

类模板与另一个模板间友好关系的最常见形式是**建立`对应实例`及其友元间的友好关系**，友元的声明用类模板的模板形参作为自己的模板实参

```c++
template <typename T> class BlobPtr;
template <typename T> class Blob;
template <typename T>
bool operator==(const Blob<T>&, const Blob<T>&);
template<typename T>
class Blob {
    friend class BlobPtr<T>; // 用类模板的形参作为友元的模板实参，可以建立对应实例间的友元关系 
    friend bool operator==<T>(const Blob<T>&, const Blob<T>&);
};
```

###### 16.1.2.2、通用和特定的模板友好关系

一个类可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元

```c++
template <typename T> class Pal;
class C {
    friend class Pal<C>; // 限定特定的实例为友元
    template <typename T> friend class Pal2; // 每一个实例都声明为友元
};
template <typename T>
class C2 {
    friend class Pal<T>; // 一对一友好关系，也是特定友好关系
    template <typename X> friend class Pal2; // Pal2所有的实例都是C2的每个实例的友元
    friend class Pal3; // Pal3是非模板类，C2所有实例的友元
};
```

**类模板所有的实例都成为友元，友元声明中必须使用与类模板本身`不同`的模板参数**

###### 16.1.2.3、令模板自己的类型参数成为友元

```c++
template <typename Type>
class Bar {
    friend Type; // 令模板自己的类型参数成为友元
    /////////
};
```

##### 16.1.2.3、模板类型别名

类模板的**一个实例定义了一个类类型**，可以定义一个`typedef`来引用实例化的类

```c++
typedef Blob<string> StrBlob;
```

由于模板不是一个类型，不能定义一个`typedef`引用一个模板，但可以通过`using`为模板定义一个类型别名

```c++
template <typename T> using twin = pair<T, T>;
twin<int> win_loss; // == pair<int, int>
twin<string> win_str; // == pair<string, string>
```

当定义一个模板类型别名时，可以**固定一个或多个模板参数**

```c++
template <typename T> using partNp = pair<string, T>;
partNp<string> books; // == pair<string, string>
```

##### 16.1.2.4、类模板的static成员

模板类的每个`static`数据成员必须有且仅有一个定义，类模板的每个实例都有一个`独有`的static对象，**在类外定义`static`数据成员也需要定义成模板**

```c++
template <typename T>
size_t Foo<T>::ctr = 0;
```

与非模板类的静态成员相同，可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员，通过类直接访问时，必须引用一个特定的实例；和其他成员函数一样，static成员函数只有在使用时才会实例化

#### 16.1.3、模板参数

模板参数遵循普通的作用域规则，一个**模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前**；模板参数会隐藏外层作用域中声明的相同名字，**在模板内不能重用模板类型参数名**，并且一个模板参数名在一个模板参数列表中只能出现一次

```c++
typedef double A;
template <typename A, typename B>
void f(A a, B b) {
    A tmp = a; // A是模板参数A的类型，不是double的别名
    double B; // 错误：不能重用模板参数B
}
```

##### 16.1.3.1、模板声明

**模板声明必须包含模板参数**，但可以不指定具体的模板参数名；声明中的模板参数名不必与定义中的相同，但一个给定模板的每个声明和定义必须有相同数量和种类(类型参数、非类型参数)的参数

```c++
template <typename D, typename> class ff; // 必须包含模板参数，但可以不指定模板参数名
template <typename A, typename B> // 声明和定义的参数数量和种类需要相同，参数名可以不同
class fff {};
```

##### 16.1.3.2、使用类的类型成员

默认情况下，**C++语言假定通过作用域运算符访问的名字不是类型**，如果使用一个**模板类型的类型成员**，必须**通过`typename`显式告诉编译器该名字是一个类型**

```c++
typename T::value_type
```

##### 16.1.3.3、默认模板实参

与函数默认实参一样，对于一个模板参数，只有当**它右侧所有参数都有默认实参**时，它才可以有**默认实参**

无论何时**使用**一个**类模板，都必须在模板名之后接上尖括号**，尖括号指出类必须从一个模板实例化而来；如果一个类模板为其所有模板参数都提供了默认实参，且使用这些默认实参，就必须在模板名之后跟一个空尖括号对

```c++
template <typename T = int> // 提供默认模板实参 
class Numbers {};
Numbers<> average; // 使用默认实参
```

#### 16.1.4、成员模板

一个类(模板类或普通类)可以包含本身是模板的成员函数，这种成员称为成员模板，**成员模板不能是虚函数**

##### 16.1.4.1、普通类的成员模板

成员模板也是以模板参数列表开始，在调用时会编译器会自动推断模板实参类型

```c++
class A {
public:
    template <typename T>
    void func(T *p) const;
};
```

##### 16.1.4.2、类模板的成员模板

对于类模板，可以为其定义成员模板，**类和成员各自有自己的、独立的模板参数**；与类模板的普通函数不同，成员模板是函数模板，当在类模板**外定义一个成员模板**时，必须**同时为类模板和成员模板提供模板参数列表**，类模板参数列表在前，后跟成员自己的模板参数列表

```c++
template <typename T> // 类模板参数
template <typename It> // 成员模板参数
Blob<T>::Blob(It b, It e) {}
```

实例化一个类模板的成员函数，必须**同时提供类和函数模板的实参**，在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参，根据传递给成员模板的函数实参来推断它的模板实参

#### 16.1.5、控制实例化

当模板使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中；当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中都会有该模板的一个实例；可以通过`显式实例化`来避免在多个文件中生成同类型的实例化

```c++
extern template declaration; // 实例化声明
template declaration; // 实例化定义
// declaration是一个<<<||||||类或函数声明||||||>>>，其中所有模板参数已被替换为模板实参
extern template class Blob<string>; // 实例化声明
template class Blob<string>; // 实例化定义
template int compare(const int &, const int &);
```

当编译器遇到`extern`模板声明时，它不会在本文件中生成实例化代码，而遇到实例化定义时，会为它生成代码；**对于一个给定的实例化版本，可能有多个`extern`声明，但必须只有一个定义**

**`extern`声明必须出现在任何使用此实例化版本的代码之前**

与处理模板的普通实例化不同，一个类的**实例化定义会实例化该模板的`所有`成员**，包括内联的成员函数，此时需要保证所用类型能用于模板的所有成员

### 16.2、函数模板实参推测

#### 16.2.1、类型转化与模板类型参数

与非模板函数一样，在一次调用中传递给**函数模板**的**实参**被用来**初始化函数的形参**；如果一个**函数形参的类型使用了模板类型参数**，那么**采用特殊的初始化规则**；编译器通常**不是对实参进行类型转换**，而是生成一个新的模板实例

[和往常一样](#xingcandedingcengconst)，顶层`const`(本身是const的)无论在**形参**还是**实参**中都会被忽略；在其他类型转换中，能在调用中应用于函数模板的包括如下两项：

-   `const`转换：可以将一个非`const`对象的引用或指针传递给一个`const`的引用或指针形参，也就是说，**非`const`对象可以赋值给`const`的引用**
-   数组或函数指针转换：如果**函数形参不是引用类型**，则**可以对数组类型的实参应用正常的指针转换**。一个数组实参可以转换为一个指向其首元素的指针，一个函数实参可以转换为一个该函数类型的指针

**其他类型转换，如算数转换、派生类向基类的转换、用户定义的转换都不能用于函数模板**

```c++
template <typename T> T fobj(T, T); 
template <typename T> T fref(const T&, const T&); // 底层引用
string s1("a value"); 
const string s2("another value");
fobj(s1, s2); // 调用fobj(string, string)，const string s2的顶层const被忽略
fref(s1, s2); // 调用fref(const T&, const T&)，将string s1非const引用传递给const的引用
int a[10], b[42];
fobj(a, b); // 形参不是引用类型，数组名可以转换为指针，调用fobj(int *, int *)
fref(a, b); // 错误：形参是引用类型，数组名不能转化为指针，两个数组的类型不统一
```

>   **说明**：将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有`const`转换及数组或函数到指针的转换

**一个模板类型参数可以用作多个函数形参的类型，由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型**

```c++
template <typename T>
bool compare(T a, T b);
long lng;
compare(lng, 1024); // 错误：不能实例化compare(long, int)
```

可以通过将函数模板的每一个形参类型单独取名定义，这样可以对函数实参进行正常的类型推断

函数模板可以有用**普通类型定义的参数**，这种实参**不进行特殊处理**，可以正常进行类型转换

```c++
template <typename T>
ostream& print(ostream &os, const T &obj) {}
print(cout, 42); // os可以进行正常的类型转换，调用print(ostream&, int)
```

#### 16.2.2、函数模板显式实参

对于**函数模板的返回类型，编译器无法推断出返回类型，需要用户显式控制返回类型**

显式模板**实参在尖括号中给出**，位于函数名之后，实参列表之前；**显式模板实参按由左至右的顺序与对应的模板参数匹配**：第一个模板实参与第一个模板参数匹配，依次类推；**只有`最右边参数`的显式模板实参才可以忽略，前提是它们可以从函数参数推断出来**

```c++
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);
auto val3 = sum<long long>(i, lng); // long long sum(int, long)

template <typename T1, typename T2, typename T3>
T3 sum1(T2, T1);
auto val4 = sum<long long>(i, lng); // 错误：T3的类型未知
```

**对于模板参数已经`显式指定`了的函数实参，可以进行正常的类型转换**

```c++
template <typename T>
bool compare(T a, T b);
long lng;
compare<int>(lng, 43); // 正确：long能转换为int
```

#### 16.2.3、尾置返回类型与类型转换

尾置返回类型的形式：

```c++
auto function(param) -> decltype(param) const;
```

**由于尾置返回类型出现在参数列表之后，它可以使用函数的参数**

>   **注**：`decltype`对左值的推断结果是一个**引用**类型

**进行类型转换的标准库模板类**

![image-20211223232211097](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211223232211097.png)

#### 16.2.4、函数指针和实参推断

当用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用**指针的类型**来推断**模板实参**

如果不能从函数指针类型确定模板实参，则会产生错误

**当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数能唯一确定其类型和值**

```c++
template <typename T>
int compare(const T&, const T&);

void func(int(*)(const string&, const string&));
void func(int(*)(const int&, const int&));
func(compare); // 错误：不知道使用哪一个版本的实例
func(compare<int>); // 可以通过显式模板实参消除歧义
```

#### 16.2.5、模板实参的推断和引用

##### 16.2.5.1、从左值引用函数参数推断类型

当一个函数参数是**模板类型参数的一个普通左值引用**时，**只能传递它一个左值**；实参可以是`const`的，也可以不是，如果实参是`const`的，则被推断为`const`类型的

当一个函数参数是**模板类型参数的一个`const`的左值引用**时，可以传递它**任何类型**的实参，可以是(`const`或非`const`)对象、临时对象、字面常量值；此时推断的类型结果不会是一个`const`类型，`const`已经是函数参数类型的一部分了

```c++
template <typename T>
void f1(const T&);
f1(42); // T推断结果是int，而不是const int
```

##### 16.2.5.2、从右值引用函数参数推断类型

当一个函数参数是一个右值引用时，可以传递一个右值，也**可以是一个左值，前提是函数的右值引用参数必须指向模板类型参数**

正常绑定规则之外的两个例外规则：

-   当一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时，编译器**推断模板类型参数为实参的左值引用类型**
-   如果间接的创建一个引用的引用，则这些引用形成了`折叠`；除了右值引用的右值引用会折叠成右值引用外，其他所有折叠结果都是左值

>   **说明**：引用折叠只能应用于**间接创建**的引用的引用，如类型别名或模板参数

```c++
template <typename T>
void fun(T&&);
int i = 32;
fun(i); // i是一个左值，编译器推断T为一个左值引用类型int&，因此int& &&折叠为int&，可以传递左值实例化fun
```

总结：

-   如果一个函数参数是一个指向模板类型参数的右值引用，则它可以被绑定到一个左值
-   如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个普通左值引用参数

如果一个函数参数是**指向模板参数类型**的**右值引用**，则可以传递给它**任意类型的实参**；如果将一个左值传递给它，则函数参数被实例化为一个普通的左值引用

在实际中，右值引用通常用于两种情况：

-   模板转发其实参
-   模板被重载

>   **说明**：虽然不能**直接**将一个左值绑定到右值引用上，但可以通过[`move`](#moveshixianyouzhiyinyongbangdingzuozhiyinyong)实现；也可以通过`static_cast`强制将一个左值转换为右值引用

#### 16.2.6、转发

通过将一个函数参数定义为**一个指向模板类型参数的`右值`引用**，可以**保持其对应实参的所有类型信息**，而使用**引用参数**(无论是左值还是右值)都可以**保持`const`属性**，因为在引用类型中的`const`是底层的

可以使用`forward`传递那些定义为模板类型参数的**右值引用**的函数参数，通过其返回类型上的引用折叠，`forward`可以保持给定实参的左值、右值属性

```c++
template <typename Type> intermediary(Type &&arg) { // 这里的arg是右值
    finalFcn(std::forward<Type>(arg)); // 此处的arg成为左值，如果保持arg的右值属性，forward可以保持右值属性
}
```

### 16.3、重载与模板

函数模板可以被另一个模板或一个普通非模板函数重载，名字相同的函数必须具有不同数量或类型的参数

如果涉及函数模板，则函数匹配规则会在以下方面受到影响：

-   对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例
-   候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板
-   可行函数(包括模板与非模板函数)按类型转换来排序
-   如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数；如果有多个函数提供同样好的匹配，则：
    -   如果同样好的函数中只有一个是非模板函数，则选择此函数
    -   如果同样好的函数没有非模板函数，而且有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板
    -   否则，此调用有歧义

```c++
template <typename T> string debug_rep(const T &);
template <typename T> string debug_rep(T *);
string s;
const string *sp = &s;
cout << debug_rep(sp) << endl; // 因为T*比const T&更特例化，调用debug_rep(T *)
```

**当有多个重载模板对一个调用提供同样好的匹配时，应选择`最特例化`的版本**

在定义任何函数之前，记得**声明所有重载的函数版本**，这样就不必担心编译器由于未遇到希望调用的函数而实例化一个并非所需的版本

```c++
template <typename T> string debug_rep(const T &t);
template <typename T> string debug_rep(T *p);
string debug_rep(const string &); // 此处需要声明，否则编译器会自己实例化一个
string debug_rep(char *p)
{
	return debug_rep(string(p));
}
```

### 16.4、可变参数模板

**可变参数模板**是一个接受可变数目参数的模板函数或模板类，可变数目的**参数**被称为**参数包**；存在两种参数包：

-   模板参数包：表示零个或多个模板参数
-   函数参数包：表示零个或多个函数参数

用一个省略号来**指出**一个模板参数或函数参数表示一个包；在一个模板参数列表中，`class...`或`typename...`指出接下来的参数表示零个或多个类型的列表；一个类型名跟一个省略号表示零个或多个给定类型的非类型参数的列表；在函数参数列表中，如果一个参数的类型是一个模板参数包，则此**参数**也是一个函数参数包

```c++
template <typename T, typename... ARGS> // ARGS是一个模板参数包
void foo(const T &t, const ARGS& ... rest); // rest是一个函数参数包
```

与往常一样，编译器从函数的实参推断模板参数类型；对于一个可变参数模板，编译器还会推断包中参数的数目

可以使用`sizeof...`运算符查看包中有多少元素

```c++
template <typename T, typename... ARGS> 
void foo(const T &t, const ARGS& ... rest) {
    cout << sizeof...(ARGS) << endl;
    cout << sizeof...(rest) << endl;
}
```

**可变参数函数通常是递归的**，第一步调用处理包中的第一个实参，然后用剩余实参调用自身；为了终止递归，还需要定义一个**非可变参数**的函数版本，此函数**必须在可变参数版本定义之前声明**

```c++
template<typename T>
ostream &print(ostream &os, const T &t) // 终止递归版本
{
	return os << t; 
}

template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest)
{
    os << t << ", "; 
    return print(os, rest...); // 递归调用
}
```

对于最后一个调用，两个函数模板提供同样好的匹配，但是非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本

##### 16.4.1、包扩展

当扩展一个参数包(包括模板参数包和函数参数包)时，还要提供用于**每个扩展元素的模式**；**扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表**；通过在**模式右边**(模式是…左边的内容)放一个省略号来触发扩展操作

```c++
template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest) { // 扩展Args，模式是const Args&，每个元素的类型都是const type&，此模式扩展结果是一个逗号分隔的零个或多个类型的列表
    os << t << ", ";
    return print(os, rest...); // 扩展rest，模式是函数参数包的名字rest，此模式扩展的结果是一个由包中元素组成的、逗号分隔的列表
}
```

**第一个扩展操作扩展模板参数包**，为模板函数生成**函数参数列表**，此模式扩展结果是一个逗号分隔的零个或多个**类型的列表**；**第二个扩展操作扩展函数参数包**，出现在**递归调用**中，为调用生成实参列表，此模式扩展的结果是一个由**包中元素**组成的、逗号分隔的列表

函数参数包扩展仅仅将包扩展为构成元素，允许更复杂的扩展模式

```c++
template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest) { 
    os << t << ", ";
    return print(os, debug_rep(rest)...); // 扩展rest，模式是debug_rep(rest)
    // return print(os, debug_rep(rest...)); // 错误
}
```

**扩展中的模式会`独立地`应用于包中的每个元素**

##### 16.4.2、转发参数包

可变参数函数通常将它们的参数转发给其他函数，可以组合使用可变参数模板与`forward`机制来编写函数

```c++
template <class... Args>
inline void emplace_back(Args&&... args)
{
    alloc.construct(first_free++, std::forward<Args>(args)...);  // 既扩展了模板参数Args，又扩展了函数参数包args
}
```

### 16.5、模板特例化

#### 16.5.1、定义函数模板特例化

当特例化一个函数模板时，必须为原模板中的**每个模板参数**都提供实参；为了指出正在实例化的一个模板，应使用关键字`template`后跟一个**空括号对**`<>`，空括号指出将为原模板的所有模板参数提供实参

```c++
template <typename T>
int compare(const T &, const T &);

template <>
int compare(const char* const &p1, const char* const &p2) {} // T的类型是const *
```

当定义一个特例化版本时，**函数参数类型必须与一个之前声明的模板中对应的类型匹配**

当定义函数模板的特例化版本时，本质上接管了编译器的工作，为原模板的一个特殊实例提供定义；**一个特例化版本本质上是一个实例，而非函数名的一个重载版本，因此特例化不影响函数匹配**

将一个特殊的函数定义为一个**特例化版本**还是一个**独立的非模板函数**，会影响到匹配；如果都同时匹配时，会匹配非模板函数；而如果没有定义非模板函数，则优先匹配特例化版本

**为了特例化一个模板，原模板的声明必须在作用域中，而且在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中**

>   **Tips**：模板及其特例化版本应该声明在同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本

#### 16.5.2、类模板特例化

##### 16.5.2.1、全特化

全特化一个类模板时，使用关键字`template`后跟一个**空括号对**`<>`，**类模板名后跟`<>`以及指出所有特例化的参数类型**

```c++
template <typename T, typename U>
class A {};
template <>
class A<int, int> {}; // 全特化
```

**模板特例化必须定义在`原始模板`所属的命名空间中**，只要在命名空间中声明了特例化，就可以在命名空间外部定义它

##### 16.5.2.2、偏特化

与函数模板不同，类模板的特例化不必为所有模板参数提供实参；可以指定一部分而非所有模板参数，或是参数的一部分而非全部特性

**一个类模板的部分特例化本身是一个模板**，与往常一样，首先**定义模板参数**，部分特例化版本的**名字与原模板名字相同**，对每个**未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应**，在**类名之后，为要特例化的模板参数指定实参**，这些实参**列于模板名之后的括号中**，这些实参**与原始模板中的参数按位置对应**

```c++
template<typename T, typename U>
class A { };

template<typename U>
class A<int, U> {}; // 偏特化
```

部分特例化版本的模板参数列表是原始模板的参数列表的**一个子集**或者**一个特例化版本**

可以**只特例化特定成员函数而不是特例化整个模板**

```c++
template <typename T> struct Foo {
    Foo(const T &t = T()): mem(t) { }
    void Bar() { /* ... */ }
    T mem;
};
template<> // 只特例化成员函数
void Foo<int>::Bar() // 用int之外的类型时，成员像往常一样进行实例化
{

}
```

>   **说明**：
>
>   -   **模板程序应该尽量减少对实参类型的要求**，比如只使用`<`而不是`>, <`，因为有的类型并没有重载`>`
>   -   当编译器遇到一个模板定义时，它并不生成代码；只有实例化出模板的一个特定版本时，编译器才会生成代码
>   -   **函数模板和类模板的成员函数的定义通常放在头文件中**

## 20、编程技巧

### 1、编写自己的头文件

头文件通常包含那些**只能被定义一次**的**实体**，如类、const和constexpr变量等。类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字一样，如`string.h`中包含类`string`。

变量、函数应**在头文件中进行声明**，**在源文件中进行定义**，同时源文件中需包含头文件；**如果函数在概念上属于类但是不定义在类中，则它一般应与类声明(而非定义)在同一个头文件内**<!--P234-->

**预处理器**(编译之前执行的一段程序)能确保头文件多次包含仍能安全工作，预处理变量有两种状态：**已定义和未定义**

`#define`指令把一个名字设定为**预处理变量**，`#ifdef`和`ifndef`来分别处理**预处理变量**在**已定义和未定义**时的相关操作，最终以`#endif`结束。

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H

#include <string>

struct Sales_data {
    double revenue = 0.0;
};

#endif 
```

**头文件保护符**(上面例子中的`SALES_DATA_H`)必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，一般把预处理变量的名字**全部大写**来作为头文件保护符

>   **Tips**：只要是头文件，就应该设置保护符





## 遗留问题

### 1、priority_queue等容器和sort算法中比较函数的用法

#### 1.1、容器中`<>`内是比较函数的类型，`<>`内可以是`decltype(lambda（lambda需要通过过decltype得到lambda的类型，同时容器对象中需要相对应的实参，因为lambda构成的类没有默认构造函数，是不能调用容器的默认构造函数，只能调用(_x)参数的构造函数）, 函数名（和lambda的情况一样，但需要加上*）)或者是函数对象的类名(这个类是有默认构造函数的，类名就是类型，容器对象不需要传实参)`

### 1.2、算法中的比较函数和容器中的不一样，算法中不需要是类型，只要是实参就可以，所以可以直接传入lambda作为实参，在模板部分了解了解

哪些是在编译期进行的，哪些是在运行期进行的，全局变量、static变量、const等都是在什么时候确定的

P589声明问题，友元类的声明，哪些需要，哪些不需要