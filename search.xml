<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Typora的使用及图床的搭建</title>
    <url>/post/44503.html</url>
    <content><![CDATA[<h2 id="Typora简介">Typora简介</h2>
<p><strong>Typora是一款功能全面、简洁高效，而且又非常优雅的Markdown编辑器。它把源码编辑和效果预览合二为一，在输入标记之后随即生成预览效果，提供了<code>所见即所得 </code>的Markdown写作体验。</strong></p>
<p><strong>Typora的主要特征</strong>：</p>
<ul>
<li><strong>实时预览</strong>：传统的Markdown编辑器都有两个窗口，左边是源码，右边是渲染后的效果。Typora独辟蹊径，把源码编辑和效果预览合二为一，实现了真正的所见即所得。</li>
<li><strong>扩展语法</strong>：Typora不光支持<a href="https://dongqing1903.github.io/post/14358.html#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%89%A9%E5%B1%95%E8%AF%AD%E6%B3%95GFM">GFM</a>，还扩展了数学公式、流程图等功能。</li>
<li><strong>界面漂亮</strong>：默认支持6种主题，可自定义，好看又好用。</li>
<li><strong>文件转换</strong>：支持多种文件格式通过导入/导出功能跟.md格式相互转换。</li>
<li><s><strong>支持中文</strong>：支持中文，可以帮助大家更好地理解各项功能。</s></li>
<li><strong>视图模式</strong>：支持大纲和文档列表视图，方便在不同段落和不同文件之间进行切换。</li>
<li><s><strong>跨平台</strong>：支持macOS、Windows和Linux系统。</s></li>
<li><s><strong>目前免费</strong>：这么好用的编辑器竟然是免费的</s></li>
</ul>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li><a href="https://www.typora.io/#download">Typora</a>官方下载地址</li>
<li>本笔记是基于<code>Windows10</code>系统下的<code>0.9.98</code>版本的Typora进行记录的</li>
<li>Markdown的基本语法在Typora上全都满足，可以阅读<a href="https://dongqing1903.github.io/post/14358.html">《Markdown学习笔记》</a>补充Markdown的基础语法知识</li>
</ul>
</blockquote>
<h2 id="快速开始">快速开始</h2>
<h3 id="1、设置语言">1、设置语言</h3>
<p><strong>在默认情况下，Typora会使用操作系统的语言，如果想要自定义语言，可以在Typora编辑器上执行如下操作：菜单栏  →【偏好设置】→【通用】→【语言】，选择语言后，重启Typora即可生效。</strong></p>
<h3 id="2、界面预览">2、界面预览</h3>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029134914405.png" alt="image-20211029134914405"></p>
<h3 id="3、主题">3、主题</h3>
<p><strong>Typora提供了5款漂亮的主题供大家选择，每一个都很漂亮。可通过菜单栏上的【主题】进行已添加主题之间的切换，也可以到<a href="https://theme.typora.io//">官网主题</a>下载其他喜欢的未安装的主题进行安装，本人使用的是<a href="https://theme.typora.io/theme/Vue/">Vue主题</a>，关于主题的添加在后续章节<a href="#1%E3%80%81Typora%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0">添加主题</a>中介绍。</strong></p>
<h3 id="4、源代码模式">4、源代码模式</h3>
<p><strong>Typora编辑器最具特色的功能是实时预览，当输入Markdown标记后，按回车键或把光标定位到别的段落就能够看到预览效果。由于<code>Typora</code>编辑器已经自身集成了《Markdown学习笔记》中推荐的在写作过程中关于空格、空行、换行等使用的场景，但有时需要另辟溪路，就需要打开源码模式，自行修改。</strong></p>
<p><strong>进入源码模式的方法：</strong></p>
<ul>
<li><strong>通过菜单栏操作</strong>：【视图】→ 【源代码模式】，如果菜单栏中的源代码模式选项前有√，表示当前编辑区显示的是源代码模式。</li>
<li><strong>通过快捷键操作</strong>：<code>CTRL + /</code>，在菜单栏中的源代码模式选项后面也有标注相对应的快捷键提示。</li>
<li><strong>通过编辑区左下角的源代码模式开关操作</strong>：点击<code>&lt;/&gt;</code>即可进入和退出源代码模式。</li>
</ul>
<h3 id="5、安装Pandoc">5、安装Pandoc</h3>
<p><strong>Pandoc是一个标记语言转换工具，可实现不同标记语言间的格式转换。Typora默认只支持导出HTML和PDF格式的文件，通过安装Pandoc可以增加Typora编辑器的导入导出格式种类。</strong></p>
<p><strong>Pandoc的安装步骤</strong></p>
<ul>
<li><strong>下载安装包</strong>：根据自己的电脑操作系统下载最新的<a href="https://github.com/jgm/pandoc/releases/latest">Pandoc</a>安装包。</li>
<li><strong>安装过程</strong>：打开下载好的<code>.msi</code>文件，根据提示一步一步的安装即可，安装完成后重启Typora，就可以生效。</li>
</ul>
<h3 id="6、Typora偏好设置">6、Typora偏好设置</h3>
<p><strong>通过菜单栏  →【文件】→【偏好设置】选项进入设置界面，偏好设置界面可以设置自动保存、系统语言、自动检查更新、自定义快捷键、外观设置（窗口样式、字体大小、状态栏、阅读速度、侧边栏、主题）、编辑器设置（默认缩进、成对字符的匹配）、图像设置以及Markdown的基础语法和扩展语法的设置等。</strong></p>
<p><strong>本人的设置如下图所示：</strong></p>
<ul>
<li>
<p><strong>通用设置：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029150125849.png" alt="image-20211029150125849"></p>
</li>
<li>
<p><strong>外观设置：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029150208911.png" alt="image-20211029150208911"></p>
</li>
<li>
<p><strong>编辑器设置：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029150233380.png" alt="image-20211029150233380"></p>
</li>
<li>
<p><strong>图像设置：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029150250508.png" alt="image-20211029150250508"></p>
</li>
<li>
<p><strong>Markdown设置：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029150324176.png" alt="image-20211029150324176"></p>
</li>
</ul>
<h2 id="高效地使用Markdown">高效地使用Markdown</h2>
<p><strong>Typora支持GFM，还扩展了很多其他的功能（如支持数学公式、上标、下标、高亮、各种图表等），它几乎为每一种标记都提供了快捷的操作方式。</strong></p>
<h3 id="1、基础语法和GFM语法">1、基础语法和GFM语法</h3>
<h4 id="1-1、编辑样式">1.1、编辑样式</h4>
<p><strong>在Typora中通过执行：菜单栏  →【格式】→【加粗/斜体/代码（行内代码）/图像/超链接】可以添加或移除关于文字样式 的标记符号。如果没有选中文字，则只会添加标记符号；如果选中了文字，则会为选中的文字添加或移除标记符号。</strong></p>
<p><strong>相关样式的快捷键如下表：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">粗体</td>
<td style="text-align:center">CTRL + B</td>
</tr>
<tr>
<td style="text-align:center">斜体</td>
<td style="text-align:center">CTRL + I</td>
</tr>
<tr>
<td style="text-align:center">图片</td>
<td style="text-align:center">CTRL + SHIFT + I</td>
</tr>
<tr>
<td style="text-align:center">超链接</td>
<td style="text-align:center">CTRL + k</td>
</tr>
<tr>
<td style="text-align:center">删除线</td>
<td style="text-align:center">ALT + SHIFT + 5</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Tips</strong>：如果想使用自动补全表情符号的功能，需要到【偏好设置】中去激活：【文件】→【偏好设置】→【编辑器】→【触发自动完成】→  勾选【Emoji表情】，然后在输入<code>Emoji</code>标记语法时，Typora会自动给出补全信息。</p>
</blockquote>
<h4 id="1-2、编辑段落">1.2、编辑段落</h4>
<p><strong>在Typora中通过执行：菜单栏 →【段落】→【段落/引用/表格/代码块/分隔线/有序列表/无序列表/任务列表】，可以添加或移除关于段落的标记符号。</strong></p>
<h5 id="1-2-1、段落与换行">1.2.1、段落与换行</h5>
<p><strong>在Markdown中，换行符是比较让人困惑的，对此，Typora的官方建议如下：</strong></p>
<ul>
<li>使用Typora的默认设置。</li>
<li>在Typora混合界面（预览界面）写作。</li>
<li>使用Enter键插入新段落，避免多插入空行。</li>
<li>如果要插入强制换行符，请使用HTML标签<code>&lt;br/&gt;</code>。</li>
</ul>
<p><strong>最通用的插入强制换行符的方法有两种：</strong></p>
<ul>
<li>在行尾加两个空格然后按回车键。</li>
<li>使用HTML标签<code>&lt;br/&gt;</code>实现换行，在默认情况下，<code>&lt;br/&gt;</code>不显示，若想显示可以执行：菜单栏  →【编辑】→【空格与换行】→  勾选【显示<code>&lt;br/&gt;</code>】。</li>
</ul>
<p><strong>在Typora中，还提供了一种快速换行的方法，确认勾选保留单换行符：菜单栏  →【编辑】→【空格与换行】→  勾选【保留单换行符】，然后使用快捷键<code>Shift+Enter</code>换行。</strong></p>
<blockquote>
<p><strong>说明</strong>：上述换行符可能在导出/打印时被忽略，请到【偏好设置】→【Markdown】→【空格与换行】→【导出/打印】去设置是否忽略。</p>
</blockquote>
<p><strong>关于Typora中的段落需要知道下面几点内容：</strong></p>
<ul>
<li>如果想要开始新的段落只需按<strong>一次</strong>回车键即可，所见即所得，查看源码你会发现Typora自动帮我们插入了一个空行。</li>
<li>在默认情况下，段落的首行没有缩进，但如果你习惯了首行缩进，可以这样设置：菜单栏  →【编辑】→【空格与换行】→  勾选【首行缩进】。</li>
<li>在表格或图表的前后插入段落不太方便，如果有此需求，可以在表格内单击鼠标右键  →【插入】→  选择【段落（上方）/段落（下方）】。</li>
</ul>
<h5 id="1-2-2、标题">1.2.2、标题</h5>
<p><strong>对标题进行设置的快捷键：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">设置<code>x</code>级标题</td>
<td style="text-align:center">CTRL + <code>x</code></td>
</tr>
<tr>
<td style="text-align:center">提升标题级别</td>
<td style="text-align:center">CTRL + =</td>
</tr>
<tr>
<td style="text-align:center">降低标题级别</td>
<td style="text-align:center">CTRL + -</td>
</tr>
<tr>
<td style="text-align:center">设置为普通文本</td>
<td style="text-align:center">CTRL + 0</td>
</tr>
</tbody>
</table>
<h5 id="1-2-3、列表">1.2.3、列表</h5>
<p><strong>Typora支持有序列表、无序列表和任务列表，它们之间可以通过快捷键实现快速切换，还可以使用列表缩进功能快速调整缩进，使用起来非常方便。</strong></p>
<p><strong>列表操作相关的快捷键：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">添加有序列表</td>
<td style="text-align:center">CTRL + SHIFT + [</td>
</tr>
<tr>
<td style="text-align:center">添加无序列表</td>
<td style="text-align:center">CTRL + SHIFT + ]</td>
</tr>
<tr>
<td style="text-align:center">增加缩进</td>
<td style="text-align:center">CTRL + ]</td>
</tr>
<tr>
<td style="text-align:center">减少缩进</td>
<td style="text-align:center">CTRL + [</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Tips</strong>：列表、代码块都可以使用“增加缩进”和“减少缩进”。</p>
</blockquote>
<h5 id="1-2-4、引用和水平分隔线">1.2.4、引用和水平分隔线</h5>
<p><strong>引用和水平分割线相关的快捷键：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">添加引用</td>
<td style="text-align:center">CTRL + SHIFT + Q</td>
</tr>
</tbody>
</table>
<h5 id="1-2-5、表格">1.2.5、表格</h5>
<ul>
<li>
<p><strong>创建表格：</strong></p>
<p><strong>如果想创建一个表格，可以执行：菜单栏  →【段落】→【表格】→  输入列数和行数  →  单击【确定】按钮。</strong></p>
<p><strong>创建表格的快捷键：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建表格</td>
<td style="text-align:center">CTRL + T</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Tips</strong>：除上面所讲的方法外，还有一种可以快速创建表格的比较酷的方式：<strong>输入表头的标记语法</strong>，在最后一个|之后按回车键。</p>
</blockquote>
</li>
<li>
<p><strong>增加行/删除行、复制表格、格式化表格：</strong></p>
<p><strong>对于表格的增加、删除、复制和格式化操作，可以在表格中单击鼠标右键，选择【表格】，通过其列出的操作选项对表格进行操作，如下图所示：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029154234005.png" alt="image-20211029154234005"></p>
<p><strong>或者点击表格，表格右上方会显示操作菜单，如下图所示：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029160658421.png" alt="image-20211029160658421"></p>
</li>
<li>
<p><strong>快速调整表格：</strong></p>
<p><strong>如果想快速调整表格的行数、列数、对齐方式，可以点击表格，表格左上方和右上方都会显示操作菜单，直接进行操作即可，如下所示：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029160317697.png" alt="image-20211029160317697"></p>
<p><strong>如果想调整表格中行或列的顺序，可将光标放在行的最左边或列的最上边，待光标变成双向箭头后拖动即可调整顺序。</strong></p>
</li>
</ul>
<h5 id="1-2-6、代码">1.2.6、代码</h5>
<ul>
<li>
<p><strong>插入围栏代码块：</strong></p>
<p><strong>如果想添加或删除围栏代码块的标记，可以执行：菜单栏  →【段落】→【代码块】。如果想把某段内容使用围栏代码块包裹，需要先选中该内容，然后执行上述操作。</strong></p>
<p><strong>插入围栏代码块的快捷键：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入围栏代码块</td>
<td style="text-align:center">CTRL + SHIFT + K</td>
</tr>
</tbody>
</table>
<p><strong>如果想声明语言，将光标放在代码块中，在代码块右下角的【选择语言】中输入编程语言即可，如下图所示：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029161432641.png" alt="image-20211029161432641"></p>
</li>
<li>
<p><strong>显示代码行数：</strong></p>
<p><strong>代码块默认是不显示代码行数的，如果想显示，则需要执行：文件  →【偏好设置】→【代码块】→  勾选【显示行号】。</strong></p>
</li>
<li>
<p><strong>自动换行：</strong></p>
<p><strong>代码块中，如果代码过长，默认是会自动换行的，如果我们不希望代码自动换行，可以执行：文件  →【偏好设置】→【代码块】→  不勾选【代码块自动换行】。</strong></p>
</li>
</ul>
<h3 id="2、Typora扩展语法">2、Typora扩展语法</h3>
<p><strong>Typora扩展了<code>下画线、数学公式、目录、脚注、上标和下标、图表操作</code>等功能，并且支持很多HTML标签，使排版格式变得更加齐全。</strong></p>
<h4 id="2-1、编辑样式">2.1、编辑样式</h4>
<h5 id="2-1-1、下划线">2.1.1、下划线</h5>
<p><strong>在Typora中，下画线是通过HTML的<code>&lt;u&gt;</code>标签实现的，其语法为<code>&lt;u&gt;内容&lt;/u&gt;</code>。</strong></p>
<p><strong>下划线快捷键：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">下划线</td>
<td style="text-align:center">CTRL + U</td>
</tr>
</tbody>
</table>
<h5 id="2-1-2、内联数学公式">2.1.2、内联数学公式</h5>
<p><strong>如果想使用内联数学公式，需要先激活：【偏好设置】→【Markdown扩展语法】→  勾选【内联公式】→  重启Typora，内联数学公式的语法为<code>$数学公式$</code>。</strong></p>
<blockquote>
<p><strong>说明：</strong></p>
<ul>
<li>Typora的内敛数学公式使用的是<code>LaTeX</code>排版。</li>
<li><code>LaTeX</code>排版的<a href="http://www.mohu.org/info/lshort-cn.pdf">pdf文档版的说明下载地址</a>。</li>
<li><code>LaTex</code>排版的<a href="http://mohu.org/info/symbols/symbols.htm">公式表示方法</a>。</li>
</ul>
</blockquote>
<h5 id="2-1-3、下标和上标">2.1.3、下标和上标</h5>
<p><strong>如果想使用上标和下标，需要先激活：【偏好设置】→【Markdown扩展语法】→  勾选【下标】、【上标】→  重启Typora，其语法为<code>~下标内容~, ^上标内容^</code>。</strong></p>
<h5 id="2-1-4、高亮">2.1.4、高亮</h5>
<p><strong>如果想使用高亮功能，需要先激活：【偏好设置】→【Markdown扩展语法】→勾选【高亮】→重启Typora，其语法为<code>==高亮内容==</code>。</strong></p>
<h5 id="2-1-5、注释">2.1.5、注释</h5>
<p><strong>如果想添加注释，可以执行：菜单栏  →【格式】→【注释】。在编辑和预览时，注释的内容会被显示；<em>在导出PDF或Word时，则会被隐藏</em>，设置注释的语法为<code>&lt;!-- 注释内容 --&gt;</code>。</strong></p>
<blockquote>
<p><strong>说明</strong>：在以<code>hexo + github + next</code>搭建的博客首页中如果设置文章不是全文显示的话，就可以在想要显示部分的结尾通过<code>&lt;!-- more --&gt;</code>来实现。</p>
</blockquote>
<h5 id="2-1-6、清除样式">2.1.6、清除样式</h5>
<p><strong>如果想快速清除样式，可以执行：菜单栏  →【格式】→【清除样式】。</strong></p>
<p><strong>清除样式的快捷键：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">清除样式</td>
<td style="text-align:center">CTRL + \</td>
</tr>
</tbody>
</table>
<h4 id="2-2、编辑段落">2.2、编辑段落</h4>
<h5 id="2-2-1、数学公式块">2.2.1、数学公式块</h5>
<p><strong>专业的写作离不开数学公式，Typora对此做了很好的支持，其语法是<code>$$ 数学公式 $$</code>。</strong></p>
<p><strong>为某段内容添加或删除公式块，需要先选中该内容，然后执行：菜单栏  →【段落】→【公式块】。如果不选中任何内容，直接执行：菜单栏→【段落】→【公式块】，则会插入公式块标记。</strong></p>
<p><strong>公式块的快捷键:</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">公式块</td>
<td style="text-align:center">CTRL + SHIFT + M</td>
</tr>
</tbody>
</table>
<h5 id="2-2-2、目录">2.2.2、目录</h5>
<p><strong>在Typora中，可以自动获取文章的标题来生成目录，当标题修改时，目录会随之自动更新，使用起来非常方便，其语法<code>[TOC]</code>。</strong></p>
<p><strong>语法说明：</strong></p>
<ul>
<li>TOC是Table of Contents的缩写。</li>
<li>在想插入目录的位置输入[TOC]，按回车键后就可以自动生成文章的目录了。</li>
</ul>
<h5 id="2-2-3、脚注">2.2.3、脚注</h5>
<p><strong>添加脚注的语法：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029170134244.png" alt="image-20211029170134244"></p>
<p><strong>显示效果：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029170248368.png" alt="image-20211029170248368"></p>
<h5 id="2-2-4、图表">2.2.4、图表</h5>
<p><strong>如果想使用图表功能，需要先激活：文件  →【偏好设置】→【Markdown扩展语法】→  勾选【图表】→  重启Typora。</strong></p>
<p><strong>需要注意如下几点：</strong></p>
<ul>
<li>图表是Typora的扩展语法，标准的Markdown语法、CommonMark和GFM都不支持这一语法。</li>
<li>如果想要把图表使用到更多的地方，推荐直接插入图片，不推荐在Typora中进行绘制。</li>
<li>在Typora中，图表在导出HTML/PDF/ePub/docx等格式的文件时会被正常显示，但是其他的Markdown编辑器不一定支持此语法。</li>
</ul>
<blockquote>
<p><strong>说明</strong>：图表部分对于本来来说用的比较少，在此处就不记录了，如果需要可自行查阅《了不起Markdown》这本书的第<code>3.2.2</code>节的图表相关的内容，在实际使用中，可以通过第三方软件将相关的图表编辑好，然后以图片的方式插入到Markdown中，这种做法更方便、可靠。</p>
</blockquote>
<h2 id="实用的功能">实用的功能</h2>
<h3 id="1、文件操作">1、文件操作</h3>
<h4 id="1-1、复原历史版本">1.1、复原历史版本</h4>
<p><strong>虽然Windows下的Typora不支持版本控制功能，但是可以恢复自动保存到草稿中的内容。</strong></p>
<p><strong>恢复的步骤：【文件】→【偏好设置】→【保存&amp;恢复】→单击【恢复未保存的草稿】→  找到以日期和文件名（或文件的第一个标题/句子）命名的草稿进行恢复。</strong></p>
<h4 id="1-2、自动保存">1.2、自动保存</h4>
<p><strong>在Windows系统下，通过【文件】→【偏好设置】→【保存&amp;恢复】→  勾选【自动保存】。</strong></p>
<h4 id="1-3、导入-导出">1.3、导入/导出</h4>
<p><strong>如果想把其他格式的文件转成Markdown文件，可以使用Typora的导入功能。</strong></p>
<p><strong>如果想把Markdown格式的文件转换成其他格式的文件，则可以使用导出功能。</strong></p>
<p><strong>具体步骤是，首先安装Pandoc，然后执行：菜单栏  →【文件】→【导入】/【导出】。</strong></p>
<h3 id="2、编辑操作">2、编辑操作</h3>
<h4 id="2-1、复制与粘贴">2.1、复制与粘贴</h4>
<p><strong>在默认情况下，在Typora中复制文本时，复制的是渲染后的格式。</strong></p>
<p><strong>如果想复制Markdown源码，可以执行：菜单栏  →【编辑】→【复制为Markdown】，或者选择要复制内容，单击鼠标右键，在弹出的菜单中选择【复制为Markdown】。</strong></p>
<p><strong>如果我们想把“复制Markdown源码”设置为默认的复制行为，可以执行：文件  →【偏好设置】→【默认复制行为】→  勾选【当复制纯文件时复制Markdown源码】。</strong></p>
<p><strong>如果想直接复制HTML源码，可以执行：菜单栏  →【编辑】→【复制为HTML代码】；如果想在粘贴时去掉所有格式，可以执行：菜单栏  →【编辑】→【粘贴为纯文本】。</strong></p>
<h4 id="2-2、查找和替换">2.2、查找和替换</h4>
<p><strong>过快捷键<code>CTRL + F</code>调出查找面板，在查找面板上可以设置是否<code>区分大小写</code>和是否<code>查找整个单词</code>，默认都是否，如下图所示：</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029172529332.png" alt="image-20211029172529332"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029181012177.png" alt="image-20211029181012177"></p>
<p><strong>可以在查找面板上切换上一个和下一个查找结果，也可以按回车键切换下一个。</strong></p>
<h4 id="2-3、跳转">2.3、跳转</h4>
<p><strong>在Typora中，除通过侧边栏的大纲列表进行跳转外，还可以通过快捷键快速跳转到页首、页尾和选中的文本区域。</strong></p>
<p><strong>跳转的快捷键：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">操作</th>
<th style="text-align:center">Windows系统</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">跑转到文首</td>
<td style="text-align:center">CTRL + HOME</td>
</tr>
<tr>
<td style="text-align:center">跑转到文末</td>
<td style="text-align:center">CTRL + END</td>
</tr>
<tr>
<td style="text-align:center">跳转到所选内容</td>
<td style="text-align:center">CTRL + J</td>
</tr>
</tbody>
</table>
<h4 id="2-4、图片操作">2.4、图片操作</h4>
<p><strong>在Typora中，可以快速插入本地图片、复制插入的图片到指定文件夹、上传图片到图床、图片居中、调整图片大小等功能。</strong></p>
<p><strong>关于图片居中：当一个段落中只包含一张图片时，图片会居中对齐，否则会左对齐。</strong></p>
<h5 id="2-4-1、插入本地图片">2.4.1、插入本地图片</h5>
<ul>
<li>
<p><strong>使用插入图片语法：</strong><code>![]()</code>。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029181909909.png" alt="image-20211029181909909"></p>
</li>
<li>
<p><strong>菜单栏  →【编格式】→【图像】→【插入本地图片】</strong></p>
</li>
<li>
<p><strong>直接拖动本地图片到编辑器中。</strong></p>
</li>
<li>
<p><strong>直接从剪切板中复制并粘贴到编辑器。</strong></p>
</li>
</ul>
<h5 id="2-4-2、管理本地图片">2.4.2、管理本地图片</h5>
<ul>
<li>
<p><strong>复制图片到指定的文件夹：</strong></p>
<p><strong>在默认情况下，插入的本地图片链接是<code>原地址</code>，图片可能分散在电脑的各处，不便于管理。为了便于管理，我们可以将插入的本地图片自动复制到指定的文件夹中。</strong></p>
<p><strong>其操作步骤：菜单栏  →【格式】→【图像】→【当插入本地图片时】→【复制到文件夹…】，然后选择或新建一个文件夹用于存放插入的本地图片。</strong></p>
<p><strong>设置完成后，当我们再次插入本地图片时，图片就会被自动复制到之前选择的文件夹中了。</strong></p>
</li>
<li>
<p><strong>使用iPic上传到网络：</strong></p>
<p><strong>iPic是一个图床工具，可自动将本地图片上传到指定图床（支持微博、七牛云、又拍云、阿里云、腾讯云等图床），然后自动保存为Markdown格式的链接，非常方便。</strong></p>
<p><strong>免费版的iPic支持将图片匿名上传至微博图床，但这不利于隐私保护，不建议使用。本人使用的是<code>阿里云</code>图床。</strong></p>
<p><strong>假设你已经安装了iPic，若想把本地图片自动上传到图床，需要先在Typora中进行设置：【偏好设置】→【图片插入】→  勾选【允许根据YAML设置自动上传图片】。然后在插入的本地图片上，单击鼠标右键，选择【上传图片】就可以通过iPic上传到指定的图床了。</strong></p>
</li>
</ul>
<blockquote>
<p><strong>说明</strong>：<a href="#2%E3%80%81%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8OSS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D">基于阿里云的对象存储OSS实现的图床方法</a>在后面章节介绍。</p>
</blockquote>
<h5 id="2-4-3、全局设置">2.4.3、全局设置</h5>
<p><strong>在默认情况下，插入图片时并没有什么特殊操作，但是我们可以在全局状态下，设置一些特殊的操作功能。具体是在【偏好设置】→【图片插入】中进行设置的，此处可选的操作如下：</strong></p>
<ul>
<li>无特殊操作。</li>
<li>复制图片到当前文件夹（./）。</li>
<li>复制图片到./assets 文件夹。</li>
<li>复制图片到./${filename}.assets 文件夹。</li>
<li>复制到指定路径。</li>
</ul>
<h5 id="2-4-4、设置图片大小">2.4.4、设置图片大小</h5>
<p><strong>在Typora中，支持使用<code>&lt;img&gt;</code>标签插入图片，也支持其对图片大小进行设置（理论上也支持其他属性的设置，但Typora在预览和编辑时可能会忽略图片大小之外的属性，这可能会影响导出效果）。</strong></p>
<p><strong>使用<code>&lt;img&gt;</code>标签的格式：</strong><code>&lt;img src="./imgs/小兔子.jpg" width="200px" height="200px" style="zoom:50%"/&gt;</code></p>
<h3 id="3、显示样式">3、显示样式</h3>
<h4 id="3-1、3种视图模式">3.1、3种视图模式</h4>
<p><strong>Typora支持3种视图模式：大纲视图、文件树视图和文档列表视图，这让我们能够方便地在不同段落和文件之间进行切换。</strong></p>
<ul>
<li><strong>大纲视图</strong>：方便查看全文的结构。</li>
<li><strong>文件树视图</strong>：方便切换当前目录及子目录中的文档。</li>
<li><strong>文档列表视图</strong>：方便切换当前目录中的文档。</li>
</ul>
<h4 id="3-2、沉浸式写作体验">3.2、沉浸式写作体验</h4>
<p><strong>如果想拥有沉浸式写作体验，可以执行：菜单栏  →【视图】，并依次勾选下面的选项：</strong></p>
<ul>
<li><strong>打字机模式</strong>：光标始终位于屏幕的中间。</li>
<li><strong>专注模式</strong>：只高亮显示光标所在行，其余内容全部变灰。</li>
<li><strong>全屏</strong>：最大化文件窗口，排除其他软件的干扰。</li>
</ul>
<h2 id="补充内容">补充内容</h2>
<h3 id="1、Typora主题添加">1、Typora主题添加</h3>
<p><strong>本笔记以添加<code>Vue</code>主题为例，讲解添加步骤</strong>：</p>
<ol>
<li>
<p>进入Typora官网下载<a href="https://theme.typora.io/theme/Vue/">Vue主题</a>，或者通过Typora的偏好设置选项中的<code>外观 -&gt; 主题 -&gt; 获取主题</code>进入Typora官网主题网站。</p>
</li>
<li>
<p>进入Typora的偏好设置打开主题文件夹：菜单栏  →【文件】→【偏好设置】→【外观】→【主题】→【打开主题文件夹】。</p>
</li>
<li>
<p>将下载好的<code>Vue主题</code>压缩包进行解压，将文件夹中的所有内容复制到<code>主题文件夹中</code>，重启Typora。</p>
</li>
<li>
<p>切换主题：菜单栏  →【主题】→【Vue】，到此就切换成<code>Vue</code>主题了。</p>
</li>
</ol>
<h3 id="2、基于阿里云的对象存储OSS搭建图床的方法介绍">2、基于阿里云的对象存储OSS搭建图床的方法介绍</h3>
<p><strong>虽然阿里云OSS不是免费的，但是一年只需要<code>RMB9.0</code>，还不到一杯奶茶的钱，就可以享受到稳定、可靠的图床了，免费的东西总得来说还是不可靠的，天下没有免费的午餐。</strong></p>
<p><strong>下面就把我从0开始搭建阿里云图床的过程一一介绍</strong>：</p>
<ol>
<li>
<p>确保Typora的版本在<code>0.9.86</code>以上，如果不知道的话，可以通过<code>菜单栏 →【帮助】→【关于】</code>进行查看自己的Typora版本，如果版本过低，可以通过<code>菜单栏 →【帮助】→【检查更新】</code>进行升级</p>
</li>
<li>
<p>通过<code>菜单栏 →【文件】→【偏好设置】→【图像】</code>进行下图的设置：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029192321925.png" alt="image-20211029192321925"></p>
</li>
<li>
<p>点击下载或更新（<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>使用外网下载速度会很快<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029192504357.png" alt="image-20211029192504357"></p>
</li>
<li>
<p>注册<a href="https://account.aliyun.com/register/qr_register.htm?spm=5176.13735996.J_8058803260.6.361c3c60Hw8kka&amp;oauth_callback=https%3A%2F%2Fwww.aliyun.com%2Fminisite%2Fgoods%3Fsource%3D5176.11533457%26userCode%3Dvnk7s0ek%26type%3Dcopy">阿里云账号</a>并绑定实名身份</p>
</li>
<li>
<p>登陆阿里云，点击控制台</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029193616838.png" alt="image-20211029193616838"></p>
</li>
<li>
<p>选择对象存贮OSS，并开通服务</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029194022838.png" alt="image-20211029194022838"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029194127281.png" alt="image-20211029194127281"></p>
</li>
<li>
<p>点击概览，然后点击创建bucket</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029194424770.png" alt="image-20211029194424770"></p>
</li>
<li>
<p>输入创建信息</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20211029201049.jpg" alt="微信图片_20211029201049"></p>
</li>
<li>
<p>根据自己的需求购买相应的资源包</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029201533237.png" alt="image-20211029201533237"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029201631995.png" alt="image-20211029201631995"></p>
</li>
<li>
<p>桌面上新建一个<code>txt</code>文本，并复制下面内容到里面</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">  "picBed": {</span><br><span class="line">    "uploader": "aliyun",</span><br><span class="line">    "aliyun": {</span><br><span class="line">    "accessKeyId": "",</span><br><span class="line">    "accessKeySecret": "",</span><br><span class="line">    "bucket": "", // 存储空间名</span><br><span class="line">    "area": "", // 存储区域代号</span><br><span class="line">    "path": "img/", // 自定义存储路径</span><br><span class="line">     "customUrl": "", // 自定义域名，注意要加 http://或者 https://</span><br><span class="line">     "options": "" // 针对图片的一些后缀处理参数 PicGo 2.2.0+ PicGo-Core 1.4.0+</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  "picgoPlugins": {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>找<strong>accessKeyId</strong>和<strong>accessKeySecret</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029202123686.png" alt="image-20211029202123686"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029203644871.png" alt="image-20211029203644871"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029203742905.png" alt="image-20211029203742905"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029202905978.png" alt="image-20211029202905978"></p>
</li>
<li>
<p>回到之前的oss对象存贮，点击之前创建的bucket，在点击概览，根据下面的图，使用自己的创建的bucket信息填充之前新建的txt</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029205648339.png" alt="image-20211029205648339"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029211409434.png" alt="image-20211029211409434"></p>
</li>
<li>
<p>将<code>步骤10</code>中的信息替换成自己的OSS信息，主要对<code>accessKeyId、accessKeySecret、bucket、area</code>，这里提供我的配置信息以供参考</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029212351764.png" alt="image-20211029212351764"></p>
</li>
<li>
<p>回到typora，通过<code>菜单栏 →【文件】→【偏好设置】→【图像】</code>打开配置文件，将<code>步骤10</code>新建的txt文件修改成自己的OSS信息的新内容替换掉配置文件中的内容，并保存重启Typora</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029212618038.png" alt="image-20211029212618038"></p>
</li>
<li>
<p>验证图片上传功能</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029213349636.png" alt="image-20211029213349636"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029213530899.png" alt="image-20211029213530899"></p>
</li>
<li>
<p>在编辑区添加图片，就会自动上传图片，以后写好的Markdown文档分享给别人是就不需要一起打包相应的插入图片了，直接分享Markdown源文件即可</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211029213207201.png" alt="image-20211029213207201"></p>
</li>
<li>
<p>至此，基于阿里云的对象存储OSS的图床搭建就完成了，尽情享用吧<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
        <category>专业工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习笔记</title>
    <url>/post/14358.html</url>
    <content><![CDATA[<h2 id="Markdown简介">Markdown简介</h2>
<p>Markdown是一种轻量级标记语言，允许人们使用易读易写的纯文本格式编写文档。Markdown编写的文档可以导出HTML、Word、Img、PDF等多种格式的文档，Markdown编写的文档后缀为<code>.md</code>。推荐使用<a href="https://dongqing1903.github.io/post/44503.html">Typora</a>(链接中有关于<code>Typora</code>的下载以及添加图床、使用方法等说明)作为Markdown的编辑器。推荐对应的书<a href="https://pan.baidu.com/s/1BU2Q0hqfPKoBLK-A1j7jiQ">《了不起的Markdown》</a>(提取码：1234)。</p>
<blockquote>
<p><strong>说明</strong>：本学习笔记只记录Markdown推荐使用的语法，不对所有语法进行呈列。</p>
</blockquote>
<h2 id="第一章Markdown基础语法">第一章	Markdown基础语法</h2>
<h3 id="1、字体">1、字体</h3>
<h4 id="1-1、标题">1.1、标题</h4>
<ul>
<li><strong>使用#的语法</strong>：# + 空格 + 标题内容</li>
<li><strong>语法说明</strong>：
<ul>
<li>#的个数代表标题的级别。</li>
<li>建议在#后加一个空格。</li>
<li>Markdown最多支持前六级标题。</li>
</ul>
</li>
<li><strong>语法实例演示</strong>：
<ul>
<li># ：一级标题</li>
<li>## ：二级标题</li>
<li>### ：三级标题</li>
<li>……</li>
<li>######：六级标题</li>
</ul>
</li>
<li><strong>使用规范</strong>：
<ul>
<li>要保持间距，建议标题的前后都要空1行（除非标题在文档开头）；<code>#</code>与标题文本之间也要有1个空格，否则会导致阅读困难。</li>
<li>不要有多余的空格。建议标题要写在一行的开头，结尾也不要有空格。</li>
<li>建议标题的结尾不要有标点符号，如句号、逗号、冒号、分号等。</li>
<li>建议标题要尽量简短，这样方便引用，特别是当生成目录时。如果原拟的标题是一个长句，可以从长句中提取标题，而将长句作为标题下的内容。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li><code>Typora</code>编辑器中已经默认设置标题时，标题前后都会空一行，无需再留空行。</li>
<li><code>Typora</code>编辑器中可以使用快捷键<code>CTRL + 数字键</code>实现六级标题。</li>
</ul>
</blockquote>
<h4 id="1-2、粗体和斜体">1.2、粗体和斜体</h4>
<ul>
<li><strong>粗体</strong>：由两对*包裹</li>
<li><strong>斜体</strong>：由一对*包裹</li>
<li><strong>实例演示</strong>：我是<code>**粗体**</code>，我是<code>*斜体*</code>。</li>
<li><strong>使用规范</strong>：在粗体和斜体语法标记的内部，建议不要有空格。</li>
</ul>
<blockquote>
<p><strong>说明</strong>：<code>Typora</code>编辑器中可以使用快捷键<code>CTRL + b</code>和<code>CTRL + i</code>来实现粗体和斜体的样式。</p>
</blockquote>
<h3 id="2、段落与换行">2、段落与换行</h3>
<p><strong>Markdown中的段落由一行或多行文本组成，不同的段落之间使用空行来标记。</strong></p>
<ul>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>如果行与行之间没有空格，则会被视为同一段落。</li>
<li>如果行与行之间有空行，则会被视为不同的段落。</li>
<li>空行是指行内什么都没有，或者只有空格和制表符。</li>
<li>如果想在段内换行，则需要在上一行的结尾插入<em>两个以上的空格</em>然后按回车键。</li>
</ul>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027091719148.png" alt="image-20211027091719148" style="zoom:67%;">
</li>
<li>
<p><strong>使用规范</strong>：</p>
<ul>
<li>当超过80个字符后进行换行。</li>
<li>在一句话结束（。或！或？）之后换行。</li>
<li>当URL较长时换行，通过在URL要换行的位置加一个换行符。</li>
</ul>
<blockquote>
<p><strong>说明</strong>：<a href="#6%E3%80%81%E9%93%BE%E6%8E%A5">链接的使用</a>在本章节第6小节介绍。</p>
</blockquote>
</li>
</ul>
<h3 id="3、列表">3、列表</h3>
<p><strong>在Markdown中支持使用有序列表和无序列表，有序列表用数字序号+英文句号+空格+列表内容来标记，无序列表由*/+/- + 空格+列表内容标记。</strong></p>
<h4 id="3-1、有序列表：">3.1、有序列表：</h4>
<ul>
<li>
<p><strong>使用语法</strong>：数字序号 + 英文句号 + 空格 + 列表内容</p>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027094817464.png" alt="image-20211027094817464" style="zoom: 67%;">
</li>
</ul>
<h4 id="3-2、无序列表：">3.2、无序列表：</h4>
<ul>
<li>
<p><strong>使用语法</strong>：*、+、-  + 空格 + 列表内容</p>
</li>
<li>
<p><strong>语法说明</strong>：*、+、- 的作用是一致的。</p>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027095914769.png" alt="image-20211027095914769" style="zoom:67%;">  
</li>
</ul>
<h4 id="3-3、嵌套列表：">3.3、嵌套列表：</h4>
<ul>
<li>
<p><strong>使用语法</strong>：</p>
<ul>
<li>+  第一层列表</li>
<li>TAB  +  第二层列表</li>
<li>TAB  +  TAB  +  第三层列表</li>
</ul>
</li>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>列表中可以嵌套列表。</li>
<li>有序列表和无序列表也可以相互嵌套。</li>
</ul>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027100700893.png" alt="image-20211027100700893" style="zoom:67%;">
</li>
<li>
<p><strong>使用规范</strong>：</p>
<ul>
<li>建议使用<code>-</code>来标记无序列表，因为<code>* </code>容易跟粗体和斜体混淆，而<code>+</code>不流行。</li>
<li>如果一个列表中所有的列表项都没有换行，建议使用1个空格。</li>
<li>如果列表项有换行，则建议给无序列表使用3个空格（根据自己设置<code>TAB</code>的缩进的位数来决定），给有序列表使用2个空格。</li>
<li>如果一个列表中的每个列表项都只有1行，建议列表项之间不要有空行。</li>
<li>如果列表项中有换行，建议在列表项之间空1行，这样会比较容易区分多行列表项的开始和结束。</li>
<li>建议在列表前/后都空1行。</li>
<li><s>数字、字符、符号列表使用英文半角句号，句号后加空格。</s></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li><code>Typora</code>编辑器中可以使用快捷键<code>CTRL + }</code> 和 <code>CTRL + {</code>实现无序列表和有序列表的样式。</li>
<li><code>Typora</code>编辑器对于列表项中有换行时，列表项之间添加空格的问题，<code>Typora</code>编辑器已经默认处理过了，同时关于有无换行时，有序列表和无序列表时空格的多少也无需考虑，<code>Typora</code>编辑器已经默认处理过了。</li>
</ul>
</blockquote>
<h3 id="4、分割线">4、分割线</h3>
<ul>
<li>
<p><strong>使用语法</strong>：分隔线由3个以上的* 、-、_来标记。</p>
</li>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>分隔线须使用至少3个以上的* 、-、_来标记。</li>
<li>行内不能有其他的字符。</li>
<li>可以在标记符中间加上空格。</li>
</ul>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027105031998.png" alt="image-20211027105031998"></p>
</li>
</ul>
<h3 id="5、图片">5、图片</h3>
<ul>
<li>
<p><strong>插入图片的语法</strong>：![图片替代文字](图片地址)</p>
</li>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>图片替代文字在图片无法正常显示时会比较有用，正常情况下可以为空。</li>
<li>图片地址可以是本地图片的路径也可以是网络图片的地址。</li>
<li>本地图片支持相对路径和绝对路径两种方式。</li>
</ul>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027105556796.png" alt="image-20211027105556796" style="zoom:67%;">
</li>
</ul>
<h3 id="6、链接">6、链接</h3>
<h4 id="6-1、文字链接">6.1、文字链接</h4>
<p><strong>文字链接就是把链接地址直接写在文本中。</strong></p>
<ul>
<li>
<p><strong>使用语法</strong>：[链接文字](链接地址)</p>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027152641385.png" alt="image-20211027152641385"></p>
</li>
</ul>
<h4 id="6-2、引用链接">6.2、引用链接</h4>
<p><strong>引用链接是把链接地址作为<code>变量</code>先在Markdown文件的页尾定义好，然后在正文中引用</strong></p>
<ul>
<li>
<p><strong>使用语法</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027153217156.png" alt="image-20211027153217156" style="zoom:67%;">
</li>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>链接标记可以有字母、数字、空格和标点符号。</li>
<li>链接标记不区分大小写。</li>
<li>定义的链接内容可以放在当前文件的任意位置，建议放在页尾。</li>
<li>当链接地址为网络地址时要以 http/https开头，否则会被识别为本地地址。</li>
</ul>
</li>
</ul>
<h4 id="6-3、网址链接">6.3、网址链接</h4>
<p><strong>在Markdown中，将网络地址或邮箱地址使用&lt;&gt;包裹起来会被自动转换为超链接。</strong></p>
<ul>
<li>
<p><strong>使用语法</strong>：&lt;URL 或 邮箱地址&gt;</p>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027154037298.png" alt="image-20211027154037298" style="zoom:67%;">
</li>
</ul>
<h4 id="6-4、使用规范">6.4、使用规范</h4>
<ul>
<li>
<p>在Markdown中，链接标题的信息应该更丰富，从标题中应该可以知道链接的内容，要使用有意义的链接标题。</p>
</li>
<li>
<p>建议使用&lt;&gt;包裹自动链接，这种方式更通用。</p>
</li>
<li>
<p>自动链接要以http/https开头。</p>
</li>
</ul>
<h3 id="7、行内代码与代码块">7、行内代码与代码块</h3>
<h4 id="7-1、行内代码">7.1、行内代码</h4>
<ul>
<li>
<p><strong>使用语法</strong>：使用两个`包裹代码</p>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027155931029.png" alt="image-20211027155931029" style="zoom:80%;">
</li>
</ul>
<h4 id="7-2、代码块">7.2、代码块</h4>
<p><strong>因为代码块使用Tab键或4个空格开头的效果不够直观，很多扩展语法（如GFM）提供了<code>围栏代码块</code>，并且支持语法高亮。</strong></p>
<ul>
<li>
<p><strong>使用语法</strong>：```语种</p>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027171837966.png" alt="image-20211027171837966" style="zoom: 67%;">
</li>
</ul>
<h4 id="7-3、使用规范">7.3、使用规范</h4>
<ul>
<li><code>除行内代码可以使用`包裹以外，如果我们想转义或强调某些字符，也可以使用`包裹</code>。</li>
<li>如果代码超过1行，请使用围栏代码块（扩展语法），并显式地声明语言，这样做便于阅读，并且可以显示语法高亮。</li>
<li>很多Shell命令都要粘贴到终端中去执行，因此最好避免在Shell命令中使用任何<code>换行</code>操作；可以在行尾使用一个\，这样既能避免命令换行，又能提高源码的可读性。</li>
<li>建议不要在没有输出内容的Shell命令前加$。在命令没有输出内容的情况下，​$是没有必要的，因为内容全是命令，我们不会把命令和输出的内容混淆。</li>
</ul>
<h3 id="8、引用">8、引用</h3>
<ul>
<li>
<p><strong>使用语法</strong>：&gt; 引用内容</p>
</li>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>多行引用也可以在每一行的开头都插入&gt;。</li>
<li>在引用中可以嵌套引用。</li>
<li>在引用中可以使用其他的Markdown语法。</li>
<li>段落与换行的格式在引用中也是适用的。</li>
</ul>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027162721865.png" alt="image-20211027162721865"></p>
</li>
<li>
<p><strong>使用规范</strong>：</p>
<ul>
<li>建议在引用的标记符号＞之后添加一个空格。</li>
<li>建议每一行引用都使用符号＞。</li>
<li>不要在引用中添加空行。</li>
</ul>
</li>
</ul>
<h3 id="9、转义">9、转义</h3>
<p><strong>当我们想在Markdown文件中插入一些标记符号，但又不想让这些符号被渲染时，可以使用<code>\</code>进行转义。</strong></p>
<ul>
<li><strong>使用语法</strong>：\特殊符号</li>
<li><strong>支持转义的特殊字符</strong>：\，`，*，_，{}，[]，()，#，+，-，.，!</li>
</ul>
<blockquote>
<p><strong>说明</strong>：如果想显示一对`(反引号)，用转义字符无法实现，需要在两端分别添加一对反引号。</p>
</blockquote>
<h2 id="第二章扩展语法GFM">第二章	扩展语法GFM</h2>
<p><strong>在众多Markdown扩展语法中，GitHub Flavored Markdown（简称GFM）无疑是目前最流行的，它提供了包括表格、任务列表、删除线、围栏代码、Emoji等在内的标记语法。</strong></p>
<h3 id="1、删除线">1、删除线</h3>
<ul>
<li>
<p><strong>使用语法</strong>：~~被删除的文字~~</p>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027164611866.png" alt="image-20211027164611866" style="zoom:80%;">
</li>
</ul>
<h3 id="2、表情符号">2、表情符号</h3>
<ul>
<li>
<p><strong>使用语法</strong>：:表情代码:</p>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027164753120.png" alt="image-20211027164753120"></p>
</li>
</ul>
<blockquote>
<p><strong>说明</strong>：更多的表情代码可以参考<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">🎁表情符号备忘单 Github</a></p>
</blockquote>
<h3 id="3、自动连接">3、自动连接</h3>
<p><strong>在标准语法中，由&lt;&gt;包裹的URL地址被自动识别并解析为超链接，使用GFM扩展语法则可以不使用&lt;&gt;包裹。</strong></p>
<ul>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027165241510.png" alt="image-20211027165241510" style="zoom:80%;">
</li>
</ul>
<h3 id="4、表格">4、表格</h3>
<ul>
<li>
<p><strong>使用语法</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027165353260.png" alt="image-20211027165353260"></p>
</li>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>单元格使用|来分隔，为了阅读更清晰，建议最前和最后都使用|。</li>
<li>单元格和|之间的空格会被移除。</li>
<li>表头与其他行使用-来</li>
<li>表格对齐格式如下：
<ul>
<li>左对齐（默认）：:</li>
<li>右对齐：-:</li>
<li>居中对齐：:-:</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027165852710.png" alt="image-20211027165852710"></p>
</li>
<li>
<p><strong>使用规范</strong>：</p>
<ul>
<li>在表格的前、后各空1行。</li>
<li>在每一行最前和最后都使用|，每一行中的|要尽量都对齐。</li>
<li>不要使用庞大复杂的表格，那样会难以维护和阅读。</li>
</ul>
</li>
</ul>
<h3 id="5、任务列表">5、任务列表</h3>
<ul>
<li>
<p><strong>使用语法</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027170149173.png" alt="image-20211027170149173"></p>
</li>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>任务列表以-+空格开头，由 [+空格/x+] 组成。</li>
<li>x可以小写，也可以大写，有些编辑器可能不支持大写，所以为避免解析错误，推荐使用小写的x。</li>
<li>当方括号中的字符为空格时，复选框是未选中状态，为x时是选中状态。</li>
</ul>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027170430536.png" alt="image-20211027170430536" style="zoom:67%;">
</li>
</ul>
<blockquote>
<p><strong>说明</strong>：<code>Typora</code>编辑器中使用任务列表的语法<code>-(空格)[(空格)](空格)内容</code></p>
</blockquote>
<h3 id="6、书签（锚点）">6、书签（锚点）</h3>
<ul>
<li>
<p><strong>使用语法</strong>：[锚点描述](#锚点名)</p>
</li>
<li>
<p><strong>语法说明</strong>：</p>
<ul>
<li>锚点名建议使用字母和数字，当然中文也是被支持的，但不排除有些网站支持得不够好。</li>
<li>锚点名是区分英文大小写的。</li>
<li>在锚点名中不能含有空格，也不能含有特殊字符。</li>
</ul>
</li>
<li>
<p><strong>实例演示</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027172705517.png" alt="image-20211027172705517"></p>
</li>
</ul>
<h2 id="第三章排版技巧">第三章	排版技巧</h2>
<h3 id="1、推荐的排版样式">1、推荐的排版样式</h3>
<h4 id="1-1、关于空格">1.1、关于空格</h4>
<p><strong>建议中文和英文之间加空格，中文/英文和数字之间也要加空格，不过有些编辑器和输入法（如百度输入法）会自动添加空隙，我们就没必要手动添加了，大家在使用时请多注意。</strong></p>
<ul>
<li>
<p><strong>需要加空格的情况:</strong></p>
<ol>
<li>
<p>英文标点符号（如，.；：？）与后面的字符之间需要加空格，与前面的字符之间不需要加空格。</p>
</li>
<li>
<p>当在中文、英文中使用＞（半角）标识路径时，两边都需要加空格。</p>
<ul>
<li>
<p><strong>实例演示</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211027173855105.png" alt="image-20211027173855105"></p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>不加空格的情况</strong>：</p>
<ol>
<li>中文标点符号和数字、中文、英文之间不需要添加空格。</li>
<li>数字和百分号之间不需要添加空格。</li>
<li>数字和单位符号之间不需要添加空格。</li>
<li>英文和数字组合成的名字之间不需要添加空格。</li>
<li>当/（半角）表示“或”、“路径”时，与前后的字符之间均不加空格</li>
<li>负号后不加空格。</li>
</ol>
</li>
</ul>
<h4 id="1-2、半角和全角">1.2、半角和全角</h4>
<p><strong>全角：中文标点符号是全角，占两个字节。</strong></p>
<p><strong>半角：英文标点符号和数字是半角，占1个字节。</strong></p>
<p><strong>全角：，。；：!#</strong></p>
<p><strong>半角：,.;:!#</strong></p>
<ul>
<li><strong>在中文排版中，要使用全角标点符号。</strong></li>
<li><strong>在英文排版中，要使用半角标点符号。</strong></li>
</ul>
<h4 id="1-3、正确的英文大小写">1.3、正确的英文大小写</h4>
<p><strong>专有名词要使用正确的大小写，请参考它们的官方文档。</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>专业笔记</category>
        <category>工具技能</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>小强升职记</title>
    <url>/post/33163.html</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p><strong>成功的关键在于<code>构建自己的核心系统</code></strong></p>
<p><strong>构建时间管理的核心系统，本书主要从以下7点进行讲解</strong>：</p>
<ol>
<li><strong>种子</strong>：找到时间黑洞，找到职业价值观</li>
<li><strong>树苗</strong>：学习四象限法则、衣柜整理法</li>
<li><strong>树叶</strong>：如何战胜拖延，如何要优先，如何处理临时突发事件</li>
<li><strong>开花</strong>：如何养成一个好习惯</li>
<li><strong>结果</strong>：如何让想法落地</li>
<li><strong>收获</strong>：如何建立高效办公区，逐步走向高效率、慢生活</li>
</ol>
<p><strong>做事靠系统，不是靠感觉。</strong></p>
<p><strong>同理：做事要有方法论，不能靠着感觉随心发展，遇到没接触的领域先借鉴借鉴别人的经验来入手任务，然后慢慢形成自己的方法论</strong>。</p>
<h2 id="第一章你的时间去哪儿了？">第一章	你的时间去哪儿了？</h2>
<h3 id="1、你真的很忙吗？">1、你真的很忙吗？</h3>
<p><strong>在时间管理方面，人被分为两类</strong>：</p>
<ul>
<li><strong>确实很忙的人</strong>：<code>确实很忙</code>的人要分两种，这两种人忙碌的内容和结果都截然不同：
<ul>
<li><strong>会自我管理</strong>的人：用20%的时间完成相同的任务，因此这种人忙于打发闲暇的时间</li>
<li><strong>不会自我管理</strong>的人：用80%的时间完成相同的任务，因此这种人忙于<strong>煮泡面和熬夜</strong></li>
</ul>
</li>
<li><strong>假装很忙的人</strong>：假装忙碌，家长让孩子不停的学习，而学生已经厌倦了持续的学习，这时的学习就是行尸走肉，假装的忙。</li>
</ul>
<h4 id="1-1、时间浪费的统计">1.1、时间浪费的统计</h4>
<p><strong>统计方法</strong>：</p>
<ol>
<li>先在一张写下自己认为分别花费在<code>集中经历工作</code>，<code>无意义浪费时间</code>，<code>真正的休息</code>上的比例</li>
<li>在纸上写下自己对<code>集中经历工作</code>，<code>无意义浪费时间</code>，<code>真正的休息</code>的描述
<ul>
<li>集中精力工作：心无杂念；进入忘我状态；效率很高</li>
<li>无意义浪费时间：打开浏览器漫无目的地乱逛；各种纠结；聊天；无法集中注意力；烦躁不安</li>
<li>真正的休息：打个小盹；散散步</li>
</ul>
</li>
<li>连续5个工作日，每隔小个小时记录下自己究竟处于哪个状态，从早上8.30左右进入实验室，到晚上11.50结束学习任务离开实验室为止</li>
<li>在第六天统计一下在过去的77个小时中，三种状态的所占的比例</li>
</ol>
<p><strong>统计表格</strong>：<a href="https://pan.baidu.com/s/1ibYoFcHrw1qYi7kf4D4ePQ">下载链接</a>（提取码：<code>1234</code>），记录5天后，统计3种时间的总量，并计算出相应的比重</p>
<blockquote>
<p><strong>说明</strong>：如果觉得自己的时间利用就是很差，我觉得不用做这个统计，这个统计数据可以让我们自己震撼到，能够触动我们，激发要做出改变的决心</p>
</blockquote>
<h4 id="1-2、认识时间黑洞">1.2、认识时间黑洞</h4>
<p><strong>时间黑洞</strong>：它会永无止境地吞噬我们宝贵的时间</p>
<p><strong>举例说明</strong>：</p>
<ul>
<li><strong>超市黑洞时间</strong>：本来只打算买点水果，看了会苹果，发现香蕉打折，然后决定先拿个购物篮，买完香蕉苹果，又发现进口的果酱很便宜，又去换了一个购物车，之后等等在计划之外的购物活动接踵而来。</li>
<li><strong>电视时间黑洞</strong>：忙了一段时间，决定休息一下，看会电视，看到自己一直心心念想的电视剧，一下没忍住，刷了5个小时，导致工作1小时，休息了5个小时</li>
<li><strong>网络时间黑洞</strong>：早上一来实验室，先打开B站看看自己关注的UP主更新的内容，又发现别的推荐的内容，又跳转到别的UP主专栏中继续浏览，接二连三的进展下去，本来9点准备学习，看到了9.30</li>
</ul>
<p><strong>时间黑洞产生的原因</strong>：人的大脑喜欢做简单事情的特点，刷朋友圈要比写论文简单的多，大脑会倾向于刷朋友圈，而畏惧写论文。</p>
<p><strong>大多数人做事情不够主动，不愿走出舒适区，所以很容易陷入时间黑洞，从而浪费时间，浪费生命。</strong></p>
<p><strong>所以下次在学习工作期间发现自己沉浸娱乐中时，要当机立断，放下手机，投入到正事中来，不要觉得多看一会没事，过度放纵自己。</strong></p>
<p><strong>一天时间内学习情况的记录</strong>：<a href="https://pan.baidu.com/s/1OAF3JddsLrdAoRpv9okHkw">表格链接</a>（提取码：<code>1234</code>）</p>
<ol>
<li>每隔一个小时写出下一个小时<code>计划做的事情</code></li>
<li>一个小时结束之后记录下结果</li>
<li>坚持一整天</li>
</ol>
<h3 id="2、如何记录和分析时间日志？">2、如何记录和分析时间日志？</h3>
<p><strong>每一段时间的运用都是有意义的，每段时间可以分为主动时间和被动时间</strong>：</p>
<ul>
<li><strong>主动时间</strong>：做事之前有预期，并且追求预期的结果</li>
<li><strong>被动时间</strong>：与主动时间相反</li>
</ul>
<p><strong>时间黑洞就是指被动时间的集合</strong>。</p>
<p><strong>时间黑洞是由时间块聚集而成的，研究表明：当注意力被打断之后，如果想要重新集中注意力，需要15分钟；时间黑洞不仅将被动时间吞噬，还将主动时间破坏。</strong></p>
<p><strong>避免时间黑洞的小妙招</strong>：</p>
<ol>
<li>关掉微信、QQ等</li>
<li>保持工作环境整洁</li>
<li>给水杯倒满水</li>
<li>做一张任务清单</li>
<li>尽量地隔离自己</li>
<li>要事第一</li>
<li>无法集中精力时，先休息一会</li>
<li>设置任务的最后期限</li>
</ol>
<p><strong>要管理时间，得先知道时间是怎么花出去的。时间日志可以帮住记录时间都花费在什么地方，时间日志的好处</strong>：</p>
<ol>
<li>提醒自己珍惜时间</li>
<li>分析自己时间的投入与产出比</li>
<li>找到自己的最高效时间段</li>
</ol>
<p><strong>老付的工作四步法</strong>：</p>
<ol>
<li>将所有的任务放入工作篮，不论是谁在什么时间交代的任务，统统放进工作栏</li>
<li>将可以置之不理的任务清除掉；将必须在某天处理或者必须转交别人处理的任务拿出来；将那些可以在两分钟之内完成的任务立即完成</li>
<li>将需要在特定日期处理的事情写进日程表；将需要别人处理的事情立即转交并且设置到期提醒；将需要现在处理的事情摆在办公桌上</li>
<li>在自己最高效的时段，做最重要的事情，其他事情也做合理的安排</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>业余笔记</category>
        <category>陶冶情操</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>读物</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo + Github + Next的博客搭建</title>
    <url>/post/26832.html</url>
    <content><![CDATA[<h2 id="主流博客框架简介">主流博客框架简介</h2>
<p><strong>现在主流的博客框架有：<code>Wordpress,Hexo,Jekyllrb,Hugo</code></strong></p>
<ul>
<li>
<p><strong>Wordpress</strong>：</p>
<p>Wordpress是一个基于PHP，用来搭建<strong>动态</strong>的博客的CMS系统。Wordpress也是一个开源的，可以使用Wordpress来制作网站，或者是App。Wordpress这个框架还是比较成熟的，使用的人也比较多，根据官网统计全球有38%的网站使用的都是Wordpress。</p>
<p>Wordpress框架主要的作用是做新闻网站和博客网站，照这样分析，可以说是所有该类型的网站使用的都是Wordpress框架。</p>
</li>
<li>
<p><strong>Hexo</strong>：</p>
<p>Hexo是基于JS，是一款快速、简洁且高效的博客框架。Hexo支持Markdown，Hexo部署起来是非常方便的，可以部署到github、码云或是是云主机。</p>
</li>
<li>
<p><strong>Jekyllrb</strong>：</p>
<p>Jekyllrb是基于Ruby，同样也是一个静态网站生成器，它的使用与Hexo的使用方法很像，也是很简单的博客框架。</p>
</li>
<li>
<p><strong>Huge</strong>：</p>
<p>Hugo是基于Go语言的，Hugo在安装、创建新的页面、更换主题等的操作也是很方便，同样，几行命令就可以搞定。</p>
</li>
</ul>
<blockquote>
<p><strong>说明</strong>：本笔记是基于<strong>Windows10</strong>系统搭建的<strong>Hexo</strong>框架博客，使用的是<strong>Hexo</strong>框架中的<strong>Next</strong>主题。</p>
</blockquote>
<h2 id="Hexo框架的安装">Hexo框架的安装</h2>
<h3 id="1、相关安装包的下载和安装">1、相关安装包的下载和安装</h3>
<h4 id="1-1、Git的下载和安装">1.1、Git的下载和安装</h4>
<h5 id="1-1-1、Git的作用">1.1.1、Git的作用</h5>
<p><strong>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理，也就是用来管理Hexo博客文章，上传到GitHub的工具。</strong></p>
<h5 id="1-1-2、Git的下载">1.1.2、Git的下载</h5>
<ul>
<li><strong>官网下载</strong>：<a href="http://git-scm.com/download/win">下载链接</a></li>
<li><strong>淘宝镜像下载</strong>：<a href="https://npm.taobao.org/mirrors/git-for-windows/v2.33.0.windows.1/">下载链接</a></li>
<li><strong>Github下载</strong>：<a href="https://gitforwindows.org/">下载链接</a></li>
<li><strong>百度网盘下载</strong>：<a href="https://pan.baidu.com/s/1ncXfgf9OC0cMzIetQSaf2w">下载链接</a>(提取码：<code>1234</code>)</li>
</ul>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>
<p>根据自己<code>Windows</code>系统的位数，选择合适的安装包下载，官网下载以<code>Setup</code>结尾的即可，淘宝镜像下载<code>.exe</code>格式的即可。</p>
</li>
<li>
<p>在国内通过访问官网下载的速度会很慢，可以<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>翻墙<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>通过官网下载或者借助<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>Github、淘宝镜像、百度网盘<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>直接下载安装包。</p>
</li>
<li>
<p>本笔记是基于Git的<code>2.33.1</code>版本记录的，版本不同安装过程稍微不一样。</p>
</li>
</ul>
</blockquote>
<h5 id="1-1-3、Git的安装">1.1.3、Git的安装</h5>
<ol>
<li>双击下载好的<code>.exe</code>格式的安装包，点击<code>Next</code></li>
</ol>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030094032171.png" alt="image-20211030094032171"></p>
<ol start="2">
<li>选择要安装的位置</li>
</ol>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030094210880.png" alt="image-20211030094210880"></p>
<ol start="3">
<li>
<p>选择组件</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030094556966.png" alt="image-20211030094556966"></p>
</li>
<li>
<p>开始菜单目录名设置</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030094722386.png" alt="image-20211030094722386"></p>
</li>
<li>
<p>选择Git的默认编辑器：默认选择<code>Vim</code>即可</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030094957389.png" alt="image-20211030094957389"></p>
</li>
<li>
<p>Git仓库在<code>git init</code>操作后的初始分支命名问题，Git默认是<code>master</code>，可自行设置成自己喜欢的命名，此处设置无伤大雅，直接默认即可，并且后期也是可以在命令行中修改，如果需要，请自行百度搜索修改命令语句</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030095330066.png" alt="image-20211030095330066"></p>
</li>
<li>
<p>选择使用命令行环境即可</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030095856073.png" alt="image-20211030095856073"></p>
</li>
<li>
<p>以下7步默认设置即可，直接<code>Next</code></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100002551.png" alt="image-20211030100002551"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100027336.png" alt="image-20211030100027336"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100049550.png" alt="image-20211030100049550"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100110335.png" alt="image-20211030100110335"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100135518.png" alt="image-20211030100135518"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100159669.png" alt="image-20211030100159669"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100215951.png" alt="image-20211030100215951"></p>
</li>
<li>
<p>直接默认设置，点击<code>install</code>进行安装即可</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100239331.png" alt="image-20211030100239331"></p>
</li>
<li>
<p>最后一步，点击完成</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100542077.png" alt="image-20211030100542077"></p>
</li>
</ol>
<h5 id="1-1-4、检验是否安装成功">1.1.4、检验是否安装成功</h5>
<p><strong>回到电脑桌面，鼠标右击，在所列出的选项中会出现<code>Git GUI Here</code>和<code>Git Bash Here</code>则代表Git安装成功</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030100948843.png" alt="image-20211030100948843"></p>
<h5 id="1-1-5、Git初始化">1.1.5、Git初始化</h5>
<ul>
<li>
<p><strong>注册Github账号</strong>：</p>
<ol>
<li>
<p>登陆<a href="https://github.com">Github官网</a></p>
</li>
<li>
<p>注册步骤如下图，可自行注册，不必参考下图</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030203129955.png" alt="image-20211030203129955"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030203800029.png" alt="image-20211030203800029"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030204009682.png" alt="image-20211030204009682"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030204318493.png" alt="image-20211030204318493"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030204509595.png" alt="image-20211030204509595"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030204656951.png" alt="image-20211030204656951"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030204754586.png" alt="image-20211030204754586"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030205134826.png" alt="image-20211030205134826"></p>
</li>
</ol>
</li>
<li>
<p><strong>Git初始化</strong>：在桌面右击选择<code>Git Bash Here</code>打开命令行进行如下操作</p>
<ol>
<li>
<p><strong>设置用户名</strong>：在<code>Git Bash</code>命令行中输入<code>git  config -- global  user.name  'Github注册的用户名'</code>，例如：<code>git config --global user.name dongqing1234</code>。</p>
</li>
<li>
<p><strong>设置用户邮箱</strong>：在<code>Git Bash</code>命令行中输入<code>git  config -- global  user.email  'GitHub注册的邮箱'</code>，例如：<code>git config --global user.email "shoudongj@gmail.com"</code>。</p>
</li>
<li>
<p>配置ok后，在命令行中输入<code>git config --list</code>进行验证是否配置成功。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030231211745.png" alt="image-20211030231211745"></p>
</li>
</ol>
</li>
</ul>
<h5 id="1-1-6、使用SSH密钥链接Github">1.1.6、使用SSH密钥链接Github</h5>
<ol>
<li>
<p><strong>查看是否存在SSH密钥</strong>：在<code>Git Bash</code>命令行中，执行<code>cd ~/.ssh</code>命令，如果<code>.ssh</code>目录中<strong>存在<code>id_rsa, id_rsa.pub</code>两个文件</strong>，则<strong>不需要执行第2步操作</strong>，否则需要进行第2步操作。</p>
</li>
<li>
<p><strong>创建一对新的SSH密钥</strong>：</p>
<ul>
<li>
<p>在命令行中执行如下命令，创建密钥</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "your_email@example.com"</span><br><span class="line"><span class="meta">#</span><span class="bash">这将按照你提供的邮箱地址，创建一对密钥</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]</span><br><span class="line"><span class="meta">#</span><span class="bash">此处直接回车，则将密钥按默认文件进行存储</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>根据提示，需要输入密码和确认密码（其实可以不用密码，就是到输密码的地方，都直接回车，所以每次push就只管回车即可）。相关提示如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>全部完成后，会输出如下信息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Your identification has been saved in /c/Users/you/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>命令行代码实例图：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030235120833.png" alt="image-20211030235120833"></p>
</li>
</ul>
</li>
<li>
<p><strong>在GitHub账户中添加自己的公钥</strong></p>
<ul>
<li>
<p>在命令行输入<code>clip &lt; ~/.ssh/id_rsa.pub</code>命令，将公钥的内容复制到系统粘贴板中。</p>
</li>
<li>
<p>登陆<a href="https://github.com">Github</a>，进入个人账户设置，选择<code>SSH与GPG公钥</code>。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030233958062.png" alt="image-20211030233958062"></p>
</li>
<li>
<p>点击<code>新建SSH密钥</code>。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030234331181.png" alt="image-20211030234331181"></p>
</li>
<li>
<p>将复制好的密钥粘贴到到<code>密钥</code>输入框中。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030235705776.png" alt="image-20211030235705776"></p>
</li>
<li>
<p>输入Github密码即可。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031000032736.png" alt="image-20211031000032736"></p>
</li>
<li>
<p>最后进行测试，在命令行中输入<code>ssh -T git@github.com</code>命令，如果需要提供验证密码，输入上一步的密码即可。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031001205880.png" alt="image-20211031001205880"></p>
</li>
</ul>
</li>
</ol>
<h4 id="1-2、Node-js的下载和安装">1.2、Node.js的下载和安装</h4>
<h5 id="1-2-1-Node-js的作用">1.2.1 Node.js的作用</h5>
<p><strong>在前面<a href="#%E4%B8%BB%E6%B5%81%E5%8D%9A%E5%AE%A2%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">主流博客框架简介</a>中讲到<code>Hexo</code>框架是基于<code>JS</code>开发的，所以<code>Hexo</code>框架的配置需要在<code>JS</code>的环境中修改，而Node.js 是一个基于 Chrome V8 引擎的JavaScirpt 运行环境</strong>。</p>
<h5 id="1-2-2-Node-js的下载">1.2.2 Node.js的下载</h5>
<p><strong>官网下载</strong>：<a href="https://nodejs.org/zh-cn/download/">下载链接</a></p>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>下载长期维护版的<code>.msi</code>格式的安装包即可，比较稳定可靠。</li>
<li>本笔记是基于Node.js的<code>16.13.0</code>版本记录的。</li>
</ul>
</blockquote>
<h5 id="1-2-3、Node-js的安装">1.2.3、Node.js的安装</h5>
<p><strong>除了安装目录按照自己的需求修改外，其他的全部按照默认设置安装即可。</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030153815819.png" alt="image-20211030153815819"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030153907374.png" alt="image-20211030153907374"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030154010207.png" alt="image-20211030154010207"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030154057081.png" alt="image-20211030154057081"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030154300341.png" alt="image-20211030154300341"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030154351718.png" alt="image-20211030154351718"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030154441602.png" alt="image-20211030154441602"></p>
<h5 id="1-2-4、检测Node-js安装是否成功">1.2.4、检测Node.js安装是否成功</h5>
<p><strong>使用安装好的Git进行检测，在电脑桌面右击选择<code>Git Bash Here</code>进入Git的命令行模式，输入<code>node -v</code>查看Node.js的版本，如果输出版本号就表示安装成功。</strong></p>
<h3 id="2、Hexo框架的安装">2、Hexo框架的安装</h3>
<blockquote>
<p><strong>说明</strong>：接下来的所有<strong>命令操作</strong>都是在<code>Git Bash</code>中进行的。</p>
</blockquote>
<h4 id="2-1、检测">2.1、检测</h4>
<h5 id="2-1-1、检测Node-js的版本">2.1.1、检测Node.js的版本</h5>
<p><strong>在<code>Git Bash</code>命令行中，输入<code>node -v</code>，输出版本号代表安装成功。</strong></p>
<h5 id="2-1-2、检测npm的版本">2.1.2、检测npm的版本</h5>
<p><strong>在<code>Git Bash</code>命令行中，输入<code>npm -v</code>，输出版本号代表安装成功。</strong></p>
<blockquote>
<p><strong>拓展</strong>：	npm是随同Node.js一起安装的<code>包管理工具</code>，类似于360软件管家，能解决Node.js代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>
</ul>
</blockquote>
<h4 id="2-2、安装淘宝的镜像源cnpm">2.2、安装淘宝的镜像源<code>cnpm</code></h4>
<p><strong>因为npm的服务器位于国外可能会影响安装，可以借助淘宝做的国内镜像cnpm下载所需要的package包</strong>。</p>
<p><strong>借助npm安装cnpm</strong>：在<code>Git Bash</code>命令行中，输入</p>
<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>即可安装。</p>
<p><strong>检验是否安装成功</strong>：</p>
<ul>
<li>在<code>Git Bash</code>命令行中，输入<code>cnpm</code>，输出cnpm信息</li>
<li>在<code>Git Bash</code>命令行中，输入<code>cnpm -v</code>，输出cnpm版本信息</li>
</ul>
<p><strong>以上两个操作都返回正确信息代表安装成功。</strong></p>
<blockquote>
<p><strong>说明</strong>：如果错误就重来，因为连接可能不稳定。</p>
</blockquote>
<h4 id="2-3、安装Hexo框架">2.3、安装Hexo框架</h4>
<p><strong>在<code>Git Bash</code>命令行中，输入<code>cnpm install -g hexo-cli</code></strong>。</p>
<p><strong>检验是否安装成功</strong>：在<code>Git Bash</code>命令行中，输入<code>hexo -v</code>，输出Hexo的版本信息代表安装成功。</p>
<p><strong>本人<code>hexo -v</code>的返回信息</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030191225379.png" alt="image-20211030191225379"></p>
<blockquote>
<p><strong>说明</strong>：如果错误就重来，因为连接可能不稳定。</p>
</blockquote>
<h4 id="2-4、初始化过程">2.4、初始化过程</h4>
<p><strong>在本地建立博客文件夹，文件夹的名字根据自己的喜好设置即可，本人设置成<code>Blog</code>，后面所有的插件安装等都是基于这个博客文件夹，如果重建博客，只需要删除博客文件夹即可</strong>。</p>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>一定要保证所建的博客文件夹中为<strong>空文件夹</strong>，里面无任何内容，否则接下来执行<code>hexo init</code>操作会报错，会提示文件夹非空。</li>
<li>本笔记中所说的<strong>站点目录</strong>就是新建的<strong>博客文件夹</strong>，站点就是博客。</li>
</ul>
</blockquote>
<p><strong>接下来的操作步骤</strong>：</p>
<ol>
<li>
<p>在新建的博客文件夹<code>Blog</code>中，右击鼠标，选择<code>Git Bash Here</code>进入Git命令行模式，要确保当前是在新建的博客文件夹中。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030192841049.png" alt="image-20211030192841049"></p>
</li>
<li>
<p>在命令行中输入<code>hexo init</code>后回车，对应的博客文件夹中就会新增很多关于Hexo框架的文件。</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030193055972.png" alt="image-20211030193055972" style="zoom:80%;">
</li>
<li>
<p>在命令行中输入<code>hexo s</code>启动Hexo，在本地浏览器输入<a href="http://localhost:4000">http://localhost:4000</a>即可在本地4000端口浏览自己的网站。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030193517056.png" alt="image-20211030193517056"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030193827087.png" alt="image-20211030193827087"></p>
</li>
</ol>
<h2 id="部署网站到Github">部署网站到Github</h2>
<h3 id="1、创建Github仓库">1、创建Github仓库</h3>
<p><strong>创建步骤</strong>：</p>
<ol>
<li>
<p>在Github网站首页点击<strong>新建仓库</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030205535299.png" alt="image-20211030205535299"></p>
</li>
<li>
<p>以<code>自己的Github用户名.github.io</code>命名仓库名称，例如：<code>lisi.github.io</code>，同时一定要设置成公有，否则会造成博客访问不了</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030210513742.png" alt="image-20211030210513742"></p>
</li>
<li>
<p>记住下图的地址，后面需要用到</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030215905006.png" alt="image-20211030215905006"></p>
</li>
</ol>
<h3 id="2、配置站点配置文件">2、配置站点配置文件</h3>
<ol>
<li>
<p>在创建的博客文件夹<code>Blog</code>中，找到站点的配置文件<code>_config.yml</code>，使用本地常用的编辑器打开进行配置站点。</p>
</li>
<li>
<p>在打开的站点配置文件<code>_config.yml</code>中，搜索<code>deploy</code>找到下图中的代码段</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030221026359.png" alt="image-20211030221026359"></p>
</li>
<li>
<p>将该代码段改成下图的代码，需要添加<code>repo、branch</code>项</p>
<ul>
<li><code>type</code>项的内容建议写成<code>git</code>便于识别；</li>
<li><code>repo</code>项的内容是仓库的地址，对应第3步中的地址，直接复制粘贴过来即可；</li>
<li><code>branch</code>项的内容设置为之前安装Git时自行设置的分支名字即可，默认设置是<code>master</code>；</li>
</ul>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:dongqing1234/dongqing1234.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211030221718860.png" alt="image-20211030221718860"></p>
</li>
<li>
<p>更改后保存并退出，在<code>Git Bash</code>中输入<code>hexo d</code>将本地文件部署到自己的Github中新建的仓库中，命令执行完后可以通过访问<a href="https://xn--eqrz3u1pdf0yyrbg95a.github.io">https://自己的用户名.github.io</a>，从远端访问自己的博客站点</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031001809287.png" alt="image-20211031001809287"></p>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>在之前在<code>Git Bash</code>中执行<code>hexo s</code>后，键盘输入<code>CTRL + C</code>即可退出。</li>
<li>执行<code>hexo d</code>会提示<code>nothing to commit, working tree clean</code>，只需要依次执行<code>hexo clean, hexo g, hexo d</code>即可。</li>
<li>执行完<code>hexo d</code>后，需要等一会才会完全部署到Github仓库中，因为Github的服务器部署在国外。</li>
<li>执行完<code>hexo d</code>后如果报错<code>ERROR Deployer not found: git</code>，需要进行安装<code>hexo-deployer-git</code>插件，在博客文件夹下进入Git命令行输入<code>npm install --save hexo-deployer-git </code>，等待安装成功即可，然后再次执行<code>hexo d</code>。</li>
<li>Hexo的命令：
<ul>
<li><code>hexo clean</code>：清除数据库缓存</li>
<li><code>hexo g</code>：生成静态网站</li>
<li><code>hexo s</code>：开启本地Hexo服务器，便于在本地预览站点</li>
<li><code>hexo d</code>：将现在的文件部署到Github中</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="更换Next主题">更换Next主题</h2>
<p><strong>Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下， 然后修改下站点配置文件即可。具体到 NexT 来说，使用git克隆最新版本的Next主题的安装步骤如下</strong>：</p>
<ul>
<li>
<p>在站点目录下右击打开<code>Git Bash Here</code>，输入命令</p>
<p><code>git clone git://github.com/theme-next/hexo-theme-next themes/next</code>将主题克隆到本地站点中</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031090107552.png" alt="image-20211031090107552"></p>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>如果不成功，多次重复实验即可。</li>
<li>注意是在<strong>站点目录</strong>下执行这条命令</li>
</ul>
</blockquote>
</li>
<li>
<p>将站点目录下**_config.yml<strong>里</strong>theme**的名称由<code>landscape</code>修改为<code>next</code>，然后保存退出</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031083910234.png" alt="image-20211031083910234"></p>
</li>
<li>
<p>在命令行中依次输入<code>hexo clean, hexo s</code>就可以预览站点的Next主题</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031091240436.png" alt="image-20211031091240436"></p>
</li>
</ul>
<h2 id="优化Next主题">优化Next主题</h2>
<h3 id="1、更改Scheme外观">1、更改Scheme外观</h3>
<p><strong>Scheme 是Next提供的一种特性，借助于Scheme，Next提供多种不同的外观，几乎所有的配置都可以在Scheme 之间共用，目前Next支持4种Scheme</strong>：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
<li>Gemini - 导航栏、头像等基本信息在侧边栏上显示</li>
</ul>
<p><strong>本人选择的是<code>Gemini</code>，简单方便</strong>。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031120446674.png" alt="image-20211031120446674"></p>
<h3 id="2、更改站点基本信息">2、更改站点基本信息</h3>
<ul>
<li>
<p>打开<strong>站点目录</strong>下的站点配置文件<code>_config.yml</code>，然后查找<code>Site</code>，对应下图改成自己需要的即可，最后保存</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031094223392.png" alt="image-20211031094223392"></p>
</li>
<li>
<p>打开<strong>主题目录</strong>下的<code>languages</code>文件夹，查看是否存在<code>zh-Hans.yml</code>文件，如果不存在将<code>zh-CN.yml</code>重命名<code>zh-Hans.yml</code></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031093735188.png" alt="image-20211031093735188"></p>
</li>
<li>
<p>在站点目录下进入<code>Git Bash</code>命令行，依次执行<code>hexo clean, hexo s</code>即可在浏览器通过<a href="http://localhost:4000">本地端口</a>看到站点的变化</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031095109539.png" alt="image-20211031095109539"></p>
</li>
</ul>
<h3 id="3、设置主题菜单">3、设置主题菜单</h3>
<p><strong>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 <a href="http://fontawesome.io/">Font Awesome</a> 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景。</strong></p>
<p><strong>主题菜单设置步骤：</strong></p>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>本笔记所说的<strong>站点</strong>配置文件<code>_config.yml</code>指的是站点目录下的<code>_config.yml</code></li>
<li>本笔记所说的<strong>主题</strong>配置文件<code>_config.yml</code>指的是站点目录下<code>themes</code>目录下的<code>next</code>目录下的<code>_config.yml</code></li>
</ul>
</blockquote>
<p>编辑<code>主题配置文件</code>，查找<code>menu</code>定位到主题菜单配置处，修改如下内容；</p>
<ol>
<li>
<p>设定菜单内容，对应的字段是 <code>menu</code>。 菜单内容的设置格式是：<code>item name: link</code>。其中 <code>item name </code>是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译</p>
<p>菜单实例配置：不需要的菜单就注销掉</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user  //不需要的就注销掉</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>设置菜单项的显示文本，在第1步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 <code>languages/zh-Hans.yml</code> 中</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">日程表</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">站点地图</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">公益</span> <span class="number">404</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h3 id="4、设置侧边栏">4、设置侧边栏</h3>
<p><strong>可以通过修改 <code>主题配置文件</code> 中的 <code>sidebar</code> 字段来控制侧栏的行为，侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。</strong></p>
<ul>
<li>
<p>设置侧栏的位置，修改 <code>sidebar.position</code> 的值，支持的选项有：</p>
<ul>
<li>left - 靠左放置</li>
<li>right - 靠右放置</li>
</ul>
</li>
<li>
<p>设置侧栏显示的时机，修改 <code>sidebar.display</code> 的值，支持的选项有：</p>
<ul>
<li><code>post</code> - 默认行为，在文章页面（拥有目录列表）时显示</li>
<li><code>always</code> - 在所有页面中都显示</li>
<li><code>hide</code> - 在所有页面中都隐藏（可以手动展开）</li>
<li><code>remove</code> - 完全移除</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  display: post</span><br></pre></td></tr></tbody></table></figure>
<h3 id="5、设置头像">5、设置头像</h3>
<p><strong>编辑 <code>主题配置文件</code>， 修改字段 <code>avatar</code>， 值设置成头像的链接地址。其中，头像的链接地址可以是</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">地址</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">完整的互联网 URI</td>
<td style="text-align:left"><code>http://example.com/avatar.png</code></td>
</tr>
<tr>
<td style="text-align:left">站点内的地址</td>
<td style="text-align:left">将头像放置主题目录下的 <code>source/uploads/</code> （新建 uploads 目录若不存在） 配置为：<code>avatar: /uploads/avatar.png</code>或者 放置在 <code>source/images/</code> 目录下 配置为：<code>avatar: /images/avatar.png</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>说明</strong>：注意在主题配置文件中，修改<code>avatar</code>选项内容时，头像链接和<code>#</code>之间需要有一个空格。</p>
</blockquote>
<h3 id="6、设置-RSS">6、设置 RSS</h3>
<p><strong>NexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 <code>主题配置文件</code>，设定 <code>rss</code> 字段的值</strong>：</p>
<ul>
<li><code>false</code>：禁用 RSS，不在页面上显示 RSS 连接。</li>
<li>留空：使用 Hexo 生成的 Feed 链接。 你可以需要先安装 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 插件。</li>
<li>具体的链接地址：适用于已经烧制过 Feed 的情形</li>
</ul>
<h3 id="7、添加「标签」页面">7、添加「标签」页面</h3>
<p><strong>新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的</strong>。</p>
<p><strong>在站点目录下右击鼠标进入命令行，输入命令 <code>hexo new page tags</code> 新建一个页面，命名为 <code>tags</code></strong>。</p>
<p><strong>在站点目录中依次进入<code>/source/tags</code>目录中，打开<code>index.md</code>文件，修改为以下内容</strong>：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2021-10-27 22:20:26</span><br><span class="line">type: "tags"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8、添加「分类」页面">8、添加「分类」页面</h3>
<p><strong>新建「分类」页面，并在菜单中显示「分类」链接。「分类」页面将展示站点的所有分类，若你的所有文章都未包含分类，此页面将是空的。</strong></p>
<p><strong>在站点目录下右击鼠标进入命令行，输入命令 <code>hexo new page categories</code> 新建一个页面，命名为 <code>categories</code></strong>。</p>
<p><strong>在站点目录中依次进入<code>/source/categories</code>目录中，打开<code>index.md</code>文件，修改为一下内容</strong>：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2021-10-27 22:22:31</span><br><span class="line">type: "categories"</span><br></pre></td></tr></tbody></table></figure>
<h3 id="9、标签页美化">9、标签页美化</h3>
<p><strong>主题配置文件 <code>_config.yml</code> 去除 <code>styles.styl</code> 的注释</strong></p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></tbody></table></figure>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031151345121.png" alt="image-20211031151345121" style="zoom:67%;">
<p><strong>在站点目录下的<code>source</code>目录中创建<code>_data</code> 目录，在<code>_data</code>目录下新建 <code>styles.styl</code> 文件，填入下面内容</strong>：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.tag-cloud</span> <span class="selector-tag">a</span> {</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">3px</span> <span class="number">#6f42c1</span>, <span class="number">0</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#d9534f</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">background</span>: rgba(<span class="number">193</span>,<span class="number">66</span>,<span class="number">92</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="10、分类页美化">10、分类页美化</h3>
<p><strong>在 站点目录下依次进行选择<code>themes → next → source → css → _schemes → (自己选择的Scheme)</code> 进入文件夹，用编辑器打开<code>index.styl </code>文件在最后新增如下样式</strong>：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 分类页样式 began */</span></span><br><span class="line"><span class="selector-class">.category-list-link</span>:hover{</span><br><span class="line">  <span class="attribute">transform</span>: scale(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">2px</span> rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">12</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">6px</span> <span class="number">0</span> rgba(<span class="number">104</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">0.1</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">transition-duration</span>: <span class="number">0.15s</span>;</span><br><span class="line">  <span class="comment">//display:flex;</span></span><br><span class="line">}</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.category-list-link</span>:before{</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"📚"</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">font</span>: normal normal normal <span class="number">14px</span>/<span class="number">1</span> FontAwesome;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">18px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 分类页样式 end */</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>修改站点目录下的<code>/themes/next/source/css/_common/components/pages/categories.styl</code>代码，将<code>.category-list-child</code>的<code>padding-left</code>属性改为<code>60px</code>，可以更改子类与父类之间的间隔</strong>。</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031122209809.png" alt="image-20211031122209809"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031122308556.png" alt="image-20211031122308556"></p>
<blockquote>
<p><strong>补充</strong>：Hexo-Next分类多层级描述</p>
<ol>
<li>
<p><strong>分类一般用法</strong><br>
Hexo中分类和标签有着明显的差别：分类具有顺序性和层次性，也就是说Foo, Bar 不等于Bar, Foo；而标签没有顺序和层次。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">PS3</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Games</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>父子分类</strong><br>
Hexo不支持指定多个同级分类。下面的指定方法会使分类Life成为Diary的子分类，而不是并列分类。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Life</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>并列+子分类</strong><br>
如果需要为文章添加多个分类，可以尝试以下 list 中的方法。此时这篇文章同时包括三个分类：PlayStation和Games分别都是父分类Diary的子分类，同时Life是一个没有子分类的分类。</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">PlayStation</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">Games</span>]</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Life</span>]</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
</blockquote>
<h3 id="11、设置代码高亮主题">11、设置代码高亮主题</h3>
<p><strong>NexT 使用 <a href="https://github.com/chriskempson/tomorrow-theme">Tomorrow Theme</a> 作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 <code>normal</code> 主题，可选的值有 <code>normal</code>，<code>night</code>， <code>night blue</code>， <code>night bright</code>， <code>night eighties</code></strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><img src="http://theme-next.iissnan.com/assets/img/tomorrow.png" alt="img"></th>
<th style="text-align:center"><img src="http://theme-next.iissnan.com/assets/img/tomorrow-night.png" alt="img"></th>
<th style="text-align:center"><img src="http://theme-next.iissnan.com/assets/img/tomorrow-night-blue.png" alt="img"></th>
<th style="text-align:center"><img src="http://theme-next.iissnan.com/assets/img/tomorrow-night-bright.png" alt="img"></th>
<th style="text-align:center"><img src="http://theme-next.iissnan.com/assets/img/tomorrow-night-eighties.png" alt="img"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>normal</code></td>
<td style="text-align:center"><code>night</code></td>
<td style="text-align:center"><code>night blue</code></td>
<td style="text-align:center"><code>night bright</code></td>
<td style="text-align:center"><code>night eighties</code></td>
</tr>
</tbody>
</table>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="comment"># 以下选项根据需要自行设置</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">false</span> </span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">flat</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="12、代码行美化">12、代码行美化</h3>
<p><strong>在站点目录下的 <code>source/_data/styles.styl</code> 文件中加入下面样式</strong>：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 代码行样式</span></span><br><span class="line"><span class="selector-tag">code</span> {</span><br><span class="line">	<span class="attribute">color</span>:<span class="number">#c7254e</span>;</span><br><span class="line">	<span class="attribute">background</span>:<span class="number">#f9f2f4</span>;</span><br><span class="line">	<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#d6d6d6</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="13、添加站点内容搜索功能">13、添加站点内容搜索功能</h3>
<ul>
<li>
<p>安装 <code>hexo-generator-searchdb</code>，在站点的目录下右击鼠标打开<code>Git Bash</code>命令行执行以下命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cnpm install hexo-generator-searchdb --save</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>编辑 <strong>站点配置文件</strong>新增以下内容到任意位置：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>编辑 <strong>主题配置文件</strong>，查找<code>local_search</code>启用本地搜索功能：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="14、设置首页阅读全文">14、设置首页阅读全文</h3>
<p><strong>在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 Next提供三种方式来控制文章在首页的显示方式，在首页显示文章的摘录并显示 <code>阅读全文</code>按钮，可以通过以下方法</strong>：</p>
<ol>
<li>
<p>在文章中使用 <code>&lt;!-- more --&gt;</code> 手动进行截断，Hexo提供的方式 <strong>推荐</strong></p>
</li>
<li>
<p>在文章的 <a href="https://hexo.io/docs/front-matter.html">front-matter</a> 中添加 <code>description</code>，并提供文章摘录</p>
</li>
<li>
<p>自动形成摘要，在 <code>主题配置文件</code>中添加：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p><strong>本人使用的是第二种，通过添加<code>description</code>的方式设置首页显示每篇博文的内容，因为尝试过第三种方法没有奏效，第一种又比较拉跨。</strong></p>
<h3 id="15、设置博客文章持久化链接">15、设置博客文章持久化链接</h3>
<ol>
<li>
<p>在命令行中输入<code>cnpm install hexo-abbrlink --save</code>命令安装<code>hexo-abbrlink</code>插件</p>
</li>
<li>
<p>站点配置文件<code>_config.yml</code>修改<code>permalink</code>选项，修改内容如下：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>   <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span> <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<blockquote>
<p><strong>说明</strong>：需要注意，如果 <code>permalink</code> 设置为 <code>post/:abbrlink.html</code> 可能导致本地图片加载失败，尽量使用<a href="https://dongqing1903.github.io/post/44503.html#2%E3%80%81%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8OSS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D">图床</a>来管理自己的图片。</p>
</blockquote>
<h3 id="16、设置回到顶部按钮">16、设置回到顶部按钮</h3>
<p><strong>修改主题配置文件 <code>_config.yml</code> 中的<code>back2top</code> 选项，设置内容如下</strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 将返回按钮设置在侧边栏</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 按钮上显示进度百分比</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="17、修改文章内链接文本样式">17、修改文章内链接文本样式</h3>
<p><strong>在站点目录下 <code>source/_data/styles.styl</code> 文件中加入下面样式</strong>：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> a{</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="selector-pseudo">&amp;:hover</span> {</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fc6423</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: none;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fc6423</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="18、去掉顶部黑线">18、去掉顶部黑线</h3>
<p><strong>在站点目录下的 <code>/source/_data/styles.styl</code> 文件加入下面样式</strong>：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">//去掉顶部黑线：</span></span><br><span class="line"><span class="selector-class">.headband</span> {<span class="attribute">display</span>:none;}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="19、更换Hexo的网页图标">19、更换Hexo的网页图标</h3>
<p><strong>当套用完Next主题后，个人博客的站点图标会自动为Next的logo</strong></p>
<ol>
<li>
<p>制作favicon图标，这里提供一种制作方法<a href="https://www.bitbug.net/">链接</a>，将下载好的图片分别命名为<code>favicon16.ico</code>和<code>favicon32.ico</code>，并将修改后的图片复制到<code>/themes/next/source/images</code>目录中</p>
</li>
<li>
<p>打开next主题的<code>_config.yml</code>文件，<code>favicon:</code>有以下内容：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span>  </span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json  </span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>将步骤2中的对应内容修改为以下内容：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon16.ico</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon32.ico</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>在命令行中依次输入<code>hexo clean, hexo g, hexo d, hexo s</code>就可以在本地和远端看到自己的站点图标变成自己设置的图标</p>
</li>
</ol>
<h3 id="20、设置左上角或右上角-github-图标">20、设置左上角或右上角 github 图标</h3>
<p><strong>修改主题配置文件<code>_config.yml</code>，启用 <code>github-banner</code> 如下</strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">自己的Github地址(示例：https://github.com/dongqing1234)</span></span><br><span class="line">  <span class="attr">title:</span> </span><br></pre></td></tr></tbody></table></figure>
<h3 id="21、设置阅读位置标记功能">21、设置阅读位置标记功能</h3>
<p><strong>在命令行中输入<code>git clone https://github.com/theme-next/theme-next-bookmark.git source/lib/bookmark</code>命令来安装模块到站点目录下的<code>source/lib </code>目录下</strong>。</p>
<p><strong>编辑主题配置文件，启用 bookmark 模块，如下</strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">bookmark:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">save:</span> <span class="string">auto</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="22、目录设置">22、目录设置</h3>
<p><strong>主题配置文件 <code>_config.yml</code>，修改 <code>toc</code> 属性</strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 自动编号</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 超出宽度跨行</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 展开所有</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 最大标题深度</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="23、增加Valine评论功能">23、增加Valine评论功能</h3>
<ol>
<li>
<p>注册leancloud，<a href="https://leancloud.cn/dashboard/login.html#/signin">leancloud注册网址</a></p>
</li>
<li>
<p>注册登陆后，访问控制台，创建应用，选择开发版，创建好之后就生成了对应的id和key</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031140044606.png" alt="image-20211031140044606"></p>
</li>
<li>
<p>在<code>主题配置文件</code>中进行修改 Valine，<code>enable、appid、appkey</code>三个选项的内容是必须修改的，分别对应步骤2中的注册信息，其他选项根据自己需求设置，修改内容如下所示：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">appid:</span>                      <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span>                     <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># Article reading statistic</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span>  <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>修改完成后，在命令行中依次执行<code>hexo clean, hexo g, hexo d, hexo s</code>就可以在本地和远端看到评论</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031141957750.png" alt="image-20211031141957750"></p>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>
<p>在自己写的博文的<a href="https://hexo.io/docs/front-matter.html">front-matter</a>中可以通过增加<code>comments: true/false</code>来选择打开和关闭本页面对应的评论区。</p>
</li>
<li>
<p>打开站点目录下的<code>source</code>目录，对目录页分别进行评论区屏蔽设置，否则在标签页、分类页等都会存在评论区，此处以<code>tags</code>项为例，打开<code>/tags/index.md</code>，内容如下：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031142902132.png" alt="image-20211031142902132"></p>
</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="24、文章置顶问题">24、文章置顶问题</h3>
<p><strong>将站点目录下的<code>node_modules/hexo-generator-index/lib/generator.js</code>文件中的内容<code>全部</code>换成如下内容</strong>：</p>
<figure class="highlight js"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> config = <span class="built_in">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line"></span><br><span class="line">  posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>{</span><br><span class="line">      <span class="keyword">if</span>(a.top &amp;&amp; b.top) {</span><br><span class="line">          <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) {</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) {</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">''</span>, posts, {</span><br><span class="line">    <span class="attr">perPage</span>: config.index_generator.per_page,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    <span class="attr">format</span>: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    <span class="attr">data</span>: {</span><br><span class="line">      <span class="attr">__index</span>: <span class="literal">true</span></span><br><span class="line">    }</span><br><span class="line">  });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>修改完成后，只需要在<code>front-matter</code>中设置需要置顶文章的top值，将会根据top值大小来选择置顶顺序，top值越大越靠前。</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031155453377.png" alt="image-20211031155453377"></p>
<h3 id="25、添加emoji表情渲染器">25、添加<code>emoji</code>表情渲染器</h3>
<p><strong>在命令行输入<code>cnpm install hexo-filter-github-emojis --save</code>安装<code>hexo-filter-github-emojis</code>插件</strong>。</p>
<p><strong>在站点配置文件中添加如下内容</strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">githubEmojis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">github-emoji</span></span><br><span class="line">  <span class="attr">unicode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">styles:</span></span><br><span class="line">  <span class="attr">localEmojis:</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="26、修改文章底部-tag-图标">26、修改文章底部 tag 图标</h3>
<p><strong>修改主题配置文件 <code>_config.yml</code>，打开底部标签</strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="27、修改主题页面布局为圆角">27、修改主题页面布局为圆角</h3>
<p><strong>在 站点目录的<code>source/_data</code> 目录下新建 <code>variables.styl</code> 文件，填写下面内容</strong>：</p>
<figure class="highlight stylus"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line"><span class="variable">$border</span>-radius-inner     = <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span>;</span><br><span class="line"><span class="variable">$border</span>-radius           = <span class="number">20px</span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>主题配置文件 <code>_config.yml</code> 去除 <code>variables.styl</code> 的注释</strong></p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">variable:</span> <span class="string">source/_data/variables.styl</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="28、设置提示块-note">28、设置提示块 - note</h3>
<p><strong>主题配置文件 <code>_config.yml</code> 中 <code>note</code> 选项</strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="comment"># 是否显示图标</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="29、隐藏底部的强力驱动">29、隐藏底部的强力驱动</h3>
<p><strong>主题配置文件 <code>_config.yml</code> 修改 <code>footer</code> 选项下的 <code>powered</code></strong>：</p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Powered by Hexo &amp; NexT</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031162227019.png" alt="image-20211031162227019"></p>
<h3 id="30、更改新建文章的模板">30、更改新建文章的模板</h3>
<p><strong>默认新建文章需要修改站点目录下的<code>scaffolds/post.md</code> 文件</strong>。</p>
<p><strong>本人的默认新建文件<code>front-matter</code>部分的内容</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211031162037116.png" alt="image-20211031162037116"></p>
<h3 id="31、添加图片放大预览功能">31、添加图片放大预览功能</h3>
<p><strong>在<code>主题配置文件</code>中开启<code>fancybox</code>选项：</strong></p>
<figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="快速操作">快速操作</h2>
<h3 id="1、快捷命令设置">1、快捷命令设置</h3>
<p><strong>可以在命令行中输入以下命令，设置Hexo命令快捷方式</strong>：</p>
<figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cd ~    # 进入家目录下</span><br><span class="line">vim .bash_profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在此文件中设置快捷命令</span></span><br><span class="line">alias hc="hexo clean"</span><br><span class="line">alias hg="hexo g"</span><br><span class="line">alias hs="hexo s"</span><br><span class="line">alias hd="hexo d"</span><br><span class="line">alias hn="hexo n"</span><br><span class="line">alias blog="cd /D/SoftWare/Blog"</span><br><span class="line">alias post="cd /D/SoftWare/Blog/source/_posts"</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置好用输入:wq退出即可，以后就可以使用快捷命令进行操作</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="2、创建博文">2、创建博文</h3>
<ul>
<li>
<p><strong>可以通过命令行创建</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo n 博文名称</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>可以直接在<code>source/_post</code>中新建<code>.md</code>文件创建新的博文，但需要写入<code>front-matter</code></strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>业余笔记</category>
        <category>博客相关</category>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/post/ad4f1e09.html</url>
    <content><![CDATA[<h1>从C到C++</h1>
<h2 id="1、C的超集">1、C的超集</h2>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211119093821786.png" alt="image-20211119093821786" style="zoom:80%;">
<ul>
<li><strong><code>C++</code>继承了<code>C</code>的绝大部分关键字，而不是语法特性，比如<code>struct</code>，<code>C++</code>中<code>struct</code>是类实现的，<code>struct</code>内部是可以定义方法的，而<code>C</code>中的<code>struct</code>内部是不可以定义方法的。</strong></li>
<li><strong><code>Lambda表达式</code>支持函数式编程</strong></li>
<li><strong><code>模板</code>支持泛型编程</strong></li>
</ul>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li><strong>学习重点：<code>异常处理、类和对象、模板、Lambda</code></strong></li>
<li><strong>检验学习：<code>STL</code></strong></li>
<li><strong>学习步骤：按照编程范式分门别类的学习语法特性</strong></li>
</ul>
</blockquote>
<h2 id="2、编程范式">2、编程范式</h2>
<p><strong>编程范式：指导我们如何设计程序去实现相关的功能</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20210616215419980.png" alt="image-20210616215419980"></p>
<ul>
<li><strong>面向过程编程：用函数封装功能</strong></li>
<li><strong>面向对象编程：用类和对象实现功能</strong></li>
<li><strong>泛型编程：用<code>模板</code>实现功能</strong></li>
<li><strong>函数式编程：用<code>Lambda表达式</code>实现功能</strong></li>
</ul>
<h1>C++基础</h1>
<h2 id="2、变量和基本类型">2、变量和基本类型</h2>
<h3 id="2-1、变量">2.1、变量</h3>
<blockquote>
<p><strong>说明</strong>：<code>变量 == 对象</code></p>
</blockquote>
<h4 id="2-1-1、变量定义">2.1.1、变量定义</h4>
<h5 id="2-1-1-1、初始化">2.1.1.1、初始化</h5>
<p><strong>初始化的含义</strong>：创建变量时赋予其一个初始值</p>
<p><strong>赋值的含义</strong>：把对象的当前值擦除，而以一个新值来替代</p>
<blockquote>
<p><strong>注意</strong>：区分初始化和赋值，初始化不是赋值</p>
</blockquote>
<p><strong>C++中初始化对象的方式</strong>：</p>
<ul>
<li>
<p>默认初始化：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// T是类型</span></span><br><span class="line">T 对象; <span class="comment">// 不能使用 T 对象()，这是函数的声明</span></span><br><span class="line"><span class="keyword">new</span> T <span class="comment">// new创建变量</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">T</span>() <span class="comment">// 自定义类型如果有相应的默认构造函数即可</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>直接初始化：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">T 对象(实参列表); <span class="comment">// 内置数据类型都支持，并且一般支持一个参数，自定义类型如果有相应的构造函数即可</span></span><br><span class="line">T 对象(其他对象); <span class="comment">// 内置数据类型都支持，并且一般支持一个参数，自定义类型如果有相应的构造函数即可</span></span><br><span class="line">T 对象{实参列表}; <span class="comment">// 内置数据类型都支持，并且一般支持一个参数，自定义类型如果有相应的构造函数即可，另外支持聚合体的初始化</span></span><br><span class="line">T 对象 = 实参; <span class="comment">// 内置数据类型都支持，并且只支持一个参数，自定义类型如果有相应的的构造函数即可，并支持隐式类型转换</span></span><br><span class="line">T 对象 = {参数列表}; <span class="comment">// 内置数据类型都支持，并且一般支持一个参数，自定义类型如果有相应的构造函数即可，并支持隐式类型转换，另外支持聚合体的初始化</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：聚合体有如下两类：</p>
<ul>
<li>数组类型：数组、vector、array</li>
<li>满足如下条件的类类型(通常是结构体或联合体)：
<ul>
<li>没有私有或保护的非静态数据成员</li>
<li>没有用户提供的构造函数</li>
<li>没有基类</li>
<li>没有虚函数</li>
</ul>
</li>
</ul>
<p><strong>聚合体的初始化可以使用列表初始化</strong>，比如<code>int a[12] = {1, 2, 3, 4, 5};</code></p>
</blockquote>
</li>
</ul>
<p><strong>C++中提供的几种不同的初始化方式，它们之间基本是等价的，可以同时相互替换，但以下三种情况除外</strong>：</p>
<ul>
<li>使用拷贝初始化(<code>=</code>)时，只能提供一个初始值</li>
<li>如果提供的是<span id="leineichushizhihuakuohao">类内初始值</span>，只能使用拷贝初始化或使用花括号的形式初始化</li>
<li><span id="shiyongliebiaochushihua">如果提供的是初始元素值的列表，只能把初始值都放在<strong>花括号</strong>里进行列表初始化，不能放在圆括号里</span></li>
</ul>
<h5 id="2-1-1-2、列表初始化">2.1.1.2、列表初始化</h5>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = {<span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> units_sold{<span class="number">0</span>};</span><br></pre></td></tr></tbody></table></figure>
<p>当用于内置类型的变量时，<strong>如果使用列表初始化且初始值存在丢失信息的风险，编译器将报错，<code>int a{3.1415}, int b = {3.1415}</code></strong></p>
<h5 id="span-id-morenchushihua-2-1-1-3、默认初始化-span"><span id="morenchushihua">2.1.1.3、默认初始化</span></h5>
<p>内置类型变量的默认初始化的初始值<strong>由定义的位置决定</strong>：</p>
<ul>
<li>全局变量初始化为0，局部静态变量初始化为0</li>
<li>定义在函数体内部的内置类型变量将不被初始化，未被初始化的内置类型变量的值是<strong>未定义</strong>的，对此操作会引发错误</li>
</ul>
<p><strong>每个类各自决定其初始化对象的方式</strong>。</p>
<h5 id="2-1-1-4、变量声明和定义的关系">2.1.1.4、变量声明和定义的关系</h5>
<p>变量声明规定了变量的类型和名字，<strong>定义还申请存储空间</strong>，也可以为变量赋初始值。</p>
<p><strong>声明而非定义</strong>变量：<code>extern 类型 变量名</code></p>
<p><strong>定义变量</strong>：<code>类型 变量名 [ = 初始值 ]</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明而非定义i</span></span><br><span class="line"><span class="keyword">int</span> j; <span class="comment">// 声明并定义j</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//声明并定义初始化k</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>声明而非定义变量时，<strong>一定不能显示地初始化变量</strong></li>
<li>任何包含了显示初始化的声明即成为定义，<code>extern int j = 0;</code>也是定义</li>
<li>在函数体内部，如果初始化一个由<code>extern</code>标记的变量，将引发错误</li>
<li>变量只能被定义一次，但可以被声明多次</li>
</ul>
</blockquote>
<h3 id="2-2、复合类型">2.2、复合类型</h3>
<h4 id="2-2-1、引用">2.2.1、引用</h4>
<p><strong>引用</strong>：为<code>对象</code>起别名</p>
<p>一般初始化变量时，初始值会被拷贝到新建的对象中。<strong>定义引用时，程序把引用和初始值<code>绑定</code>在一起</strong>，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起，因此<strong>无法令引用重新绑定到另外一个对象，引用必须初始化</strong></p>
<p>对引用的一切操作，都是对引用所绑定对象的操作</p>
<p>允许在一条语句中定义多个引用，<code>每个</code><strong>引用标识符都必须以&amp;开头</strong></p>
<p><span id="yinyongdechushihuaguize">除了以下两种特殊情况</span>，其他所有<strong>引用的类型都要和与之绑定的对象<code>严格匹配</code>，而且只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</strong></p>
<ul>
<li>
<p>常量引用：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> r = <span class="number">34.45</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = r; <span class="comment">// 正确：引用类型与绑定对象类型不一致，同时引用是const类型的，对象是普通类型，ri的值为34</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;si = <span class="number">43</span>; <span class="comment">// 正确：引用与字面值绑定</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>在继承关系中，可以把基类的指针或引用绑定到派生类对象上。</p>
</li>
</ul>
<p><strong>引用本身不是一个对象</strong>，不能定义引用的引用</p>
<h4 id="2-2-2、指针">2.2.2、指针</h4>
<p><strong>指针与引用的区别</strong>：</p>
<ul>
<li>指针本身就是一个<code>对象</code>，允许对指针赋值和拷贝，而且在指针的生命周期内可以<strong>先后指向几个不同的对象</strong></li>
<li>指针<strong>无须在定义时赋初值</strong>，在块作用域内定义的指针如果没有被初始化，将拥有一个<strong>不确定</strong>的值</li>
</ul>
<p>允许在一条语句中定义多个指针变量，<code>每个</code><strong>变量前面都必须有符号*</strong></p>
<p>指针存放某个<code>对象</code>的地址，<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>因为引用不是对象，没有实际地址，不能定义指向引用的指针<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，但指针是对象，存在对指针的引用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">// r是对指针p的引用  </span></span><br><span class="line">r = &amp;i; <span class="comment">// 正确</span></span><br><span class="line">*r = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>Tips</strong>：对于上例中多重指针和引用的r，从<code>右往左阅读</code>，<strong>离变量最近的<code>符号</code>(&amp;)对变量的类型有最直接的影响</strong>，因此r是一个引用，<strong>声明符的其余部分用以确定<code>&amp;r</code>的类型</strong>，符号*说明r引用是一个指针，int指出r引用是一个int指针</p>
</blockquote>
<p>除了以下两种特殊情况，其他所有<strong>指针的类型都要和与之指向的对象</strong><code>严格匹配</code>：</p>
<ul>
<li>
<p>常量指针、指向常量的指针</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> r = <span class="number">34.45</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *ri = &amp;r; <span class="comment">// 正确：指针类型与指向对象类型不一致，指针是const类型的，对象是普通类型</span></span><br><span class="line"><span class="keyword">double</span> *<span class="keyword">const</span> p = &amp;r; <span class="comment">// 正确：</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>在继承关系中，可以把基类的指针或引用绑定到派生类对象上。</p>
</li>
</ul>
<p>解引用操作仅适用于<strong>确实指向了某对象的有效指针</strong></p>
<p><strong>空指针</strong>的定义方法：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">// 字面值nullptr可以转换成任意其他类型的指针类型，C++11引入的</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>; <span class="comment">// 字面值0</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">// 从C语言引入的，需要包含头文件cstdlib</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>void*</code>可以存放任意对象的地址，<strong>不能直接操作<code>void*</code>指针所指的对象，需要转换成已知类型的指针</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *arr = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>通过<code>*</code>的个数可以区分指针的级别，<code>**</code>表示指向指针的指针，<code>***</code>表示指向指针的指针的指针</p>
<h3 id="2-3、处理类型">2.3、处理类型</h3>
<h4 id="2-3-1、类型别名">2.3.1、类型别名</h4>
<p><strong>普通类型别名</strong>定义的方式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages; <span class="comment">// wages是double的同义词</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI是Sales_item的同义词</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>指针的类型别名</strong>定义的方式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring; <span class="comment">// pstring是char*的同义词</span></span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">// cstr的类型是常量的指针，而不是说cstr是一个常量指针，pstring是一个指针，const pstring就是常量的指针</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">const</span> pstring p = &amp;a;</span><br><span class="line"><span class="keyword">const</span> pstring *ps = &amp;p; <span class="comment">// ps是一个指针，ps所指向的对象是一个指向const char指针类型的指针</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注意</strong>：<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>此处不能理解成<code>const char *cstr = 0</code>，pstring的基本类型是<strong>指针</strong>，如果是<strong>char *</strong>，*成为声明符的一部分，<strong>const char</strong>成为基本数据类型。</p>
</blockquote>
<h4 id="2-3-2、auto类型说明符">2.3.2、auto类型说明符</h4>
<p><code>auto</code>让编译器通过初始值来推算变量的类型，所以<strong>auto定义的变量必须有初始值</strong></p>
<p>当<code>引用</code>被用来初始化<code>auto</code>变量时，编译器会<strong>以引用对象的类型作为auto的类型</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a的类型是i的类型</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>auto</code>会忽略<strong>顶层const</strong>，<strong>底层const</strong>会保留下来，如果希望推断出的auto的类型是一个<strong>顶层const，需要明确指出const</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b是一个整数，ci的顶层const被忽略</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c是一个整数，cr是ci的别名，ci是顶层const被忽略，对于cr来说是底层const，但此处是使用引用cr，实际使用的就是被引用对象本身，要区分开cr的定义还是使用</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">// &amp;i是一个地址，d是一个指针</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci; <span class="comment">// ci是一个常量，&amp;ci是指向常量的指针，是底层const，e是一个指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci; <span class="comment">// 明确指定顶层const类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将引用的类型设为auto</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci; <span class="comment">// g是一个整形常量引用</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><span id="shangyijiedeshuomingzhongdeliwai"><strong>说明</strong></span>：<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>引用从来都是作为<strong>其所指对象的同义词</strong>出现(<strong>可以直接看作所指对象</strong>)，在decltype中有一个<a href="#decltypedetelidifang">例外</a></p>
</blockquote>
<h4 id="2-3-3、decltype类型指示符">2.3.3、decltype类型指示符</h4>
<p><code>decltype</code>：选择并返回操作数的数据类型，在此过程中，编译器分析表达式并得到它的类型，<strong>却不实际计算表达式的值</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x; <span class="comment">// sum的类型是f()的返回类型</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果表达式是一个<code>变量</code>，<code>decltype</code>返回变量的类型(<strong>包括顶层const和引用在内</strong>)</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// ci的类型是const int，x的类型也是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// cj的类型是const int &amp;，y的类型也是const int &amp;，此处和通常情况情况不一样，一般引用在使用时，使用是被引用对象本身，此处不是</span></span><br></pre></td></tr></tbody></table></figure>
<p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span id="decltypedetelidifang">上例</span><code>decltype(cj) y = x;</code>就是<a href="#shangyijiedeshuomingzhongdeliwai">上一节的说明中说的例外</a></p>
<p>如果表达式是一个<code>表达式</code>，<code>decltype</code>返回表达式结果对应的类型，有些表达式将返回引用类型作为左值使用，<strong><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>注意下例中的3种特殊情况<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="comment">// 对应使用引用的特殊的情况，r是引用，decltype的结果就是引用，a的类型是int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(r) a = i; </span><br><span class="line"><span class="comment">// 特殊情况一</span></span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">// 正确：r+0表达式的结果是一个整形数值，所以decltype的结果是int</span></span><br><span class="line"><span class="comment">// 特殊情况二</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">// 错误：decltype(*p)的结果是int&amp;，c需要赋初值</span></span><br><span class="line"><span class="comment">// 特殊情况三</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">// 错误：d是int&amp;，必须初始化</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>特殊情况一：如果想让结果类型是<code>r</code>所指的类型<code>int</code>，可以把<code>r</code>作为表达式的一部分，如<code>r + 0</code>，这样表达式的结果就是一个具体值而非一个引用</li>
<li>特殊情况二：如果表达式的内容是<code>解引用操作</code>，则<strong>decltype将得到引用类型</strong>，因为解引用指针可以得到指针指向的对象，可以给该对象进行赋值，是一个左值</li>
<li>特殊情况三：如果<code>decltype</code>使用的是不加括号的变量，得到的结果就是该变量的类型；如果<strong>给<code>变量</code>加上一层或多层括号</strong>，编译器会把它当作一个<strong>表达式</strong>，<code>decltype</code>返回的结果是<code>引用类型</code></li>
</ul>
<h3 id="2-4、const限定符">2.4、const限定符</h3>
<h4 id="2-4-1、初始化和const">2.4.1、初始化和const</h4>
<p>const对象一旦创建后其值就不能再改变，<strong>const对象必须初始化</strong></p>
<p>只能在const类型的对象上执行<strong>不改变其内容</strong>的操作</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">43</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i; <span class="comment">// const变量初始化没有限制，变量或者常量都可以</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>默认状况下，const对象仅在文件内有效</strong>，当需要在多个文件间使用同一个<code>const变量</code>时，对于const变量<strong>不管是声明还是</strong><code>定义</code>都添加<code>extern</code>关键字</p>
<h4 id="2-4-2、const的引用">2.4.2、const的引用</h4>
<p><strong>对常量的引用(常量引用)</strong>：将<strong>引用</strong>绑定到<strong>const对象</strong>上，对常量的引用不能被用作<strong>修改它所绑定的对象</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">43</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;rl = ci;</span><br></pre></td></tr></tbody></table></figure>
<p>对于<strong>普通引用</strong>只能用与其所引用对象一致的类型进行初始化</p>
<p>对于<strong>常量引用</strong>，在初始化时允许用<strong>任意表达式</strong>作为初始值，只要该表达式的结果能转换成引用的类型即可，尤其允许一个常量引用绑定<strong>非常量</strong>的对象、字面值或表达式，这种情况的实现原理如下：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br><span class="line"><span class="comment">// 内部实现原理</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval; <span class="comment">// 由浮点数生成一个临时的整型常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;  <span class="comment">// 让ri绑定这个临时量</span></span><br><span class="line"><span class="comment">// 如果ri不是常量引用的话，就可以通过ri去修改临时量temp，是没有意义的。</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>常量的引用仅仅对<strong>引用可参与的操作</strong>做出了限定(<code>不可以通过引用修改被引用的对象</code>)，对于<strong>引用的对象本身</strong>是不是一个常量未作限定</li>
<li>引用不是对象</li>
</ul>
</blockquote>
<h4 id="2-4-3、const和指针">2.4.3、const和指针</h4>
<p><strong>指向常量的指针</strong>：与常量引用类似，不能用于改变其所指对象的值</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *ptr = &amp;pi; </span><br></pre></td></tr></tbody></table></figure>
<p><strong>指针是对象，引用不是对象，允许把指针本身定为常量</strong></p>
<p><strong>常量指针</strong>必须初始化，而且一旦初始化完成，它的值(<strong>存放在指针中的那个地址</strong>)就不能再改变了。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 把*放在const关键字之前用以说明指针是一个常量</span></span><br><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;</span><br><span class="line"><span class="comment">// 从右向左读，可以弄清声明的含义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;</span><br><span class="line"><span class="comment">// 从右往左读，第一个声明符是const，表明pip是一个常量对象</span></span><br><span class="line"><span class="comment">// 对象的类型由声明符的其他部分确定，const double *说明pip是一个指向double类型常量的指针</span></span><br><span class="line"><span class="comment">// 总的来说：pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li><strong>指向常量的指针</strong>仅仅对<strong>指针可参与的操作</strong>做出了限定(<code>不可以通过指针修改被指向的对象</code>)，对于<strong>指针指向的对象本身</strong>是不是常量未作限定</li>
<li><strong>常量指针</strong>说明指针本身是常量，并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于<strong>所指对象</strong>的类型</li>
<li>注意区分<code>指向常量的指针</code>和<code>常量指针</code></li>
</ul>
</blockquote>
<h4 id="2-4-4、顶层const">2.4.4、顶层const</h4>
<p>指针本身是一个对象，又可以指向另一个对象，对于<strong>指针</strong>来说：</p>
<ul>
<li><strong>顶层const</strong>：指针本身是常量</li>
<li><strong>底层const</strong>：指针所指向的对象是常量</li>
</ul>
<p>更一般的结论：</p>
<ul>
<li><strong>顶层const</strong>：使得<strong>被修饰的</strong><code>变量本身</code>无法改变的const</li>
<li><strong>底层const</strong>：其他的通过指针或引用等<code>间接途径</code>来限制目标内容不可变的const，<strong>常量引用都是底层const</strong></li>
</ul>
<p><strong>当执行对象的拷贝操作时，拷入拷出的对象必须具有相同的</strong> <span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><code>底层const资格</code>或者<span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><code>两个对象的数据类型能够转换</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;  <span class="comment">// ci是顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci;  <span class="comment">// 指向常量的指针，底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">// p3是底层const、顶层const，</span></span><br><span class="line"><span class="keyword">int</span> *p = p3; <span class="comment">// 错误：p3包含底层const，而p没有，违背第1点</span></span><br><span class="line">p2 = p3; <span class="comment">// 正确：p2和p3都包括底层const</span></span><br><span class="line">p2 = &amp;i; <span class="comment">// 正确：p2和&amp;i都不包含底层const，但是&amp;i可以转换成const int *类型</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = ci; <span class="comment">// 错误：普通的int&amp;不能绑定到int常量上，const int不能转化成int，违背第2点</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-5、constexpr和常量表达式">2.4.5、constexpr和常量表达式</h4>
<p><strong>常量表达式</strong>：值不会改变并且在<strong>编译过程</strong>就能得到计算结果的表达式</p>
<p><strong>一个对象(或表达式)是不是常量表达式由<code>数据类型</code>和<code>初始值</code>共同决定</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files = <span class="number">20</span>; <span class="comment">// 是</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max_files + <span class="number">1</span>; <span class="comment">// 是</span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>; <span class="comment">// 不是，staff_size值可以发生改变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = <span class="built_in">get_size</span>(); <span class="comment">// 不是，get_size()在编译过程不能确定</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong><code>constexpr</code>变量一定是常量，必须用<code>常量表达式</code>初始化</strong></p>
<p><em>算数类型、引用和指针都属于字面值类型</em>，<strong>一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或<code>0</code>或<code>存储于某个固定地址中的对象</code>(全局变量、局部静态变量的地址)，一个<code>constexpr</code>引用的初始值必须是<code>某个固定地址中的对象</code></strong></p>
<p><code>constexpr</code>仅对指针有效，与指针所指的对象无关，<strong>constexpr把它所定义的对象置为<code>顶层const</code>，所以constexpr指针既可以指向常量也可以指向非常量</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>; <span class="comment">// p为指向常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">// q为常量指针</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">24</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = &amp;j; <span class="comment">// 指向非常量对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> z = <span class="number">34</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *zr = &amp;z; <span class="comment">// 指向常量对象 const int</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：<span id="zimianzhileixingdedingyi"><code>字面值类型</code></span>是指<strong>编译时就能得到结果的类型</strong>，具体包括算术类型(整形、字符型、布尔类型、浮点型)、引用和指针，自定义类、IO库、string类型不属于该类型。</p>
</blockquote>
<h2 id="3、字符串、向量和数组">3、字符串、向量和数组</h2>
<h3 id="3-1、命名空间">3.1、命名空间</h3>
<h4 id="3-1-1、命名空间定义">3.1.1、命名空间定义</h4>
<p>定义形式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 命名空间的名字 {</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 只要是能出现在全局作用域中的声明就能置于命名空间内，主要包括：</span></span><br><span class="line"><span class="comment">     * 类、变量、函数、模板、其他命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">} <span class="comment">// 没有;</span></span><br></pre></td></tr></tbody></table></figure>
<p>命名空间的名字必须在定义它的作用域内保持<strong>唯一</strong>，<strong>命名空间不能定义在函数或类的内部</strong></p>
<p>定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问，<strong>类似于外层作用域中的全局变量和内层作用域中的局部变量</strong>；位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间</p>
<p><strong>命名空间可以不连续</strong>，该特性使得<strong>将几个独立的接口和实现文件组成一个命名空间</strong>，此时命名空间的组织方式类似于自定义类及函数的方式：</p>
<ul>
<li>命名空间的一部分的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中</li>
<li>命名空间成员的定义部分则至于另外的源文件中</li>
</ul>
<p>在程序中某些实体只能<strong>定义</strong>一次，但可以<strong>声明多次</strong>：如<strong>非内联函数、静态数据成员、变量</strong>等，<strong>命名空间中定义的名字也需要满足这一要求</strong>，可以通过上面的方式组织命名空间并达到目的；这种接口和实现分离的机制确保我们所需的<strong>函数和其他名字只定义一次</strong>，而只要是用到这些实体的地方都能看到对于实体名字的<strong>声明</strong></p>
<p><strong>位于头文件的代码一般来说不应该使用<code>using</code>声明</strong>，因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个<code>using</code>声明，那么每个使用了该文件的文件就都会有这个声明，对于某些程序来说，由于不经意间包含了一个名字，反而可能产生始料未及的名字冲突</p>
<p><strong>不能把<code>#include</code>放在命名空间中</strong></p>
<blockquote>
<p><strong>说明</strong>：如果在头文件中使用命名空间，在命名空间中只进行相关变量和函数的声明，不能是定义</p>
</blockquote>
<p>假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一命名空间定义的名字的简写形式(不需要加前缀)；也可以在命名空间定义的外部定义该命名空间的成员；命名空间对于名字的<strong>声明必须在作用域内</strong>，同时该名字的<strong>定义需要明确指出其所属的命名空间</strong>；和定义在类外部的类成员一样，<strong>一旦看到含有完整前缀的名字，就可以确定该名字位于命名空间的作用域内，可以直接使用命名空间中的成员，但对于函数的返回值需要指定前缀</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cplusplus_primer::Sales_data cplusplus_primer::<span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data&amp; lhs, <span class="keyword">const</span> Sales_data&amp; rhs) { }</span><br></pre></td></tr></tbody></table></figure>
<p>尽管命名空间的成员可以定义在命名空间的外部，<strong>但是这样的定义必须出现在所属命名空间的<code>外层空间</code>中，不能在一个不相关的作用域中定义这个运算符</strong></p>
<h5 id="3-1-1-1、全局命名空间">3.1.1.1、全局命名空间</h5>
<p>全局命名空间以<code>隐式</code>的方式声明，并且在所有程序中都存在，全局作用域中定义的名字被隐式地添加到全局命名空间中</p>
<p>可以直接通过<code>::</code>使用全局作用域的成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">::member_name</span><br></pre></td></tr></tbody></table></figure>
<h5 id="3-1-1-2、嵌套的命名空间">3.1.1.2、嵌套的命名空间</h5>
<p><strong>内层</strong>命名空间声明的名字将<strong>隐藏外层</strong>命名空间声明的<strong>同名成员</strong>，在嵌套的命名空间中定义的名字只在内层命名空间中有效，<strong>外层命名空间中的代码要想访问它必须在名字前添加限定符(和全局作用域中不能使用局部作用域中的变量不同)</strong>(只能使用前面的内层命名空间中声明的成员)</p>
<h5 id="3-1-1-3、内联命名空间">3.1.1.3、内联命名空间</h5>
<p>内联命名空间中的名字可以被外层命名空间<strong>直接</strong>使用，无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它</p>
<p>在关键字<code>namespace</code>前添加关键字<code>inline</code>定义内联命名空间，<code>inline</code>必须出现在命名空间<code>第一次定义</code>的地方，后续再打开命名空间的时候可以写也可以不写<code>inline</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> FifthEd {</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="keyword">namespace</span> FifthEd { <span class="comment">// 隐式内联</span></span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="3-1-1-4、未命名的命名空间">3.1.1.4、未命名的命名空间</h5>
<p><strong>未命名的命名空间中定义的变量拥有<code>静态</code>生命周期</strong>，它们在第一次使用前创建，并且直到程序结束才销毁</p>
<p>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件；每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关，在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体；<strong>如果一个头文件中定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体</strong></p>
<p>定义在未命名的命名空间中的名字可以<strong>直接使用</strong></p>
<p><strong>未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同</strong>，如果定义在最外层作用域中，该空间的成员名字一定要与全局作用域中的名字有所区别；一个未命名的命名空间也能嵌套在其他命名空间中，其中的成员可以<strong>通过外层命名空间的名字来访问</strong></p>
<h4 id="3-1-2、命名空间的使用">3.1.2、命名空间的使用</h4>
<h5 id="3-1-2-1、命名空间的别名">3.1.2.1、命名空间的别名</h5>
<p>别名的形式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> 别名 = 命名空间名;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>不能在命名空间还没有定义前就声明别名</strong></p>
<h5 id="3-1-2-2、using声明">3.1.2.2、using声明</h5>
<p>一条<code>using</code>声明语句中<strong>一次只引入命名空间的一个成员</strong>，<code>using</code>声明引入的名字的有效范围：<strong>从<code>using</code>声明的地方开始，一直到<code>using</code>声明所在的作用域结束为止</strong>；在此过程中，外层作用域的同名实体将被隐藏，未限定的名字只能在<code>using</code>声明所在的作用域以及其内层作用域中使用，在有效作用域结束后，必须使用完整的经过限定的名字</p>
<p>一条<code>using</code>声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中，在类的作用域中，<code>using</code>声明语句<strong>只能指向基类成员</strong></p>
<p><code>using</code><strong>声明的名字的作用域与<code>using</code>声明语句本身所在的作用域一致，好像<code>using</code>声明语句为命名空间的成员在当前作用域内创建了一个别名</strong></p>
<h5 id="3-1-2-3、using指示">3.1.2.3、using指示</h5>
<p><code>using</code>指示必须<strong>使用已经定义好的命名空间的名字</strong>，<code>using</code>指示 可以出现在全局作用域、局部作用域、命名空间中，<strong>但不能出现在类的作用域中</strong></p>
<p><code>using</code>指示具有将命名空间成员提升到<strong>同时包含命名空间本身和<code>using</code>指示的最近作用域</strong>，此时会导致二义性冲突，这种冲突是允许存在的，但要想使用必须明确指出名字的版本</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> test4{</span><br><span class="line">	<span class="keyword">int</span> i;                         <span class="comment">//位置1</span></span><br><span class="line">	<span class="keyword">namespace</span> my{</span><br><span class="line">		<span class="keyword">namespace</span> my1{</span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">2</span>;             <span class="comment">//位置2</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">namespace</span> myfun{</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>{</span><br><span class="line">			<span class="keyword">using</span> <span class="keyword">namespace</span> my::my1; <span class="comment">// 同时包含命名空间和using指示的作用域是test4作用域</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">"hello:"</span> &lt;&lt; i; <span class="comment">// 产生二义性</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">"hello:"</span> &lt;&lt; my::my1::i;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-1-3、类、命名空间与作用域">3.1.3、类、命名空间与作用域</h4>
<p>对命名空间内部名字的查找遵循常规的查找规则：由内向外依次查找每个外层作用域，外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止，只有位于开放的块中且在<strong>使用点之前</strong>声明的名字才被考虑</p>
<p><strong>当给函数传递一个<code>类类型</code>的对象时，除了在常规的作用域查找外还会查找</strong><code>实参类所属的命名空间</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span>&lt;&lt;(std::cin, s); <span class="comment">// 首先在当前作用域查找operator&lt;&lt;函数，然后在外层作用域查找，最后在实参cin，s所在的命名空间std中查找</span></span><br></pre></td></tr></tbody></table></figure>
<p>一个另外的未声明的类或函数如果第一次出现在友元声明中，则认为它是最近的外层命名空间的成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A {</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> {</span></span><br><span class="line">        <span class="comment">// 这些函数隐式地成为命名空间A的成员</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    A::C cobj;</span><br><span class="line">    <span class="built_in">f</span>(cobj); <span class="comment">// 根据cobj实参所属类的命名空间查找</span></span><br><span class="line">    <span class="built_in">f2</span>(); <span class="comment">// 找不到    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-1-4、重载与命名空间">3.1.4、重载与命名空间</h4>
<p>对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行，那么<strong>将在<code>每个实参类以及实参类的基类</code>所属的命名空间中搜寻候选函数</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS {</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Quote</span> {</span>};</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> Quote&amp;)</span> </span>{}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_item</span> :</span> <span class="keyword">public</span> NS::Quote {}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Bulk_item book1;</span><br><span class="line">    <span class="built_in">display</span>(book1); <span class="comment">// 搜查Bulk_item和Quote类所在命名空间的相关成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>using</code>声明语句声明的只是一个<code>名字</code>，而非一个特定的函数，使用<code>using</code>声明一个函数时，<strong>该函数的所有版本都被引入到当前的作用域中</strong></p>
<p>一个<code>using</code>声明引入的函数将<code>重载</code><strong>该声明语句所属作用域中已有的其他同名函数</strong>，如果<code>using</code>声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明；如果<code>using</code>声明所在的作用域中已经有一个函数与新引入的函数<strong>同名且形参列表相同</strong>，则该<code>using</code>声明将引发错误；</p>
<p><code>using</code>指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中；和<code>using</code>声明不同的是，对于<code>using</code>指示来说，<strong>引入一个与已有函数形参列表相同的函数并不会产生错误</strong>，只要指明调用的是命名空间中的函数版本还是当前作用域的版本即可</p>
<h3 id="3-2、标准库类型string">3.2、标准库类型string</h3>
<h4 id="3-2-1、定义和初始化string对象">3.2.1、定义和初始化string对象</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string s; <span class="comment">// 默认构造：生成空的string s</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str)</span></span>; <span class="comment">// 拷贝构造：创建string str的拷贝</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(rvstr)</span></span>; <span class="comment">// 移动构造：将rvstr的内容搬移到创建的string s中</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, stridx)</span></span>; <span class="comment">// 将string str内始于stridx到结尾的部分作为s的初值 </span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str, stridx, strlen)</span></span>; <span class="comment">// 将string str内始于stridx，长度为strlen的部分作为s的初值 </span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cstr)</span></span>; <span class="comment">// 以C语言字符串初始化， const char *</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(chars, charslen)</span></span>; <span class="comment">// 以字符数组前charslen字符初始化</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(num, c)</span></span>; <span class="comment">// 生成一个字符串，包含num个c字符</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(beg, end)</span></span>; <span class="comment">// 以[begin, end)区间内的字符作为字符串s的初始值</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(initlist)</span></span>; <span class="comment">// 以列表中的字符初始化s</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-2-2、string对象上的操作">3.2.2、string对象上的操作</h4>
<h5 id="3-2-2-1、构建string的其他方法">3.2.2.1、构建string的其他方法</h5>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208000432730.png" alt="image-20211208000432730"></p>
<h5 id="3-2-2-2、改变string的其他方法">3.2.2.2、改变string的其他方法</h5>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208000751058.png" alt="image-20211208000751058"></p>
<p>除了接受迭代器的insert和erase版本外，string还提供了接受<code>下标</code>的版本</p>
<p><code>append</code>可以在string的末尾追加<strong>字符串、string等</strong>，而<code>push_back</code>只能追加<code>char</code>字符元素</p>
<p><code>replace</code>操作是调用<code>erase和insert</code>的一种简写形式</p>
<p><code>assign</code>函数无须指定要替换string中哪个部分，<code>assign</code>总是替换string中的<strong>所有内容</strong></p>
<h5 id="3-2-2-3、string搜索操作">3.2.2.3、string搜索操作</h5>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208001635813.png" alt="image-20211208001635813"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208001818220.png" alt="image-20211208001818220"></p>
<h5 id="3-2-2-4、compare函数">3.2.2.4、compare函数</h5>
<p><code>compare</code>是string类的<strong>成员函数</strong>，用法和<code>strcmp</code>一致</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208002255808.png" alt="image-20211208002255808"></p>
<h5 id="3-2-2-5、数值操作-非成员函数">3.2.2.5、数值操作(非成员函数)</h5>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208002505183.png" alt="image-20211208002505183"></p>
<p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符，可以是<code>+/-/.</code>或者<code>数字</code>，可以包含<code>e/E</code>来表示指数部分</p>
<h5 id="3-2-2-6、其他操作">3.2.2.6、其他操作</h5>
<p><code>getline(is, s)</code>函数从给定的输入流<code>is</code>中读入内容，直到遇到<code>换行符</code>为止(<strong>换行符也被读进来了</strong>)，然后将所读的内容存放到s中(<strong>不存换行符</strong>)；<code>getline</code>只要一遇到换行符就结束读取操作并返回结果。<code>getline</code>函数的返回<strong>它的流参数</strong></p>
<p><code>string::size_type</code>是一个<strong>无符号类型</strong>的值</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type</span><br></pre></td></tr></tbody></table></figure>
<p>当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须<strong>确保每个加号运算符的两侧的运算对象<code>至少</code>有一个时string</strong></p>
<blockquote>
<p><strong>注意</strong>：区分string和字符串字面值，字符串字面值是<code>const char *</code>类型的，字符串字面值类型能转换成string类型，反之不行</p>
</blockquote>
<h3 id="3-3、标准库类型vector">3.3、标准库类型vector</h3>
<p>vector的元素必须是对象，引用不是对象，元素不能是引用</p>
<h4 id="3-3-1、定义和初始化vector对象">3.3.1、定义和初始化vector对象</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;T&gt; c; <span class="comment">// 默认构造函数：空的vector，没有任何元素</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">c</span><span class="params">(c2)</span></span>; <span class="comment">// 拷贝构造函数：</span></span><br><span class="line">vector&lt;T&gt; c = c2; <span class="comment">// </span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">c</span><span class="params">(rv)</span></span>; <span class="comment">// 移动构造函数：</span></span><br><span class="line">vector&lt;T&gt; c = rv; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">c</span><span class="params">(n)</span></span>; <span class="comment">// 利用元素的default构造函数生成一个大小为n的vector </span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">c</span><span class="params">(n, elem)</span></span>; <span class="comment">// 建立一个带下为n的vector，每个元素值都是elem</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">c</span><span class="params">(beg, end)</span></span>; <span class="comment">// 以区间[beg,end)的元素初始化vector c</span></span><br><span class="line">vector&lt;T&gt; c{initlist}; <span class="comment">// 以初始化列表初始化vector c，只能使用花括号，不能使用圆括号</span></span><br><span class="line">vector&lt;T&gt; c = {initlist}; <span class="comment">//</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果<a href="#shiyongliebiaochushihua">使用<code>列表</code>初始化</a>，只能将初始值都放在<code>花括号</code>里进行列表初始化，而不能放在圆括号里</p>
<p>如果只提供元素的数量而没有设定初始值，只能使用<code>直接初始化</code>，是因为相应的构造函数是<code>explicit</code>的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">( size_type count, <span class="keyword">const</span> T&amp; value = T(), <span class="keyword">const</span> Allocator&amp; alloc = Allocator())</span></span>; </span><br></pre></td></tr></tbody></table></figure>
<p>如果用的是圆括号，一般提供的值是用来**构造(调用相关的构造函数)**对象的</p>
<p>如果用的花括号，一般是用列表初始化对象</p>
<p>对于vector类型来说，如果<strong>初始化时使用花括号</strong>的形式但是<strong>提供的值又不能用来列表初始化</strong>，就要<strong>考虑用这样的值来构造vector对象</strong>，<code>只能{}转化为()使用，反之不行</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v5{<span class="string">"hi"</span>}; <span class="comment">// 列表初始化，构造一个元素</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v6</span><span class="params">(<span class="string">"hi"</span>)</span></span>; <span class="comment">// 错误</span></span><br><span class="line">vector&lt;string&gt; v7{<span class="number">10</span>}; <span class="comment">// 此处相当于 v7(10), v7有10个默认初始化的元素</span></span><br><span class="line">vector&lt;string&gt; v8{<span class="number">10</span>, <span class="string">"hi"</span>}; <span class="comment">// 此处相当于 v8(10, "hi")</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-3-2、vector对象上的操作">3.3.2、vector对象上的操作</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>如果循环体内部包含有<strong>向vector对象添加元素</strong>的语句，不能使用<strong>范围for循环</strong>，<strong>范围for循环语句内不应改变其遍历序列的大小</strong></p>
<p>使用vector类型的<code>size_type</code>时要指定作用域<code>vector&lt;type&gt;::size_type</code>，需要指定是由那种类型定义的，需要指明vector对象的类型</p>
<p>不能通过<code>下标</code>添加vector对象，vector对象的下标运算符可用于访问<strong>已存在</strong>的元素，而不能用于添加元素</p>
<h3 id="3-4、迭代器">3.4、迭代器</h3>
<p>迭代器都包含<code>begin</code>和<code>end</code>两个成员：</p>
<ul>
<li><code>begin</code>：指向第一个元素的迭代器</li>
<li><code>end</code>：指向容器<code>尾元素的下一个位置</code></li>
</ul>
<h3 id="3-5、数组">3.5、数组</h3>
<h4 id="3-5-1、定义和初始化内置数组">3.5.1、定义和初始化内置数组</h4>
<p>数组中元素的个数属于数组的一部分，<strong>编译的时候维度应该是已知的</strong>，维度必须是一个常量表达式</p>
<p>定义数组时，不允许用<code>auto</code>关键字由初始值的列表推断类型，数组的元素应为对象，不存在引用的数组</p>
<p>可以对数组的元素进行<code>列表初始化</code>，此时允许忽略掉数组的维度</p>
<p><strong>字符数组</strong>还可以用<code>字符串字面值</code>初始化，字符串字面值结尾的<code>\0</code>也会拷贝到字符数组中</p>
<p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p>
<p><strong>默认情况下，类型修饰符从右向左依次绑定，对于数组而言，由内向外阅读更合适</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">// 从右向左读：ptrs[10]是一个数组，数组元素的类型是int*</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*Parray)[<span class="number">10</span>]; <span class="comment">// 从内向外读：*Parray是一个指针，指针类型是int[10]</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-5-2、访问数组元素">3.5.2、访问数组元素</h4>
<p>数组也可以使用<code>范围for</code>语句</p>
<h4 id="3-5-3、指针和数组">3.5.3、指针和数组</h4>
<p>在很多用到<strong>数组名字</strong>的地方，编译器都会自动地将其替换为<strong>一个指向数组<code>首元素</code>的指针</strong>，但<a href="#sizeofshuzu">sizeof(数组名)</a>除外</p>
<p>当使用数组作为一个<code>auto</code>变量的初始值时，推断得到的类型是指针而非数组</p>
<p>当使用<code>decltype</code>时，推断得到的是数组，不会将数组名转换为指针</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>};</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>; <span class="comment">// ia转化为指针，指向数组ia的第一个元素, ia2是一个指针</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>}; <span class="comment">// ia3是一个数组，int[6]类型的数组</span></span><br></pre></td></tr></tbody></table></figure>
<p>指针也是迭代器</p>
<p>标准库提供<code>begin</code>和<code>end</code>函数，这两个函数不是成员函数，使用时需要将数组作为其参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ai[] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ai);</span><br><span class="line"><span class="keyword">int</span> *end = <span class="built_in">end</span>(ai);</span><br></pre></td></tr></tbody></table></figure>
<p>两个指针相减的结果的类型是一种名为<code>ptrdiff_t</code>的标准库类型，<code>ptrdiff_t</code>是一种<strong>带符号</strong>类型</p>
<p>只要指针指向数组中的元素(或者数组中尾元素的下一个位置)，都可以执行下标运算，此时的下标允许是<code>负数</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">0</span>]; <span class="comment">// k = ia[2]</span></span><br><span class="line"><span class="keyword">int</span> l = p[<span class="number">-2</span>]; <span class="comment">// l = ia[0]</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-5-4、C风格字符串">3.5.4、C风格字符串</h4>
<p>如果需要<strong>C风格字符串</strong>，无法直接使用<strong>string</strong>对象来代替它；string提供一个名为<code>c_star</code>的成员函数，该函数的返回值是一个C风格的字符串，是一个<code>const char *</code>类型的指针；如果执行完<code>c_str()</code>函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份</p>
<h4 id="3-5-5、多维数组">3.5.5、多维数组</h4>
<p>使用范围for语句处理多维数组，<strong>除了<code>最内层</code>的循环外，其他所有循环的控制变量都应该使用引用</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;row : ia) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row) {</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4、表达式">4、表达式</h2>
<h3 id="4-1、类型转换">4.1、类型转换</h3>
<h4 id="4-1-1、隐式转换">4.1.1、隐式转换</h4>
<p><strong>算术类型之间的隐式转换被设计得尽可能<code>避免损失精度</code></strong></p>
<h4 id="4-1-2、显式转换">4.1.2、显式转换</h4>
<h5 id="4-1-2-1、static-cast">4.1.2.1、static_cast</h5>
<p><strong>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</strong></p>
<p>static_cast的类型转换是在<code>编译期间转换</code>的</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>原有的自动类型转换，比如<code>int → double</code></li>
<li><code>void*</code>指针和具体类型指针之间的转换，比如<code>void* → int*</code></li>
<li>有<code>转换构造函数</code>或者<code>类型转换函数</code>的类与其他类型之间的转换，比如<code>double → Complex(调用转换构造函数)</code></li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li>两个具体类型指针之间的转换</li>
<li>int和指针之间的转换</li>
<li><strong>static_cast也不能去掉表达式的底层const</strong></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f);</span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="built_in">malloc</span>(<span class="number">10</span> *<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)));</span><br></pre></td></tr></tbody></table></figure>
<h5 id="4-1-2-2、const-cast">4.1.2.2、const_cast</h5>
<p><strong>const_cast只能改变运算对象的</strong><code>底层const</code>，<strong>改变常量属性</strong>，不能改变表达式的类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;n); <span class="comment">// &amp;n是底层const，指向常量的指针，const_cast去除底层const</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="4-1-2-3、reinterpret-cast">4.1.2.3、reinterpret_cast</h5>
<p>reinterpret_cast转换仅仅是<strong>对二进制位的重新解释</strong>，<strong>不会借助已有的转换规则对数据进行调整</strong></p>
<p>reinterpret_cast可以认为是 static_cast 的一种补充，<strong>一些 static_cast 不能完成的转换，就可以用reinterpret_cast 来完成</strong></p>
<ul>
<li>两个具体类型指针之间的转换</li>
<li>int和指针之间的转换</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">double</span> *pa = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：reinterpret_cast主要进行指针类型之间的转换</p>
</blockquote>
<h5 id="4-1-2-4、dynamic-cast">4.1.2.4、dynamic_cast</h5>
<p><code>dynamic_cast</code>可以将一个基类类型强转成派生类类型</p>
<p><code>dynamic_cast</code>运算符的使用形式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e) <span class="comment">// e必须是一个有效的指针</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e) <span class="comment">// e必须是一个左值</span></span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e) <span class="comment">// e不能是左值</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>type</code><strong>必须</strong>是一个类类型，并且通常情况下该类型应该含有<strong>虚函数</strong>；</p>
<p><code>e</code>的类型必须符合以下三个条件中的任意一个：</p>
<ul>
<li>目标<code>type</code>的<strong>公有</strong>派生类</li>
<li>目标<code>type</code>的<strong>公有</strong>基类</li>
<li>目标<code>type</code>的类型</li>
</ul>
<p>如果<code>dynamic_cast</code>的转换目标是指针类型并且失败了，结果为0；如果转换目标是引用类型并且失败了，将抛出一个<code>bad_cast</code>异常</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Base bp;</span><br><span class="line">Derived *dp = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(bp);</span><br><span class="line"><span class="keyword">const</span> Derived &amp;d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(bp)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针</strong></p>
<h3 id="4-2、sizeof运算符">4.2、sizeof运算符</h3>
<p>sizeof运算符满足<strong>右结合律</strong>，所得到的值是一个<code>size_t</code>类型的常量表达式</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span> (type) </span><br><span class="line"><span class="keyword">sizeof</span> expr <span class="comment">// 返回表达式结果类型的大小，类似于decltype，不实际计算表达式的值</span></span><br></pre></td></tr></tbody></table></figure>
<p>sizeof运算符的结果部分地依赖于其作用的类型：</p>
<ul>
<li>对char或类型为char的表达式执行sizeof运算，结果为1</li>
<li>对<code>引用类型</code>执行sizeof运算得到<code>被引用对象</code>所占空间的大小</li>
<li>对<code>指针</code>执行sizeof运算得到<code>指针本身</code>所占空间的大小</li>
<li>对<code>解引用指针</code>执行sizeof运算得到<code>指针指向的对象所占空间</code>的大小，<strong>指针不需要有效</strong></li>
<li>对<code>数组</code>执行<span id="sizeofshuzu">sizeof运算得到<code>整个数组</code>所占空间的大小</span>，<strong>sizeof运算不会把数组转化成指针来处理</strong></li>
<li>对<code>string或vector对象</code>执行sizeof运算只返回<code>该类型固定部分的大小</code>，不会计算对象中的元素占用了多少空间</li>
</ul>
<h2 id="5、语句">5、语句</h2>
<h3 id="5-1、范围for语句">5.1、范围for语句</h3>
<p><strong>范围for语句的语法形式</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// expression必须是一个序列，可以是初始值列表、数组、vector、string等类型的对象，拥有能返回迭代器begin和end成员的类型</span></span><br><span class="line"><span class="comment">// declaration来指代每次循环的序列中的元素，如果需要更改元素值，需要使用引用类型</span></span><br><span class="line"><span class="keyword">for</span> (declaration : expression) { </span><br><span class="line">    statement</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6、函数">6、函数</h2>
<h3 id="6-1、函数基础">6.1、函数基础</h3>
<h4 id="6-1-1、局部对象">6.1.1、局部对象</h4>
<h5 id="6-1-1-1、局部静态对象">6.1.1.1、局部静态对象</h5>
<p>局部静态对象在程序执行路径<code>第一次</code>经过对象定义语句时初始化，并且直到程序终止才被销毁</p>
<p>如果局部静态变量没有显式的初始值，将执行值初始化，如果是内置类型将被初始化为0</p>
<h3 id="6-2、参数传递">6.2、参数传递</h3>
<h4 id="6-2-1、传值参数">6.2.1、传值参数</h4>
<p>当初始化一个非引用类型的变量时，<strong>初始值被<code>拷贝</code>给变量</strong>，对变量的改动不会影响初始值</p>
<h4 id="6-2-2、const形参和实参">6.2.2、const形参和实参</h4>
<p><span id="xingcandedingcengconst">当实参初始化形参时会忽略掉<strong>顶层const</strong>，<strong>形参的顶层const被忽略</strong>，当形参有顶层const时，实参是常量对象或非常量对象都可以</span></p>
<p>形参是引用类型时，传实参时需要和<a href="#yinyongdechushihuaguize">引用的初始化规则</a>一样</p>
<h4 id="6-2-3、数组形参">6.2.3、数组形参</h4>
<p><strong>数组形参的形式</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [])</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> [<span class="number">10</span>])</span></span>; </span><br></pre></td></tr></tbody></table></figure>
<p><strong>管理指针形参的方式</strong>：</p>
<ul>
<li>使用标记执行数组长度：要求数组本身包含一个<code>结束字符</code>；对于**字符串或字符数组，是以<code>\0</code>为结束字符</li>
<li>使用标准库规范：传递指向数组<strong>首元素和尾元素的指针</strong>，比如<code>void print(int *begin, int *end);</code></li>
<li>显示传递一个表示数组大小的形参：专门定义一个表示数组大小的形参，比如<code>void print(int *p, int size);</code></li>
</ul>
<h5 id="6-2-3-1、数组引用形参">6.2.3.1、数组引用形参</h5>
<p><a href="#bianliangdingyichengshuzudeyinyong">变量可以定义成数组的引用</a>，形参也可以定义成数组的引用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>; <span class="comment">// &amp;arr外层的()不能省略</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="keyword">int</span> &amp;arr[<span class="number">10</span>]) <span class="comment">// 错误：将arr声明成了引用的数组</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in"><span class="keyword">int</span></span> (&amp;arr)[<span class="number">10</span>]) <span class="comment">// 正确：arr是具有10个整数的整形数组的引用</span></span><br></pre></td></tr></tbody></table></figure>
<p>这种用法限制了print函数的可用性，只能将<strong>函数作用于大小为10的数组</strong></p>
<h5 id="6-2-3-2、传递多维数组">6.2.3.2、传递多维数组</h5>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> size)</span></span>; <span class="comment">// size行10列的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *matrix[<span class="number">10</span>]; <span class="comment">// 10个指针构成的数组</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*matrix)[<span class="number">10</span>]; <span class="comment">// 指向含有10个整数数组的指针</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="6-2-4、含有可变形参的函数">6.2.4、含有可变形参的函数</h4>
<p>C++提供两种方法：</p>
<ul>
<li>如果所有的实参类型相同，可以传递一个名为<code>initializer_list</code>的标准库类型</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// initializer_list是一个模板类型，用法和vector一样，用于表示某种特定类型的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg) </span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果实参的类型不同，可以使用可变参模板</li>
<li>省略符形参</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">va_list类型 <span class="comment">// 获取第一个参数`a`后面的参数，是一个参数指针 `va_arg argptr`</span></span><br><span class="line">va_start宏 <span class="comment">// 定位参数`a`后面的第一个参数的位置 `va_start(argptr, a)`</span></span><br><span class="line">va_arg宏 <span class="comment">// 返回下一个类型匹配的表达式值`va_arg(argptr, 参数类型)`</span></span><br><span class="line">va_end宏 <span class="comment">// 结束整个获取可变参数列表的动作 `va_end(argptr)`</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-3、返回类型和return语句">6.3、返回类型和return语句</h3>
<p>在<strong>含有return语句的循环后面应该也有一条return语句</strong>，如果没有的话该程序就是错误的。</p>
<p>返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于<strong>初始化调用点的一个临时量</strong>，该临时量就是函数调用的结果</p>
<h4 id="6-3-1、列表初始化返回值">6.3.1、列表初始化返回值</h4>
<p>列表用来对<strong>表示函数返回的临时量</strong>进行初始化，如果列表为空，临时量执行值初始化，否则返回的值由函数的返回类型决定；<strong>和列表初始化变量的使用方法一致，此处初始化函数返回的临时变量</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 列表初始化数组类型</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表初始化，调用对应的构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">double</span> b, <span class="keyword">char</span> c) : <span class="built_in">a</span>(a), <span class="built_in">b</span>(b), <span class="built_in">c</span>(c) {}</span><br><span class="line">};</span><br><span class="line"><span class="function">A <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> {<span class="number">1</span>, <span class="number">0.3</span>, <span class="string">'c'</span>}; <span class="comment">// 调用构造函数初始化临时变量</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回内置类型，{}中对多一个值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> {<span class="number">1</span>};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="6-3-2、返回数组指针">6.3.2、返回数组指针</h4>
<h5 id="6-3-2-1、使用类型别名">6.3.2.1、使用类型别名</h5>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>]; <span class="comment">// arrT是类型别名，表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">// 返回一个指向含有10个整数的数组指针</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="6-3-2-2、声明一个返回数组指针的函数">6.3.2.2、声明一个返回数组指针的函数</h5>
<p>数组的维度必须跟在函数名字之后，函数的形参跟在函数名之后且形参列表应该先于数组的维度</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> (*<span class="built_in">function</span>(parameter))[dimension];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">func</span>(<span class="keyword">int</span> i))[<span class="number">10</span>]; </span><br></pre></td></tr></tbody></table></figure>
<h5 id="6-3-2-3、使用尾置返回类型">6.3.2.3、使用尾置返回类型</h5>
<p>任何函数的定义都可以使用尾置返回，对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 尾置返回类型跟在形参列表之后并以-&gt;符号开头，原来返回值类型的地方使用auto</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>; <span class="comment">// 返回的是一个指针，该指针指向含有10个整数的数组</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="6-3-2-4、使用decltype">6.3.2.4、使用decltype</h5>
<p>对返回类型的数组进行decltype操作，将结果作为返回类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>};</span><br><span class="line"><span class="keyword">decltype</span>(odd)* <span class="built_in">func</span>(<span class="keyword">int</span> i);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注</strong>：decltype只会返回表达式的类型，decltype(odd)返回的是数组的类型，并不把数组类型转化成指针，需要附加一个*</p>
</blockquote>
<h3 id="6-4、函数重载">6.4、函数重载</h3>
<p>重载函数<strong>只和函数名和形参列表有关，与<code>返回值的类型</code>无关</strong></p>
<h4 id="6-4-1、重载和const形参">6.4.1、重载和const形参</h4>
<p><a href="#xingcandedingcengconst">顶层const不影响传入函数的对象</a>，一个拥有<span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>顶层const的形参无法和另一个没有顶层const的形参</strong><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>区分开来</p>
<p>如果形参是某种类型的指针或引用，则**通过区分其指向的是常量对象还是非常量对象(底层const)**可以实现函数重载</p>
<p>传递一个<strong>非常量对象</strong>或者<strong>指向非常量对象的指针</strong>时，编译器优先选用<strong>非常量版本</strong>的函数，因为函数匹配采用最精准类型匹配，用非常量对象初始化常量引用需要类型转换，而接收非常量形参的版本则更精确匹配</p>
<h4 id="6-4-2、const-cast和重载">6.4.2、const_cast和重载</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2)</span></span>;</span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> string&amp;&gt;(s1), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> string &amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="6-4-2、重载与作用域">6.4.2、重载与作用域</h4>
<p><span id="shengmingzaineicunzuoyongdehanshubingbuhuichongzaishengmingzaiwaicengzuoyongyudehanshu">如果在内层作用域中声明名字，它将<span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名</strong><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>：</span></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"value : "</span>); <span class="comment">// 错误：void print(const string &amp;)被隐藏了</span></span><br><span class="line">    <span class="built_in">print</span>(ival); <span class="comment">// 正确：调用void print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>); <span class="comment">// 正确：调用void print(int)，void print(double)被隐藏掉了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>在C++中，名字查找发生在类型检查之前</strong>，<code>print("valur: ")</code>先查找<code>print</code>名字的函数，在内层作用域中查找到<code>void print(int)</code>，然后再进行类型检查报错</p>
<h3 id="6-5、特殊用途语言特性">6.5、特殊用途语言特性</h3>
<h4 id="6-5-1、默认实参">6.5.1、默认实参</h4>
<p><strong>一旦某个形参被赋予了默认值，后面所有形参都必须有默认值</strong></p>
<p>函数调用时实参按其位置解析，<strong>默认实参负责填补调用缺少的<code>尾部实参</code>(靠右边的位置)</strong></p>
<blockquote>
<p><strong>Tips</strong>：合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，让经常使用默认值的形参出现在后面</p>
</blockquote>
<p>允许多次声明同一个函数，函数的<strong>后续声明只能为之前那些没有默认值的形参添加默认实参</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = <span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = <span class="string">'*'</span>)</span></span>; <span class="comment">// 不能改变已有的默认值</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">45</span>, <span class="keyword">char</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：默认形参可以出现在函数声明或者定义中，但不能同时给形参赋默认值</p>
</blockquote>
<h4 id="6-5-2、constexpr函数">6.5.2、constexpr函数</h4>
<p>定义constexpr函数的方法需要遵循几项约定：</p>
<ul>
<li>函数的<strong>返回值类型及所有的形参</strong>都得是<a href="#zimianzhileixingdedingyi">字面值类型</a></li>
<li>函数体中必须有且只有一条return语句，也可以包含其他语句，<strong>只要这些语句在<code>运行时</code>不执行任何操作就行</strong></li>
</ul>
<p>执行初始化任务时，<strong>编译器把对constexpr函数的调用替换成其结果值</strong>，为了能在编译过程中随时展开，constexpr函数被隐式地指定为<strong>内联函数</strong></p>
<p>constexpr函数的返回值：</p>
<ul>
<li>如果实参是常量表达式，返回值就是常量</li>
<li>如果实参是非常量表达式，返回值就不是常量</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="number">42</span>; }</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>{ <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt; } <span class="comment">// 返回值并非一定是常量，取决于实参的类型</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：constexpr函数需要在函数的开头用constexpr标记</p>
</blockquote>
<h4 id="6-5-3、调试帮助">6.5.3、调试帮助</h4>
<p>assert宏定义在头文件<code>cassert</code>中，assert宏常用于检查<code>不能发生</code>的条件</p>
<p>定义<code>NDBUG</code>能避免检查各种条件所需的运行时的开销，此时根本不会执行运行时检查</p>
<h3 id="6-6、函数指针">6.6、函数指针</h3>
<p>函数的类型由<code>返回类型</code>和<code>形参类型</code>共同决定，与函数名无关</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*pf)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;); <span class="comment">// *pf外层的括号必不可少</span></span><br></pre></td></tr></tbody></table></figure>
<p>把函数名作为一个值使用时，该函数<strong>自动地转换成指针</strong>，可以直接使用指向函数的指针调用该函数，无需提前解引用指针</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// 两种写法等价</span></span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">"hello"</span>, <span class="string">"jdiehyg"</span>);</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">"hello"</span>, <span class="string">"jdiehyg"</span>);</span><br><span class="line"><span class="keyword">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">"hello"</span>, <span class="string">"jdiehyg"</span>);</span><br></pre></td></tr></tbody></table></figure>
<h4 id="6-6-1、函数指针形参">6.6.1、函数指针形参</h4>
<h5 id="6-6-1-1、使用指向函数的指针">6.6.1.1、使用指向函数的指针</h5>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, <span class="keyword">bool</span> pf(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> sring &amp;))</span></span>; <span class="comment">// 自动将pf转化为指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, <span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> sring &amp;))</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="6-6-1-2、使用类型别名">6.6.1.2、使用类型别名</h5>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func1</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>; <span class="comment">// Func1是函数类型，不是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>; <span class="comment">// // Func2是函数类型，不是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*Func3)</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>; <span class="comment">// Func3是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *Func4</span>; <span class="comment">// // Func4是函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, Func1)</span></span>; <span class="comment">// 自动将Func1转换成函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp;s2, Func3)</span></span>; </span><br></pre></td></tr></tbody></table></figure>
<h4 id="6-6-2、返回指向函数的指针">6.6.2、返回指向函数的指针</h4>
<h5 id="6-6-2-1、使用类型别名">6.6.2.1、使用类型别名</h5>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line">usinf PF = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="6-6-2-2、使用返回类型尾置">6.6.2.2、使用返回类型尾置</h5>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="6-6-2-3、使用decltype">6.6.2.3、使用decltype</h5>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *<span class="built_in">getFcn</span>(<span class="keyword">const</span> string &amp;);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注</strong>：decltype只返回表达式原本的类型，只会返回函数类型，不会转化成相应的指针类型</p>
</blockquote>
<h2 id="7、类">7、类</h2>
<p><strong>类的基本思想是<code>数据抽象</code>和</strong><code>封装</code>：</p>
<ul>
<li><strong>数据抽象</strong>：是一种依赖于<strong>接口</strong>和<strong>实现</strong><code>分离</code>的编程技术
<ul>
<li><strong>类的接口</strong>：包括用户所能执行的操作</li>
<li><strong>类的实现</strong>：包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数</li>
</ul>
</li>
<li><strong>封装</strong>：实现了类的接口与实现的分离，封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分</li>
</ul>
<p>两个类的成员完全一样，只要类名不一样就是不同的类</p>
<p><strong>类的前向声明</strong>：只声明类而暂时不定义这个类</p>
<p><span id="buwanquanleixing"><strong>不完全类型</strong></span>：在声明之后定义之前都属于不完全类型，可以定义指向这种类型的指针或引用，也可以声明(但不能定义)以不完全类型作为参数或返回值的函数</p>
<h3 id="7-1、定义抽象数据类型">7.1、定义抽象数据类型</h3>
<p><strong>类是一种类型，对象是类类型的变量</strong></p>
<h4 id="7-1-1、成员属性-数据成员">7.1.1、成员属性(数据成员)</h4>
<p><strong>数据成员</strong>定义了类的对象的具体内容，<strong>每个对象有自己的一份数据成员拷贝</strong>，修改一个对象的数据成员，不会影响其他的对象的数据成员。</p>
<p>可以为数据成员提供一个<a href="#leineichushizhihuakuohao">类内初始值</a>，<strong>或放在花括号里</strong>，<strong>或放在等号右边</strong>，<code>但不能用圆括号</code>，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被<a href="#morenchushihua">默认初始化</a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//类内初始值</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">int</span> b{<span class="number">1</span>}; <span class="comment">// 正确</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// 错误</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>补充</strong>：</p>
<ul>
<li>
<p>类在内存中存储分为<strong>数据区</strong>和<strong>方法区</strong>，每一个对象对应<strong>不同的数据区，而方法区是共享的</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211118220526028.png" alt="image-20211118220526028"></p>
</li>
<li>
<p><code>sizeof(类名)</code>只包括<strong>数据区</strong>的存储大小，不包括<strong>方法区</strong>的存储大小，<strong>方法区</strong>的存储大小在编译期就已经确定，创建对象时，不会拷贝<strong>方法区</strong>的内容，只会拷贝一份<strong>数据区</strong>的内容</p>
</li>
</ul>
</blockquote>
<h5 id="7-1-1-1、定义一个类型成员">7.1.1.1、定义一个类型成员</h5>
<p>除了定义数据和函数成员之外，类还可以<strong>自定义某种类型在类中的别名</strong>，由类定义的类型别名和其他成员一样存在访问限制，可以是<strong>public</strong>或者<strong>private</strong></p>
<p>用来<strong>定义类型的成员必须</strong><code>先定义后使用</code>，类型成员通常出现在类开始的地方</p>
<p>在类的作用域之外，<strong>类类型成员则使用</strong><code>作用域运算符</code>访问</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="comment">// using pos = string::size_type;</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Screen::pos ht = <span class="number">24</span>; <span class="comment">// 类的作用域之外，类类型成员使用作用域运算符访问</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="7-1-1-2、可变数据成员">7.1.1.2、可变数据成员</h5>
<p>可以通过在数据成员的声明中加入<code>mutable</code>关键字，来实现在<code>const</code><strong>的成员函数</strong>中修改数据成员</p>
<p><strong>可变</strong><code>数据成员</code>永远不会是<code>const</code>的，即使是<code>const</code>对象的成员，<strong>一个<code>const</code>成员函数可以改变一个可变成员的值</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> ii) : <span class="built_in">i</span>(ii) {}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="comment">// const成员函数可以改变可变成员的值</span></span><br><span class="line">        i = <span class="number">18</span>; <span class="comment">// 正确</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h4 id="7-1-2、成员方法-成员函数">7.1.2、成员方法(成员函数)</h4>
<p>成员函数的<strong>声明必须在类的内部</strong>，定义既可以在类的内部也可以在类的外部，<strong>定义在类内部</strong>的函数是<strong>隐式的inline函数</strong></p>
<h5 id="7-1-2-1、this指针">7.1.2.1、<code>this</code>指针</h5>
<p>成员函数通过一个名为<code>this</code>的额外的<strong>隐式参数</strong>来访问调用它的那个对象，当我们调用一个成员函数时，用请求该函数的对象地址初始化<code>this</code></p>
<p>每一个成员函数都隐式含有<code>this</code>指针，成员方法在底层中的真实面貌：<code>void func(this, x)</code>，参数列表的第一个参数是一个隐藏的参数<code>this</code>，<strong>默认赋值为调用的对象</strong>，任何对类成员的直接访问都被看做<code>this</code>的隐式引用</p>
<p>因为<code>this</code>总是指向<strong>这个</strong>对象，所以<code>this</code>是一个<strong>常量指针</strong>，不允许改变<code>this</code>中保存的地址</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.func(<span class="number">123</span>); <span class="comment">// 等价于 func(&amp;a, 123); </span></span><br><span class="line">             <span class="comment">// 成员函数原型：void func(int num) ==&gt;&gt; void func(const A *this, int num)</span></span><br><span class="line">             <span class="comment">// this的类型：const A * </span></span><br></pre></td></tr></tbody></table></figure>
<p><code>this</code>的形参是隐式定义的，任何自定义名为<code>this</code>的参数或变量的行为都是非法的</p>
<h5 id="7-1-2-2、const成员函数">7.1.2.2、const成员函数</h5>
<p>默认情况下，<code>this</code>的类型是<strong>指向类类型</strong><code>非常量版本</code>的常量指针，因为<code>this</code>是隐式的，所以不能直接通过更改<code>this</code>的类型来绑定到一个<strong>常量对象</strong>上，在C++中允许<strong>把<code>const</code>关键字放在成员函数列表之后来表示<code>this</code>是一个<code>指向常量</code>的常量指针</strong>，使用<code>const</code>的成员函数被称为<strong>常量成员函数</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>常量对象，以及常量对象的引用或指针都<code>只能</code>调用常量成员函数</strong>，而<code>非常量对象</code><strong>既可以调用常量成员函数，也可以调用普通成员函数</strong>，对于<code>非常量对象</code><strong>优先</strong>匹配普通成员函数，如果不存在普通成员函数则匹配常量成员函数</p>
<p>一个<code>const</code>成员函数如果以引用的形式返回<code>*this</code>，那么它的返回类型将是<strong>常量引用</strong>，因为此时的<code>this</code>是<code>const</code>的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> j) : <span class="built_in">i</span>(j) {}</span><br><span class="line">    <span class="function"><span class="keyword">const</span> A&amp; <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="comment">// 返回值类型为常量引用类型</span></span><br><span class="line">        i = <span class="number">234</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>通过区分成员函数是否是<code>const</code>的，可以对成员函数进行重载。非常量版本的函数对于常量对象是不可用的，只能在一个常量对象上调用<code>const</code>成员函数，虽然非常量对象可以调用常量版本或非常量版本，但会优先匹配非常量版本</p>
<h5 id="7-1-2-3、类作用域和成员函数">7.1.2.3、类作用域和成员函数</h5>
<p>编译器分两步处理类：</p>
<ul>
<li>首先编译成员的声明</li>
<li>再编译成员函数体</li>
</ul>
<p>所以<strong>成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序</strong></p>
<h5 id="7-1-2-4、在类的外部定义成员函数">7.1.2.4、在类的外部定义成员函数</h5>
<p>成员函数的定义必须和它的声明匹配，包括返回类型、函数名、参数列表，如果是常量成员函数，定义时还需要确定<code>const</code>属性，同时类外定义还需要指明类名</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>{}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="7-1-2-5、令成员作为内联函数">7.1.2.5、令成员作为内联函数</h5>
<p><strong>定义在类内部</strong>的成员函数是<strong>自动inline</strong>的，可以在类的内部把<code>inline</code>作为声的一部分显示地声明成员函数，同样的，也可以在类外部用<code>inline</code>关键字修饰函数的定义</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> j) : <span class="built_in">i</span>(j) {}</span><br><span class="line">    <span class="function"><span class="keyword">const</span> A&amp; <span class="title">func</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> A&amp; <span class="title">A::func</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    i = <span class="number">234</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：可以同时在声明和定义的地方同时说明<code>inline</code>，这是合法的，不过，最好<strong>只在类外部定义的地方说明<code>inline</code></strong></p>
</blockquote>
<h4 id="7-1-3、构造函数">7.1.3、构造函数</h4>
<p>构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数</p>
<p><strong>创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其<code>常量</code>属性</strong>，构造函数在const对象的构造过程中可以向其写值</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> ii) {</span><br><span class="line">        i = ii;</span><br><span class="line">        j = ii;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> ii, <span class="keyword">int</span> jj) : <span class="built_in">i</span>(ii), <span class="built_in">j</span>(jj) {}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">const</span> A <span class="title">a</span><span class="params">(<span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> A <span class="title">b</span><span class="params">(<span class="number">345</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注</strong>：构造函数不能被声明成<code>const</code>的，因为构造函数是用来初始化对象的数据成员，需要更改数据成员，所以不能声明成<code>const</code>的</p>
</blockquote>
<h5 id="7-1-3-1、合成的默认构造函数">7.1.3.1、合成的默认构造函数</h5>
<p><strong>合成的默认构造函数</strong>：编译器创建的构造函数</p>
<p>只有当类<strong>没有声明任何构造函数</strong>时，编译器才会<strong>自动地生成</strong>默认构造函数</p>
<p><span id="hechengmorengouzaohanshu">合成的默认构造函数的初始化规则</span>：</p>
<ul>
<li>如果存在类内初始值，用初始值初始化成员</li>
<li>否则，<a href="#morenchushihua">默认初始化</a></li>
</ul>
<p>不能依赖合成的默认构造函数的情况：</p>
<ul>
<li>
<p>类内有自定义的构造函数，编译器不会生成合成的默认构造函数</p>
</li>
<li>
<p>定义在块中的内置类型或复合类型的对象被默认初始化，它们的值是未定义的</p>
</li>
<li>
<p><strong>如果类包含其他类类型的成员，并且其他类没有默认构造函数，此时编译器不能为此类生成合成的默认构造函数</strong><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</li>
</ul>
<p>如果需要默认构造函数，可以通过在参数列表后面写上<code>= default</code>来要求编译器生成构造函数。<code>= default</code>既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。在类内使用<code>= default</code>，则默认构造函数是<strong>内联</strong>的，在类外使用时，默认是非内联的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 类内 = default</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>; <span class="comment">//类内声明 定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外 = default</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>(); <span class="comment">// 类内声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>; <span class="comment">// 类外定义</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="7-1-3-2、构造函数初始化列表">7.1.3.2、构造函数初始化列表</h5>
<p>初始化列表负责为新创建的对象的一个或几个数据成员赋初值，构造函数初始值是成员名字的一个列表，每个名字后面紧跟<strong>括号(或花括号)<strong>括起来的成员初始值，不同成员的初始化通过</strong>逗号</strong>分隔开来</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="keyword">const</span> string &amp;s) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(<span class="number">0</span>), <span class="built_in">revenue</span>(<span class="number">0</span>) {}</span><br></pre></td></tr></tbody></table></figure>
<p>当某个数据成员被构造函数初始值列表忽略时，该成员将在<code>构造函数体之前</code><strong>以<a href="#hechengmorengouzaohanshu">合成默认构造函数</a>相同的方式隐式初始化</strong></p>
<p>初始化列表的<strong>初始化顺序</strong>是根据<strong>成员属性的<code>声明</code>顺序</strong>有关，与初始化列表的先后顺序无关，初始化列表规定了每一个成员属性的构造形式</p>
<blockquote>
<p><strong>注</strong>：最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，<strong>尽量避免使用某些成员初始化其他成员</strong></p>
</blockquote>
<p><strong>构造函数在<code>{}</code>之前就已经初始化完成了</strong>，如果没有初始化列表，在函数体中给成员属性赋值，需要<strong>先初始化再赋值</strong>操作，特别对于<code>const、引用</code>类型的<strong>成员属性</strong>会出错，其次就是效率更高。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化列表的形式</span></span><br><span class="line"><span class="built_in">Data</span>() : __x(<span class="number">100</span>), __y(<span class="number">100</span>), <span class="built_in">a</span>(<span class="number">34</span>)  <span class="comment">//到此初始化已经结束</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//赋值操作</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211119194527170.png" alt="image-20211119194527170" style="zoom:80%;">
<blockquote>
<p><strong>注</strong>：注意区分<code>const</code>对象和<code>const</code>数据成员在构造时的区别</p>
<ul>
<li>构造函数在<strong>const对象</strong>的构造过程中可以向其写值</li>
<li>类的<strong>数据成员类型</strong>如果是<code>const</code>或<code>引用</code>时，只能通过初始化列表或者类内初始值的方式进行初始化</li>
</ul>
</blockquote>
<h5 id="7-1-3-3、默认实参和构造函数">7.1.3.3、默认实参和构造函数</h5>
<p>如果一个构造函数为<strong>所有参数都提供了默认实参</strong>，则实际上也就相当于定义了默认构造函数</p>
<h5 id="7-1-3-4、委托构造函数">7.1.3.4、委托构造函数</h5>
<p><strong>委托构造函数</strong>：使用它所属的其他构造函数执行它自己的初始化过程</p>
<p>在委托构造函数内，成员初始值列表<strong>只有一个唯一的入口，就是类名本身</strong>，类名后面紧跟圆括号括起来的参数列表，<strong>参数列表必须与另外一个构造函数匹配</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>(string s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price) : <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt * price) {} <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() : <span class="built_in">Sales_data</span>(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>) {} <span class="comment">// 委托构造函数：委托 Sales_data(string s, unsigned cnt, double price)</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(string s) : <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) {} <span class="comment">// 委托构造函数：委托 Sales_data(string s, unsigned cnt, double price)</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(istream &amp;is) : <span class="built_in">Sales_data</span>() { <span class="built_in">read</span>(is, *<span class="keyword">this</span>); } <span class="comment">// 委托构造函数：委托 Sales_data() : Sales_data("", 0, 0)</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>当一个构造函数委托给另一个构造函数时，<strong>受委托的构造函数的初始值列表和函数体被依次执行</strong>，最终将控制权交给<strong>委托者的函数体</strong></p>
<h5 id="7-1-3-5、默认构造函数的作用">7.1.3.5、默认构造函数的作用</h5>
<p><strong>当对象默认初始化或值初始化时自动执行默认构造函数</strong></p>
<p>默认初始化发生的情况：</p>
<ul>
<li>在块作用域内不使用任何初始值定义一个非静态变量或数组时</li>
<li>当类本身含有类类型的成员且使用合成的默认构造函数时</li>
<li>当类类型的成员没有在构造函数初始值列表中显示初始化时</li>
</ul>
<p>值初始化发生的情况：</p>
<ul>
<li>在数组初始化过程中提供的初始值数量少于数组大小时</li>
<li>不使用初始值定义一个局部静态变量时</li>
<li>当我们通过书写形如T()的表达式显式地请求值初始化时，T()要执行默认构造函数生成临时变量，再赋值给变量</li>
</ul>
<p><strong>默认构造函数的使用</strong>：不需要在对象名后添加<code>()</code>，<code>Sales_data obj</code>即可</p>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>值初始化：在定义变量的时候，当场给变量赋值</li>
<li>默认初始化：在定义变量时，不做赋值操作，系统根据默认规则给变量赋初值</li>
</ul>
<p><strong>Tips</strong>：如果定义了其他构造函数，最好也提供一个默认构造函数</p>
</blockquote>
<h4 id="7-1-4、拷贝、赋值和析构">7.1.4、拷贝、赋值和析构</h4>
<h5 id="7-1-4-1、转换构造函数">7.1.4.1、转换构造函数</h5>
<p>如果<strong>构造函数只接受</strong><code>一个实参</code>，则它实际上定义了转换为此类类型的隐式转换机制</p>
<blockquote>
<p><strong>说明</strong>：实参是指在<strong>调用函数</strong>时，函数名后面括号中的参数。如果有多个形参，但<strong>其他形参都有默认值</strong>，转换构造函数也是可以实现的</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">private</span> : </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> x) : <span class="built_in">x</span>(x) {</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" : Class A : "</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;a) {</span><br><span class="line">        cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" : copy from : "</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    A a = <span class="number">45</span>; <span class="comment">// 调用A(45)创建匿名对象，再将匿名对象拷贝给对象a</span></span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">78</span>; <span class="comment">// 调用A(78)创建匿名对象，再将匿名对象赋值给对象a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编译器只会自动地执行<strong>一步类型转换</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 成员函数 conbine 的原型为 void conbine(const Sales_data&amp;);</span></span><br><span class="line">item.<span class="built_in">conbine</span>(<span class="string">"9-999-9999"</span>); <span class="comment">// 错误：需要用户定义的两种转换</span></span><br><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 第一步："9-999-9999"转换成string类型的临时变量temp</span></span><br><span class="line"><span class="comment">// 第二步：将temp转换成Sales_data类型</span></span><br><span class="line"></span><br><span class="line">string null_book = <span class="string">"9-999-9999"</span>;</span><br><span class="line">item.<span class="built_in">conbine</span>(null_book); <span class="comment">// 正确：只进行一步转换</span></span><br><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 第一步：将string类型的变量null_book转换成Sales_data类型</span></span><br></pre></td></tr></tbody></table></figure>
<p>类构造函数默认是<code>implicit</code>隐式的， <code>explicit</code>关键字可以抑制构造函数定义的隐式转换，<code>explicit</code>只对一个<code>实参</code>的构造函数(<strong>如果构造函数的其他参数都有默认值也可以</strong>)有效。只能<strong>在类内声明构造函数时使用<code>explicit</code>关键字，在类外定义时不应重复</strong></p>
<p>使用<code>explicit</code>构造函数时，只能以<strong>直接初始化</strong>的形式使用，<strong>编译器不会<code>自动转换过程中</code>使用该函数</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Sales_data item = null_book; <span class="comment">// 错误：编译器不会将string类型的null_book自动转换成Sales_data类型</span></span><br><span class="line"><span class="function">Sales_data <span class="title">item</span><span class="params">(null_book)</span></span>; <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure>
<p>但可以为转换<strong>显示地使用构造函数</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Sales_data item = <span class="built_in">Sales_data</span>(null_book); <span class="comment">// 显式地通过构造函数创建临时对象</span></span><br><span class="line">Sales_data item = <span class="keyword">static_cast</span>&lt;Sales_data&gt;(null_book); <span class="comment">// 使用显示类型转换</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="7-1-4-2、拷贝构造函数">7.1.4.2、拷贝构造函数</h5>
<p>即使定义了其他构造函数，编译器也会<strong>合成一个拷贝构造函数</strong>，合成拷贝构造函数会将参数的<code>非static</code>成员逐个拷贝到正在创建的对象中，每个成员的类型决定拷贝形式，对于类类型的成员调用其拷贝构造函数来拷贝</p>
<p>使用<strong>拷贝初始化</strong>时，编译器将右侧运算对象拷贝到正在创建的对象中，如果需要还要进行类型转换，调用转换构造函数</p>
<p><strong>拷贝初始化发生的情形</strong>：</p>
<ul>
<li>
<p>使用<code>=</code>给对象赋值</p>
</li>
<li>
<p>将一个对象作为实参传递给一个<strong>非引用</strong>对象的形参</p>
</li>
<li>
<p>从一个返回类型为<strong>非引用</strong>类型的函数返回一个对象</p>
</li>
<li>
<p>用花括号初始化一个数组中的元素或者一个聚合类的成员</p>
</li>
<li>
<p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span id="charushifangruyigekaobei">某些类类型对其分配的对象使用拷贝初始化</span><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
</li>
</ul>
<p><strong>拷贝构造函数的参数必须是<code>const的引用</code>类型的原因</strong>：</p>
<ul>
<li>引用的原因：当实参赋值给形参时，要调用拷贝构造函数，如果参数不是引用类型，就会<code>无限循环递归</code>的调用拷贝构造函数</li>
<li>const的原因：
<ul>
<li>兼容绑定匿名对象，匿名对象如果是<strong>右值</strong>的话，只能使用<strong>const引用</strong>接收</li>
<li>逻辑上的限制，拷贝构造函数中不需要改变被拷贝对象</li>
<li>兼容const类型的拷贝</li>
</ul>
</li>
</ul>
<h5 id="7-1-4-3、拷贝赋值运算符">7.1.4.3、拷贝赋值运算符</h5>
<p>与拷贝构造函数一样，如果未定义自己的拷贝赋值运算符，编译器会合成拷贝赋值运算符</p>
<p>为了和内置类型的赋值保持一致，赋值运算符通常<strong>返回一个指向其左侧运算对象的引用</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp; a) {}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>拷贝赋值运算符的使用场景</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">A a = <span class="number">45</span>; <span class="comment">// 当=出现在对象的定义语句中时，调用的是拷贝构造函数</span></span><br><span class="line">a = <span class="number">78</span>; <span class="comment">// 当=出现在变量赋值而非定义语句中时，调用的拷贝赋值运算符</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="7-1-4-4、析构函数">7.1.4.4、析构函数</h5>
<p>析构函数释放对象使用的资源，并销毁对象的<code>非static</code>数据成员</p>
<p><strong>析构函数没有参数，不能被重载，一个类只能有一个析构函数</strong></p>
<p>在一个析构函数中，<strong>首先执行函数体然后销毁成员</strong>，成员按初始化顺序的逆序销毁</p>
<p><strong>隐式销毁</strong>一个<strong>内置指针类型</strong>的成员不会delete它<strong>指向的对象</strong>，而智能指针是类类型，具有自己的析构函数，智能指针成员在析构阶段会被自动销毁；<strong>当指向一个对象的引用或指针离开作用域时，析构函数不会执行</strong></p>
<p><strong>调用析构函数的场景</strong>：</p>
<ul>
<li>变量在离开其作用域时被销毁</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器被销毁时，其元素被销毁</li>
<li>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<p><strong>析构<code>函数体</code>自身并不直接销毁成员</strong>，成员在析构函数体之后隐含的析构阶段中被销毁</p>
<h5 id="7-1-4-5、移动构造">7.1.4.5、移动构造</h5>
<p>新标准的一个最主要的特性时可以<strong>移动而非拷贝对象</strong>的能力，对象被拷贝后就立即销毁时可以用移动来代替拷贝</p>
<h6 id="7-1-4-5-1、右值引用">7.1.4.5.1、右值引用</h6>
<p>右值引用必须<strong>绑定到右值</strong>的引用，可以通过&amp;&amp;而不是&amp;来获得右值的引用，右值引用只能绑定到一个<strong>将要销毁</strong>的对象</p>
<p><strong>左值表达式表示的是一个对象的身份，右值表达式表示的是对象的值</strong></p>
<p>左值持久，左值表常态：<strong>只要变量有名字，就是左值</strong>，包括<strong>右值引用类型的变量</strong>也是左值</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误：rr1是变量，左值</span></span><br></pre></td></tr></tbody></table></figure>
<p>右值短暂，右值表临时：右值要么是字面常量，要么是表达式求值过程中创建的临时值</p>
<p><strong>左值右值的区分方法</strong>：当代码运行到下一行，如果上一行表达式的值能够通过<code>单一的变量</code>访问到就是左值，否则是右值</p>
<p><strong>左值、右值和左值引用、右值引用无关，一个表达式只与左值右值有关</strong>，<strong>左值、右值是和<code>作用域</code>有关的，不同的作用域有可能是左值，有可能是右值</strong>，为了消除作用域导致右值变为左值的情况，可以使用<code>move   forward</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>{</span><br><span class="line">    <span class="built_in">judge2</span>(x);<span class="comment">//此处x为左值</span></span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> &amp;&amp;x)</span> </span>{ <span class="comment">// 左值、右值和作用域有关 此处为右值</span></span><br><span class="line">    <span class="built_in">judge2</span>(x);<span class="comment">//此处x为左值，左值和左值引用、右值引用无关，x只与左值、右值有关，此处的x判断为左值</span></span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>左值引用：不能绑定到<strong>要求转换的表达式、字面常量或返回右值的表达式</strong></p>
<p>右值引用：与左值引用相反，不能将右值引用绑定到左值上</p>
<p>返回左值引用的函数，连同<strong>赋值、下标、解引用和<code>前置</code>递增/递减运算符</strong>，都是返回左值的表达式，左值引用可以绑定到返回左值表达式的结果上</p>
<p>返回非引用类型的函数，连同<strong>算术、关系、位以及后置递增/递减运算符</strong>，都生成右值，右值引用或const的左值引用绑定到返回右值表达式的结果上</p>
<h6 id="7-1-4-5-2、move和foward">7.1.4.5.2、move和foward</h6>
<p><span id="moveshixianyouzhiyinyongbangdingzuozhiyinyong"><code>move</code>可以<strong>将左值转换为对应的右值引用类型</strong>，调用move之后，对于<strong>移后源</strong>对象，<strong>只能对它赋新值或者销毁</strong>，不能使用移后源对象的值</span></p>
<p><code>move</code>的实现源码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用的绑定规则</strong>：</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">非常量左值引用（X&amp; ）：只能绑定到X类型的左值对象；</span><br><span class="line">常量左值引用（const X&amp;）：可以绑定到 X、const X类型的左值对象，或X、const X类型的右值；</span><br><span class="line">非常量右值引用（X&amp;&amp;）：只能绑定到X类型的右值；</span><br><span class="line">常量右值引用（const X&amp;&amp;）：可以绑定规定到X、const X类型的右值。</span><br></pre></td></tr></tbody></table></figure>
<p><strong>引用的折叠规则</strong>：模板实例化、typedef、auto类型推断中使用折叠规则</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">T&amp; &amp; 变为 T&amp;</span><br><span class="line">T&amp; &amp;&amp; 变为 T&amp;</span><br><span class="line">T&amp;&amp; &amp; 变为 T&amp;  </span><br><span class="line">T&amp;&amp; &amp;&amp; 变为 T&amp;&amp;  </span><br></pre></td></tr></tbody></table></figure>
<p>总结：</p>
<ul>
<li>所有右值引用折叠到右值引用上仍然是一个右值引用</li>
<li>所有的其他引用类型之间的折叠都将变成左值引用</li>
</ul>
<p><code>forward</code>的实现源码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T&amp;&amp; <span class="title">forward</span><span class="params">(std::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp; arg)</span> <span class="keyword">noexcept</span></span>{</span><br><span class="line">    <span class="comment">// forward an lvalue as either an lvalue or an rvalue</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(arg));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T&amp;&amp; <span class="title">forward</span><span class="params">(std::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp; arg)</span> <span class="keyword">noexcept</span></span>{</span><br><span class="line">    <span class="comment">// forward an rvalue as an rvalue</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(arg));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果x是一个非引用类型，<code>forward&lt;x&gt;() == forward&lt;x&amp;&amp;&gt;()</code>都是处理成右值，因为<code>forward&lt;x&gt;</code>返回类型是<code>x&amp;&amp;</code>，而<code>x&amp;&amp; &amp;&amp; == x&amp;&amp;</code></p>
<p>如果x是一个非引用类型，<code>forward&lt;x&amp;&gt;()</code>是处理成左值，因为<code>forward&lt;x&gt;</code>返回类型是<code>x&amp;&amp;</code>，而<code>x&amp; &amp;&amp; == x&amp;</code></p>
<p>由源代码可知：<code>forward</code>可以将<code>右值，左值</code>转换成<code>右值</code>，但不能将<code>右值</code>转换成<code>左值</code></p>
<h6 id="7-1-4-5-3、移动构造函数和移动赋值运算符">7.1.4.5.3、移动构造函数和移动赋值运算符</h6>
<p>移动构造函数的第一个参数是<code>右值引用</code>，与拷贝构造函数一样其他的任何额外的参数都必须有默认实参</p>
<p><strong>除了完成资源移动，移动构造函数必须确保移后源对象处于这样一个状态——销毁它是无害的</strong>，<code>一旦资源完成移动，源对象必须不再指向被移动的资源</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(Array &amp;&amp;x) : <span class="built_in">data</span>(x.data) { <span class="comment">//直接改名字</span></span><br><span class="line">	a.data = <span class="literal">nullptr</span>; <span class="comment">//将右值名字指向空指针，避免析构时重复析构造成段错误</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>编写移动操作时，必须确保将<strong>移后源对象进入一个可析构的状态</strong>，除了将移后源对象置为析构安全的状态之外，移动操作还必须<strong>保证对象仍然有效</strong>，可以安全地为其赋新值或者可以安全地使用而不依赖其当前值，另一方面，<strong>移动操作对移后源对象留下的值没有任何要求，不应该依赖于移后源对象中的数据</strong></p>
<p>编译器<strong>不会自动合成移动操作</strong>，只有当类没有定义任何自己版本的控制拷贝成员，且类的每个非static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员，如果一个成员时类类型，且该类有对应的移动操作，编译器也能移动这个成员</p>
<p><strong>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认地被定义为删除的</strong></p>
<p><strong>如果一个类既有移动构造函数也有拷贝构造函数时，如果一个值是<code>左值</code>，优先绑定<code>左值引用</code>版本(拷贝构造函数)，如果一个值是<code>右值</code>，<code>优先</code>绑定<code>右值引用</code>版本(移动构造函数)</strong>。但<strong>如果一个类只有拷贝构造函数时，不管是左值还是右值，都会调用拷贝构造函数，编译器不会合成移动构造函数，同时<code>&amp;&amp;</code>可以绑定到<code>const &amp;</code>上</strong></p>
<p><strong>一般来说，不需要为函数操作定义一个接收<code>const X&amp;&amp;</code>或者是一个普通的<code>X&amp;</code>参数的版本，只需要定义<code>const &amp;</code>和<code>X&amp;&amp;</code>参数的版本即可</strong>，所以移动构造函数的参数是<code>非const</code>的，拷贝构造函数的参数是<code>const</code>的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_bakc</span><span class="params">(X&amp;&amp;)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>移动赋值运算符也需要遵循<a href="#zifuzhi">自赋值</a>问题</p>
<blockquote>
<p><strong>补充</strong>：拷贝行为包括<strong>拷贝构造函数</strong>和<strong>赋值运算符</strong></p>
</blockquote>
<h6 id="7-1-4-5-4、右值引用和成员函数">7.1.4.5.4、右值引用和成员函数</h6>
<p>如果一个成员函数同时提供拷贝或移动版本，通常<strong>一个版本接受一个指向<code>const</code>的左值引用，一个版本接受一个指向非<code>const</code>的右值引用；一般来说不需要定义接受一个<code>const X&amp;&amp;</code>或一个普通的<code>X&amp;</code>参数的版本</strong></p>
<p>区分移动构造和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>，而另一个版本接受一个<code>T&amp;&amp;</code></p>
<p>通常，在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值；可以通过<strong>引用限定符</strong>指出<code>this</code>的左值、右值属性，引用限定符只能用于非<code>static</code>成员函数，且<strong>必须同时出现在函数的声明和定义中</strong></p>
<p>对于<code>&amp;</code>限定的函数，只能用于左值，对于<code>&amp;&amp;</code>限定的函数，只能用于右值</p>
<p>一个函数可以同时用<code>const</code>和引用限定，<strong>引用限定必须跟随在<code>const</code>限定符之后</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) <span class="keyword">const</span> &amp;;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>引用限定符可以区分重载版本，<strong>如果定义两个或者两个以上具有相同名字和相同参数列表的成员函数，必须对所有函数都加上引用限定符，或者都不加</strong></p>
<h5 id="7-1-4-6、三-五法则-point-right-经验-point-left-​">7.1.4.6、三/五法则(<span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>经验<span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>)​</h5>
<p><span id="需要自定义的析构函数的类也需要自定义的拷贝和赋值操作">需要自定义的析构函数的类也需要自定义的拷贝和赋值操作</span></p>
<p>需要自定义的拷贝操作的类也需要自定义的赋值操作，反之亦然</p>
<h5 id="7-1-4-7、使用-default">7.1.4.7、使用=default</h5>
<p>拷贝构造函数和赋值运算符都可以定义为<code>=default</code>，用法和构造函数的用法一致</p>
<h5 id="7-1-4-8、阻止拷贝">7.1.4.8、阻止拷贝</h5>
<p>将拷贝构造函数或赋值运算符定义<strong>删除的</strong>或者<strong>不可访问的</strong>，可以阻止拷贝</p>
<p><code>=delete</code><strong>必须</strong>出现在函数<code>第一次</code><strong>声明</strong>的时候，与<code>=default</code>的用法不同</p>
<p><strong>析构函数不能是删除的成员</strong></p>
<p><span id="就像其他任何类的情况一样">编译器将合成的成员定义为删除的函数</span>：</p>
<ul>
<li>如果类的<strong>某个成员</strong>的<code>析构函数</code>是删除的或不可访问的，则类的合成析构函数被定义为删除的</li>
<li>如果类的某个成员的<strong>拷贝构造函数或者析构函数</strong>是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的</li>
<li>如果类的某个成员的<strong>拷贝赋值运算符</strong>是删除的或不可访问的，或者<strong>类有一个const的或引用成员</strong>，则类的合成拷贝赋值运算符被定义为删除的</li>
<li>如果类的某个成员的<strong>析构函数</strong>是删除的或不可访问的，或者<strong>类有一个引用成员并没有类内初始化器</strong>，或者<strong>类有一个const成员并没有类内初始化器且其类型未显式定义默认构造函数</strong>，则类的默认构造函数被定义为删除的</li>
</ul>
<p>总结：<strong>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将定义为删除的</strong></p>
<p>类可以将<strong>拷贝构造函数和拷贝赋值运算符声明为private</strong>来阻止拷贝，声明成private只能阻止用户代码不能拷贝，但友元函数和成员函数仍旧可以拷贝，所以需要将拷贝构造函数和拷贝赋值运算符<strong>声明成privatede ，并不定义它们</strong></p>
<h5 id="7-1-4-9、拷贝控制和资源管理">7.1.4.9、拷贝控制和资源管理</h5>
<h6 id="7-1-4-9-1、行为像值的类">7.1.4.9.1、行为像值的类</h6>
<p>类的行为像一个值，意味着它应该有自己的状态，<strong>当拷贝一个像值的对象时，副本和原对象是完全独立的，需要进行深拷贝</strong></p>
<p><strong>赋值运算符通常组合了析构函数和构造函数的操作</strong>，类似析构函数，赋值操作会销毁左侧运算对象的资源，类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据，<strong>必须先执行销毁左侧资源操作，再拷贝右侧资源</strong></p>
<p><span id="zifuzhi">自定义赋值运算符需要满足</span>：<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>如果将一个对象赋予它自身，赋值运算符必须能正常工作</strong>，通常需要先拷贝参数对象，然后再进行销毁左侧资源<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs) {</span><br><span class="line">	<span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps); <span class="comment">// 先拷贝参数对象有可能被释放的资源</span></span><br><span class="line">    <span class="keyword">delete</span> ps; <span class="comment">// 释放左侧资源</span></span><br><span class="line">    ps = newp; <span class="comment">// 拷贝右侧资源</span></span><br><span class="line">    i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>类中成员属性含有<code>指针、其他类对象</code>等，需要自定义拷贝构造函数实现深拷贝</strong></p>
<p><strong>相关例子</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="keyword">const</span> A &amp;a) {</span><br><span class="line">    out &lt;&lt; <span class="string">"("</span> &lt;&lt; a.x &lt;&lt; <span class="string">", "</span> &lt;&lt; a.y &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> {</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">int</span> n = <span class="number">100</span>) : <span class="built_in">n</span>(n), <span class="built_in">data</span>((T *)<span class="built_in">calloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T), n)) {} <span class="comment">// 避免T类型没有默认构造函数，使用new的话会是未定义的</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="keyword">const</span> Vector &amp;a) : <span class="built_in">n</span>(a.n) { <span class="comment">// 有指针成员，需要深拷贝</span></span><br><span class="line">        data = (T *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(T) * n);<span class="comment">//此处不能使用new，原因同上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">new</span>(data + i) <span class="built_in">T</span>(a.data[i]);<span class="comment">//new的定位构造，实现副本和原本数据一致，但互不影响</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">T &amp;<span class="title">at</span><span class="params">(<span class="keyword">int</span> ind)</span> </span>{ <span class="keyword">return</span> data[ind]; }</span><br><span class="line">    T &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> ind) { <span class="keyword">return</span> data[ind]; }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> m = <span class="number">-1</span>)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">-1</span>) m = n;</span><br><span class="line">        cout &lt;&lt; <span class="string">"arr "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" : "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            cout &lt;&lt; data[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    T *data; </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h6 id="7-1-4-9-2、行为像指针的类">7.1.4.9.2、行为像指针的类</h6>
<p>行为像指针的类则共享状态，当拷贝一个像指针的对象时，<strong>副本和原对象使用相同的底层数据</strong></p>
<p>需要使用类似<code>shared_ptr</code>中的<code>引用计数</code>技术来管理类中的资源，当引用技术为0时，才销毁资源</p>
<p>可以<strong>将<code>计数器</code>保存在<code>动态内存</code>中</strong>，当拷贝或赋值时，拷贝指向计数器的<code>指针</code>，这样副本和原对象会使用相同的计数器</p>
<h3 id="7-2、访问控制与封装">7.2、访问控制与封装</h3>
<p>在C++中，使用<strong>访问说明符</strong>加强类的封装：</p>
<ul>
<li>定义在<strong>public</strong>说明符之后的成员在<strong>整个程序内</strong>可被访问，<strong>public</strong>成员定义类的接口</li>
<li>定义在<strong>private</strong>说明符之后的成员可以被<strong>类的成员函数</strong>访问，但是不能被使用该类的代码访问，<strong>private</strong>部分封装了类的实现细节</li>
</ul>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211119212317875.png" alt="image-20211119212317875" style="zoom: 67%;">
<p>每个访问说明符制定了接下来的成员的访问级别，其<strong>有效范围直到出现下一个访问说明符或者到达类的结尾处为止</strong></p>
<p><code>struct</code>和<code>class</code>的唯一区别：<strong>默认访问权限不一样</strong>，<code>struct</code>默认访问权限是<code>public</code>，<code>class</code>默认访问权限是<code>private</code></p>
<blockquote>
<p><strong>Tips</strong>：定义类的所有成员是<strong>public</strong>时，使用<code>struct</code>；如果是<code>private</code>时，使用<code>class</code></p>
</blockquote>
<h4 id="7-2-1、友元">7.2.1、友元</h4>
<p><strong>友元</strong>可以允许其他类或者函数访问<strong>类内非公有成员</strong>，可以在<strong>类内</strong>通过<code>friend</code>来声明该类的<strong>友元类或函数</strong></p>
<p>友元<strong>声明只能出现在类定义的内部，但是在类内出现的具体的位置不限</strong>，友元不是类的成员，不受所在区域的访问控制级别的约束</p>
<blockquote>
<p><strong>Tips</strong>：最好在类定义开始或结束前的位置集中声明友元</p>
</blockquote>
<p>友元的<strong>声明仅仅指定了访问的权限</strong>，而<strong>非一个通常意义上的函数声明</strong>，如果类的用户能够调用某个友元函数，必须在<strong>类内友元声明之外再专门对函数进行一次声明</strong></p>
<blockquote>
<p><strong>说明</strong>：许多编译器未强制限定友元函数必须在使用之前在类的外部声明，但为了<strong>安全起见最好在使用之前在类的外部声明</strong></p>
</blockquote>
<h5 id="7-2-1-1、类之间的友元关系">7.2.1.1、类之间的友元关系</h5>
<p>如果一个类指定了友元类，则<strong>友元类的成员函数可以访问此类包括非公有成员在内的所有成员</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> {</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>友元关系不存在传递性</strong>，每个类负责控制自己的友元类或者友元函数</p>
<h5 id="7-2-1-2、令成员函数作为友元">7.2.1.2、令成员函数作为友元</h5>
<p>当把一个<strong>成员函数声明成友元</strong>时，必须指出该成员函数<strong>属于哪个类</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> {</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>要想令某个成员函数作为友元，必须按照如下方式设计程序：</p>
<ul>
<li>首先定义<strong>Window_mgr</strong>类，其中声明<strong>clear</strong>函数，<strong>但不能定义它</strong>。在clear使用Screen的成员之前<strong>必须先声明Screen</strong></li>
<li>接下来<strong>定义</strong>Screen，包括对于clear的友元声明</li>
<li>最后定义clear，此时clear函数才可以使用Screen的成员</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span> <span class="comment">// 1、前向声明Screen类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span> {</span> <span class="comment">// 2、定义Window_mgr类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = vector&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>; <span class="comment">// 3、只声明clear函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Screen&gt; screens;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> {</span> <span class="comment">// 4、定义Screen类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>; <span class="comment">// clear友元声明</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">size_t</span> access_ctr;</span><br><span class="line">    <span class="built_in">Screen</span>(pos s, pos b, string c) : <span class="built_in">cursor</span>(s), <span class="built_in">height</span>(b), <span class="built_in">contents</span>(c) {}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor;</span><br><span class="line">    pos height;</span><br><span class="line">    string contents;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span> </span>{ <span class="comment">// 定义clear</span></span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.height * <span class="number">2</span>, <span class="string">' '</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注</strong>：</p>
<ul>
<li>重载函数要声明为友元，必须逐个声明为友元</li>
<li>友元函数不能直接访问类内成员，只能<strong>访问对象的成员</strong></li>
</ul>
</blockquote>
<h5 id="7-2-1-3、友元声明和作用域">7.2.1.3、友元声明和作用域</h5>
<p><strong>类和非成员函数的声明不是必须在它们的友元声明之前</strong>。当一个名字第一次出现在一个友元<code>声明</code>中时，隐式地假定改名字在当前作用域中是可见的</p>
<p><strong>如果是在类的内部定义友元函数，也必须在类的外部提供相应的声明使得函数可见</strong>，如果成员函数用到友元函数，友元函数的<strong>类外声明</strong>必须在<strong>成员函数调用友元函数之前出现</strong>，如果是类内调用，需要在类作用域之前声明</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">x</span>(<span class="keyword">int</span> a) : <span class="built_in">s</span>(a) {}</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>{ <span class="comment">// 类内定义友元函数</span></span><br><span class="line">        x sd;</span><br><span class="line">    	cout &lt;&lt; sd.s &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">x</span>() { <span class="built_in">f</span>(); } <span class="comment">// 类内调用友元函数，需要在类作用域之前声明友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x::g</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">f</span>(); }; <span class="comment">// 错误：f还没被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">x::h</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">f</span>(); }; <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li>如果友元函数中<strong>通过对象</strong>用到类的成员，友元函数的声明和类成员的声明之间的相对位置无关</li>
<li><strong>如果类的成员用到友元函数，友元函数必须在<code>类定义之前</code>声明或者在<code>成员函数类外定义之前</code>定义</strong>，总之，要保证友元函数要在成员函数定义之前可见</li>
</ul>
</blockquote>
<h3 id="7-3、类的其他特性">7.3、类的其他特性</h3>
<h4 id="7-3-1、类的作用域">7.3.1、类的作用域</h4>
<p>在类的作用域之外，普通数据和函数成员只能由<strong>对象、引用或者指针</strong>使用<code>成员运算符</code>访问，类的<code>类型成员</code><strong>使用<code>作用域</code>运算符访问，跟在运算符之后的名字都必须是对应类的成员</strong></p>
<p>在类的外部，成员的名字都被<strong>隐藏起来</strong>，一旦遇到类名，定义的剩余部分(参数列表、函数体，<strong>但不包括函数返回类型</strong>)就在类的作用域之内了，可以<strong>直接</strong>使用类内的其他成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在Window_mgr::之后，就处于类内，ScreenIndex可以直接使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span> </span>{ </span><br><span class="line">    Screen &amp;s = screen[i]; <span class="comment">// Window_mgr类内的screen[i]成员直接访问</span></span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.height * s.width, <span class="string">' '</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>函数的返回类型通常出现在<strong>函数名之前</strong>，在类外部定义成员函数时，<strong>返回类型中使用的名字都位于类作用域之外，<code>返回类型必须指明是哪个类的成员</code></strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="keyword">const</span> Screen&amp;)</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 在类外定义成员函数</span></span><br><span class="line">Window_mgr::ScreenIndex <span class="comment">// 返回类型使用的名字位于类外，必须指明属于哪个类   </span></span><br><span class="line">Window_mgr::<span class="built_in">addScreen</span>(<span class="keyword">const</span> Screen&amp; s) {}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="7-3-1-1、名字查找与类的作用域">7.3.1.1、名字查找与类的作用域</h5>
<p><strong>名字查找</strong>(寻找与所用名字最匹配的声明过程)的过程：</p>
<ul>
<li>首先，在名字所在的块中寻找其声明语句，<strong>只考虑在名字的使用<code>之前</code>出现的声明</strong></li>
<li>如果没找到，继续查找外层作用域</li>
<li>如果最终没找到匹配的声明，则程序报错</li>
</ul>
<p>类的<strong>定义</strong>分两步处理：</p>
<ul>
<li>首先，编译成员的声明</li>
<li>直到类全部可见后才编译函数体  ===&gt;&gt;&gt;&gt;  成员函数可以使用类内任何数据成员</li>
</ul>
<p>对于类内<strong>成员函数</strong>，解析其中名字的方式(<strong>只适用于成员函数的名字查找</strong>)：</p>
<ul>
<li>首先，在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才被考虑</li>
<li>如果在成员函数内没找到，则在类内继续查找，<strong>类的所有成员都可以被考虑</strong>&lt;区别之处&gt;</li>
<li>如果类内也没找到该名字的声明，在成员函数之前的作用域内继续查找</li>
</ul>
<p>上述的方式只适用于成员函数中(<code>函数体</code>)使用的名字，<strong>声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line">string bal;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>{ <span class="keyword">return</span> bal; } <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal; <span class="comment">// Money在使用之前，需要可见</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211120153656589.png" alt="image-20211120153656589" style="zoom:80%;">
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211120154111789.png" alt="image-20211120154111789" style="zoom:80%;">
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211120153904546.png" alt="image-20211120153904546" style="zoom:80%;">
<p>一般来说，内层作用域可以重新定义外层作用域的名字，即使该名字已经在内层作用域使用过。<strong>然而在类中，如果成员使用了外层作用域中的某个名字，而这个名字代表一种类型，则类内不能在之后重新定义该名字</strong></p>
<blockquote>
<p><strong>Tips</strong>：类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后</p>
</blockquote>
<p>如果类内、类外还有相同的变量名，可以通过<code>this-&gt;</code>或<code>类名::</code>来指明使用的是类内变量</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span> </span>{</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height;</span><br><span class="line">    cursor = width * Screen::height;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以通过作用域运算符来指定哪个区域的名字：</p>
<ul>
<li>全局作用域：<code>::变量名</code></li>
<li>其他类：<code>类名::成员名</code></li>
</ul>
<p>当<strong>成员定义在类的外部</strong>时，名字查找的第三步不仅要考虑定义之前的全局作用域中的声明，<strong>还需要考虑在成员函数<code>定义之前</code>的全局作用域中的声明</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> string::size_type pos;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(pos)</span></span>;</span><br><span class="line">    pos height = <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"><span class="function">Screen::pos <span class="title">verify</span><span class="params">(Screen::pos)</span></span>; <span class="comment">// verify对Screen类的定义是不可见的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::setHeight</span><span class="params">(pos var)</span> </span>{ <span class="comment">// 成员函数定义之前的全局作用域中声明了verify</span></span><br><span class="line">    height = <span class="built_in">verify</span>(var);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="7-3-2、聚合类">7.3.2、聚合类</h4>
<p>当一个类满足如下条件时，这个类是聚合的：</p>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，也没有virtual函数</li>
</ul>
<p>聚合类具有特殊的初始化语法形式，可以使用<strong>花括号括起来的成员初始值列表来初始化聚合类的数据成员</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Data vall = {<span class="number">0</span>, <span class="string">"Anna"</span>};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>初始值的顺序必须与声明的顺序一致</strong>，与初始化数组元素的规则一样，不允许初始值列表的元素个数超过类的成员数量</p>
<h4 id="7-3-3、字面值常量类">7.3.3、字面值常量类</h4>
<p><strong>数据成员都是<code>字面值类型</code>的<code>聚合类</code>是字面值常量类</strong>，对于非聚合类来说，符合下述要求，也是一个字面值常量类：</p>
<ul>
<li>数据成员都必须是<a href="#1.1.4.4%E3%80%81constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">字面值类型</a></li>
<li>类必须<strong>至少含有一个constexpr构造函数</strong></li>
<li>如果一个数据成员含有<strong>类内初始值</strong>，则<strong>内置类型成员的初始值必须是一条<code>常量表达式</code></strong>；或者如果成员属于某种类类型，则初始值必须使用<strong>成员自己的constexpr构造函数</strong></li>
<li>类必须使用<strong>析构函数的默认定义</strong></li>
</ul>
<p>尽管构造函数不能是<code>const</code>的，但是<strong>字面值常量类的构造函数可以是<code>constexpr</code>函数</strong>。<code>constexpr</code>构造函数可以声明成<code>= default</code>的形式，否则<code>constexpr</code>构造函数必须既符合构造函数的要求(不能包含返回语句)，又要符合<code>constexpr</code>函数的要求(能拥有的唯一可执行语句就是返回语句)，所以<strong>constexpr构造函数体应该是空的</strong>。</p>
<p>使用前置关键字<code>constexpr</code>就可以声明一个<code>constexpr</code>构造函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="keyword">bool</span> b = <span class="literal">true</span>)</span> : hw(b), io(b), other(b) {</span>}</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="keyword">bool</span> h, <span class="keyword">bool</span> i,, <span class="keyword">bool</span> o)</span> : hw(b), io(b), other(b) {</span>}</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> hw;</span><br><span class="line">    <span class="keyword">bool</span> io;</span><br><span class="line">    <span class="keyword">bool</span> other;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><code>constexpr</code>构造函数必须<strong>初始化所有数据成员</strong>，可以通过初始值或者使用constexpr构造函数或者一条常量表达式的形式</p>
<p><code>constexpr</code>构造函数用于生成<code>constexpr</code>对象以及<code>constexpr</code>函数的参数或返回类型</p>
<h4 id="7-3-4、-star-类的静态成员-类成员、类属性">7.3.4、<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>类的静态成员(类成员、类属性)</h4>
<h5 id="7-3-4-1、声明静态成员">7.3.4.1、声明静态成员</h5>
<p>在成员的声明之前加上关键字<code>static</code>使得其与类类型关联在一起，静态成员可以是<code>public</code>或者<code>private</code>的，静态数据成员的类型可以是常量、引用、指针、类类型等</p>
<p><strong>类的静态成员存在于任何对象之外</strong>，对象中不包含任何与静态数据成员有关的数据。静态成员函数也不与任何对象绑定在一起，不包含<code>this</code>指针，<strong>静态成员函数不能声明为const的</strong>，不能在静态成员函数体内使用<code>this</code>指针</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>{ <span class="keyword">return</span> interestRate; }</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string owner;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h5 id="7-3-4-2、使用静态成员成员">7.3.4.2、使用静态成员成员</h5>
<p>使用<strong>作用域运算符</strong>直接访问静态成员：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> r = Account::<span class="built_in">rate</span>(); <span class="comment">// 使用作用域运算符访问静态成员</span></span><br></pre></td></tr></tbody></table></figure>
<p>虽然<strong>静态成员</strong>不属于类的某个对象，但仍然可以<strong>使用类的对象、引用或者指针来访问静态成员</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">// 因为静态成员属于类，是所有类的对象共享的，所以可以访问</span></span><br><span class="line">r = ac1.<span class="built_in">rate</span>(); <span class="comment">// 通过对象的引用访问</span></span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>(); <span class="comment">// 通过对象的指针访问</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>成员函数不用通过作用域运算符就能直接使用静态成员</strong></p>
<h5 id="7-3-4-3、定义静态成员">7.3.4.3、定义静态成员</h5>
<p>当在类外定义静态成员函数时，不能重复<code>static</code>关键字，<code>static</code>只能出现在类内部的声明语句，<strong>指向类外部的静态成员时，必须指明成员所属的类名</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Account::rate</span><span class="params">(<span class="keyword">double</span> newRate)</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure>
<p>类似于全局变量，静态数据成员定义在任何函数之外，一旦被定义，就将一直存在于程序的整个声明周期中</p>
<p>静态数据成员不属于任何对象，不能通过构造函数初始化</p>
<ul>
<li>一般来说，不能在类内初始化静态成员，必须在类的外部定义和初始化每一个静态成员，一个静态成员只能定义一次</li>
<li>特殊情况：
<ol>
<li><code>const整数类型(bool,char,int,short,long等)</code>的静态数据成员<code>可以</code>使用<strong>类内初始值来初始化，<code>也可以</code>类外定义和初始化</strong></li>
<li><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><code>constexpr</code>静态成员<code>必须</code>使用<strong>类内初始值来初始化</strong></li>
</ol>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 一般情况：类内声明，类外定义初始化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account1</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interesrRate;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">double</span> Account1::interestRate = <span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊情况：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account2</span> {</span></span><br><span class="line">    <span class="comment">// static const int period = 30; // const整数类型可以使用类内初始值初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> period;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Account2::period = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account3</span> {</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> period = <span class="number">30</span>; <span class="comment">// constexpr类型只能使用类内初始值初始化</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如果某个静态成员的应用场景仅限于编译器可以替代它的值的情况，则一个初始化的const或constexpr不需要分别定义。相反，<strong>如果将它用于值不能替代的场景中，则该成员必须有一条定义语句</strong></p>
<p><strong>如果在类的内部提供了一个初始值，则成员的<code>定义不能再指定一个初始值</code>了</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> s = <span class="number">12</span>; <span class="comment">// 类内指定了初始值</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Account::s; <span class="comment">// 类外定义不能再指定初始值</span></span><br></pre></td></tr></tbody></table></figure>
<p>静态数据成员可以是<a href="#buwanquanleixing">不完全类型</a>，静态数据成员的类型可以是它<strong>所属的类类型</strong>，而非静态数据成员则受到限制，只能声明成它所属类的指针或引用</p>
<p>静态成员可以作为<strong>默认实参</strong>，非静态成员不能作为默认实参</p>
<h2 id="9、顺序容器">9、顺序容器</h2>
<p>顺序容器为程序员提供了<strong>控制元素存储和访问顺序</strong>的能力，这种顺序不依赖于元素的值，而是<strong>与元素加入容器时的位置</strong>相对应</p>
<h3 id="9-1、顺序容器概述">9.1、顺序容器概述</h3>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207185608218.png" alt="image-20211207185608218"></p>
<p><code>array</code>的大小是固定的，其他容器都提供高效、灵活的内存管理，可以添加和删除元素，扩张和收缩容器的大小</p>
<p><code>string</code>和<code>vector</code>将元素保存在<strong>连续的内存空间</strong>中，支持<code>下标</code>来快速访问元素，但在容器<strong>中间</strong>添加和删除元素非常费时，需要移动所有在插入或删除位置之后的元素，有时还需要<strong>分配额外的存储空间</strong>，每个元素都得移动到新的存储空间</p>
<p><code>list</code>和<code>forward_list</code>可以随意添加和删除元素，但不支持随机访问，<strong>比<code>vector、deque、array</code>的额外内存开销要大</strong></p>
<p><code>deque</code>支持<strong>快速访问</strong>，在容器中间插入和删除元素的代价高，但<strong>在容器<code>两端</code>插入和删除元素代价低</strong></p>
<p><code>array</code><strong>不支持添加和删除元素已经更改容器大小的操作</strong>，<code>forward_list</code><strong>没有<code>size</code>操作</strong></p>
<h3 id="9-2、容器库概览">9.2、容器库概览</h3>
<p>顺序容器几乎可以保存任意类型的元素，<strong>可以为不支持特定操作需求的类型定义容器，但只能使用那些没有特殊要求的容器操作</strong></p>
<h4 id="9-2-1、迭代器">9.2.1、迭代器</h4>
<p>与容器一样，迭代器有着公共的接口：如果一个迭代器提供某种操作，那么所有提供相同操作的迭代器对这个操作的实现方式是相同的。</p>
<p><strong>迭代器支持的运算</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207193251630.png" alt="image-20211207193251630"></p>
<p><strong>迭代器范围</strong>：是由两个迭代器表示，两个迭代器分别指向同一个容器中的元素或者<code>尾元素之后</code>的位置(<code>end</code>)，采用的是<code>左闭右开</code>区间</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207192640212.png" alt="image-20211207192640212"></p>
<p><code>begin</code>生成指向第一个元素位置迭代器，<code>end</code>生成指向尾元素之后位置的迭代器；迭代器<code>begin、end</code>必须<strong>指向相同的容器</strong></p>
<p>带<code>r</code>开头的迭代器返回<code>反向</code>迭代器，以<code>c</code>开头的迭代器返回<code>const</code>迭代器</p>
<p><strong>当<code>auto</code>和<code>begin、end</code>结合使用时，获得的迭代器类型依赖于容器类型(<code>const</code>或<code>非const</code>)，但以<code>c</code>开头的版本总是能够获得<code>const_iterator</code>的，而不管容器的类型是什么</strong></p>
<p><strong>所有的迭代器操作不会生成元素，只能生成元素的引用</strong></p>
<blockquote>
<p><strong>注</strong>：<code>forward_list</code>容器的迭代器不支持<code>--</code>操作</p>
</blockquote>
<h5 id="9-2-1-1、插入迭代器">9.2.1.1、插入迭代器</h5>
<p>插入器是一种<strong>迭代器适配器</strong>，接受一个容器，生成一个迭代器，能实现向给定容器添加元素；当通过一个插入迭代器进行<strong>赋值时</strong>，该迭代器<strong>调用容器操作</strong>来向给定容器的指定位置<strong>插入</strong>一个元素</p>
<p><strong>插入迭代器的操作</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208163158514.png" alt="image-20211208163158514" style="zoom: 67%;">
<p><strong>插入器的种类</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208163557975.png" alt="image-20211208163557975" style="zoom: 67%;">
<p>只有在容器支持<code>push_back, push_front, insert</code>的情况下，才可以使用相对应的插入器</p>
<p>当调用<code>inserter(c, iter)</code>时，得到一个迭代器，使用这个迭代器时，会将元素插入到<code>iter</code>原来所指向的元素之前的位置</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = <span class="built_in">inserter</span>(c, iter);</span><br><span class="line">*it = val; <span class="comment">// 等价于 it = val</span></span><br><span class="line"><span class="comment">///////    等价操作   ///////</span></span><br><span class="line">it = c.<span class="built_in">insert</span>(it, val);</span><br><span class="line">++it</span><br></pre></td></tr></tbody></table></figure>
<h5 id="9-2-1-2、iostream迭代器">9.2.1.2、iostream迭代器</h5>
<p><code>istream_iterator</code>读取输入流，<code>ostream_iterator</code>向一个输出流写数据。这些迭代器将它们对应的流<strong>当作一个特定类型的元素序列</strong>来处理，通过使用流迭代器，可以用泛型算法从流对象读取数据以及向其写数据</p>
<h6 id="9-2-1-2-1、istream-iterator操作">9.2.1.2.1、istream_iterator操作</h6>
<p>当创建流迭代器时，必须<strong>指定迭代器将要读写的对象类型</strong>，<code>istream_iterator</code>要读取的类型必须定义了输入运算符，当创建一个<code>istream_iterator</code>时，可以将它绑定到一个流；如果<strong>默认初始化</strong><code>istream_iterator</code>迭代器，创建一个可以当作<strong>尾后值</strong>使用的迭代器</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(cin)</span></span>; <span class="comment">// 指明要读写的对象类型int，绑定到输入流cin上</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof; <span class="comment">// 尾后迭代器</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以用<code>istream_iterator</code>从标准输入读取数据</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_eof;</span><br><span class="line"><span class="keyword">while</span> (in_iter != in_eof) {</span><br><span class="line">    vec.<span class="built_in">push_back</span>(*in_iter++); <span class="comment">// 从标准输入读取数据</span></span><br><span class="line">} </span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec1</span><span class="params">(in_iter, in_eof)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>istream_iterator</code>的操作：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208175709004.png" alt="image-20211208175709004" style="zoom:67%;">
<h6 id="9-2-1-2-2、ostream-iterator操作">9.2.1.2.2、ostream_iterator操作</h6>
<p>可以对任何具有输出运算符<code>&lt;&lt;</code>的类型定义<code>ostream_iterator</code>，当创建一个<code>ostream_iterator</code>时，可以提供(可选的)第二参数，它是一个字符串，在<strong>输出每个元素后都会打印此字符串</strong>，此字符串必须是一个<strong>C风格字符串</strong>，<strong>必须将<code>ostream_iterator</code>绑定到一个指定的流</strong>，不允许<strong>空的或表示尾后位置</strong>的<code>ostream_iterator</code></p>
<p><strong>ostream_iterator操作</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208181408222.png" alt="image-20211208181408222" style="zoom:67%;">
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">" "</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec) {</span><br><span class="line">    *out_iter++ = e;</span><br><span class="line">    <span class="comment">// out_iter = e; // 使用 = 时，会将值写入到所绑定的流中</span></span><br><span class="line">    <span class="comment">// *out_iter = e; // *out_iter, out_iter++, ++out_iter都是一样的效果</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：对于插入迭代器和输出流迭代器的<code>*、++</code>操作都是无效的，因为使用<code>=</code>时，可以直接将元素插入到容器或流中；</p>
</blockquote>
<h5 id="9-2-1-3、反向迭代器">9.2.1.3、反向迭代器</h5>
<p>反向迭代器是在容器中<strong>从尾元素向首元素反向移动</strong>的迭代器，<strong>递增</strong>一个反向迭代器会移动到<strong>前一个元素</strong>，<strong>递减</strong>一个迭代器会移动到<strong>下一个元素</strong>，除了<code>forward_list</code>外，其他容器都支持反向迭代器，可以通过成员函数<code>rbegin, rend, crbegin, crend</code>获取反向迭代器</p>
<p>只能从既支持<code>++</code>也支持<code>--</code>的迭代器来定义反向迭代器，不能从一个<code>流迭代器</code>创建反向迭代器</p>
<p><code>reverse_iterator</code>的<code>base</code>成员函数可以<strong>将反向迭代器转换为普通迭代器</strong>，使用反向迭代器，遍历顺序总是从后往前，使用普通迭代器，遍历顺序总是从前往后</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208183522198.png" alt="image-20211208183522198" style="zoom:67%;">
<h4 id="9-2-2、容器类型成员">9.2.2、容器类型成员</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207192459063.png" alt="image-20211207192459063"><strong>使用这些类型，需要显示使用<code>类名::</code></strong></p>
<h4 id="9-2-3、容器的定义和初始化">9.2.3、容器的定义和初始化</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207195658431.png" alt="image-20211207195658431"></p>
<p>除了<code>array</code>外，其他所有容器的默认构造函数都会创建一个指定类型的<code>空容器</code></p>
<p>创建<strong>一个容器</strong>为另一个容器的<strong>拷贝</strong>，<strong>两个容器的类型及其元素类型必须相等</strong>；</p>
<p>当<strong>传递迭代器参数</strong>来拷贝一个范围时，不要求<strong>容器类型</strong>必须相同，并且新容器和原容器的<strong>元素类型</strong>可以不同，<strong>只要能将拷贝的元素转换为要初始化的容器的元素类型即可</strong></p>
<p><code>顺序容器</code>还提供了接受<strong>一个容器大小和一个(可选的)元素初始值</strong>，如果不提供元素初始值，标准库会创建一个<strong>值初始化器</strong>。如果元素类型是内置类型或者具有默认构造函数的类类型，可以只为构造函数提供一个容器大小的参数，<strong>如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个<code>显式的</code>元素初始值(用来调用相关的构造函数)</strong></p>
<p>与内置数组一样，<code>array</code>的<strong>大小</strong>也是类型的一部分，当定义一个<code>array</code>时，除了指定元素类型，还要指定容器大小</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>, 3&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>默认构造的<code>array</code>是非空的，包含了与其大小一样多的元素，这些元素都被<code>默认初始化</code>；如果对<code>array</code>进行列表初始化，不够的部分会进行<code>值初始化</code></p>
<p><strong>不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制，但要求类型和大小必须相等</strong></p>
<h4 id="9-2-4、赋值和swap">9.2.4、赋值和swap</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207202444102.png" alt="image-20211207202444102"></p>
<p>可以用<code>花括号</code>包围的值列表对<code>array</code>进行<strong>初始化</strong>，但<strong>不允许进行赋值</strong></p>
<p><code>assign</code>允许从一个<strong>不同的但相容</strong>的类型赋值，或者从<strong>容器的一个子序列</strong>赋值，<code>assign</code>操作用参数指定的元素(的拷贝)替换左边容器中的<strong>所有元素</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle; <span class="comment">// 错误：容器类型不同</span></span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(), oldstyle.<span class="built_in">cend</span>());</span><br></pre></td></tr></tbody></table></figure>
<p><code>seq.assign(n, t)</code>接收一个整型值和元素值，用指定数目(<strong>数目可以多于原来的数目</strong>)具有相同给定值的元素替换容器中原有的元素</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">list&lt;string&gt; <span class="title">slists</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 1个元素，为空string</span></span><br><span class="line">slists.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="string">"Hiya"</span>); <span class="comment">// 10个元素，每个都是Hiya</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>swap</code>操作交换两个<strong>相同类型</strong>容器的内容，<strong>交换两个容器内容的操作保证会很快，是因为元素本身并未交换，只是交换了两个容器的内部数据结构</strong></p>
<p><strong>元素不会移动意味着，除<code>string</code>外，指向容器的迭代器、引用、指针在swap操作之后都不会失效，仍然指向swap<code>操作之前</code>所指向的元素，但是，在swap之后，这些元素已经属于不同的容器了</strong>；</p>
<p><strong>swap两个<code>array</code>会真正交换它们的元素，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换</strong></p>
<p><strong>对<code>string</code>调用swap会导致迭代器、引用、指针失效</strong></p>
<blockquote>
<p><strong>Tips</strong>：统一使用非成员版本的<code>swap(a, b)</code></p>
</blockquote>
<h4 id="9-2-5、容器大小操作">9.2.5、容器大小操作</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207205336900.png" alt="image-20211207205336900"></p>
<h4 id="9-2-6、关系运算符">9.2.6、关系运算符</h4>
<p><strong><code>每个容器类型</code>都支持相等运算符</strong>，关系运算符<strong>左右两边的运算对象必须是<code>相同类型的容器</code>，且必须保存<code>相同类型的元素</code></strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207205938015.png" alt="image-20211207205938015"></p>
<p>容器的相等运算符实际上是使用元素的==运算符实现比较的，而<strong>其他关系运算符是使用元素的<code>&lt;</code>运算符</strong>；<strong>如果元素类型不支持所需运算符，那么<code>保存这种元素的容器</code>就不能使用相应的关系运算</strong></p>
<h3 id="9-3、顺序容器操作">9.3、顺序容器操作</h3>
<h4 id="9-3-1、向顺序容器添加元素">9.3.1、向顺序容器添加元素</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207210828380.png" alt="image-20211207210828380"></p>
<h5 id="9-3-1-1、使用push-back-push-front">9.3.1.1、使用push_back, push_front</h5>
<p>除了<code>array, forward_list</code>外，每个顺序容器(包括string)都支持<code>push_back</code></p>
<p><code>list、forward_list、deque</code>支持<code>push_front</code>，其他容器不支持</p>
<blockquote>
<p><strong>说明</strong>：<code>push_front、push_back</code>插入的是<strong>元素</strong>，对于<code>string</code>插入的是<code>char</code>类型</p>
</blockquote>
<h5 id="9-3-1-2、在容器中的特定位置添加容器">9.3.1.2、在容器中的特定位置添加容器</h5>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207213236993.png" alt="image-20211207213236993"></p>
<p><strong>如果传递给insert一对迭代器，它们不能指向添加元素的目标容器</strong></p>
<p><code>insert</code>成员函数的返回值都是指向所插入的<strong>第一个元素的迭代器</strong></p>
<p>当用一个对象来初始化容器，或将一个对象插入到容器中时，实际上放入到容器中的是对象的<a href="#charushifangruyigekaobei">一个拷贝</a></p>
<p><code>emplace、emplace_front、emplace_back</code>这些操作是<code>构造</code>而不是拷贝元素，当调用<code>push, insert</code>成员函数时，将元素类型的对象拷贝到容器中，调用一个<code>emplace</code>成员函数时，则是将参数传递给<strong>元素类型的构造函数</strong>，<code>emplace</code>使用这些参数在容器管理的内存空间中直接构造元素</p>
<p><code>emplace</code>函数的<strong>参数必须与元素类型的构造函数相匹配</strong></p>
<h4 id="9-3-2、访问元素">9.3.2、访问元素</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207220118583.png" alt="image-20211207220118583"></p>
<p>包括<code>array</code>在内的每个<strong>顺序容器</strong>都有一个<code>front</code>成员函数，除<code>forward_list</code>外的所有顺序容器都有一个<code>back</code>成员函数，这两个操作分别<strong>返回首元素和尾元素的引用</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val1 = c.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">auto</span> val2 = *c.<span class="built_in">begin</span>(); <span class="comment">// val1和val2都是第一个元素的拷贝</span></span><br><span class="line"><span class="keyword">auto</span> val3 = c.<span class="built_in">back</span>();</span><br><span class="line"><span class="keyword">auto</span> val4 = *(--c.<span class="built_in">end</span>()); <span class="comment">// val3和val4都是最后一个元素的拷贝，但不适用于forward_list容器</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注</strong>：如果容器为空，调用成员函数<code>front、back</code>将发生段错误，类似于使用越界的下标</p>
</blockquote>
<h4 id="9-3-3、删除元素">9.3.3、删除元素</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207220419875.png" alt="image-20211207220419875"></p>
<p>删除<code>deque</code>中除首尾元素之外的任何元素都会使所有迭代器、引用、指针失效；指向<code>vector或string</code>中删除点<code>之后</code>位置的迭代器、引用、指针都会失效</p>
<h4 id="9-3-4、特殊的forward-list操作">9.3.4、特殊的forward_list操作</h4>
<p>在一个单向链表中，没有简单的方法来获取一个元素的前驱，所以在一个<code>forward_list</code>中添加或删除元素的操作是<strong>通过改变<code>给定元素之后</code>的元素来完成的</strong></p>
<p><code>forward_list</code>没有提供<code>insert、emplace、erase</code>操作，而提供下面的操作：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207221647497.png" alt="image-20211207221647497"></p>
<p><code>forward_list</code>容器的所有插入和删除操作的返回值都指向<code>前驱</code>位置，对于<code>***_after</code>操作中指定的位置都不能是<code>end()</code>，否则是未定义的</p>
<h4 id="9-3-5、改变容器的大小">9.3.5、改变容器的大小</h4>
<p><code>resize</code>操作接受一个<strong>可选的</strong>元素值参数，用来初始化添加到容器中的<code>新元素</code>，如果未提供此参数，<code>新元素</code>进行<code>值初始化</code>，如果容器保存的是类类型元素，且resize向容器添加新元素，必须提供初始值或者提供默认构造函数</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207222513286.png" alt="image-20211207222513286"></p>
<h4 id="9-3-6、容器操作可能使迭代器失效">9.3.6、容器操作可能使迭代器失效</h4>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207222850871.png" alt="image-20211207222850871" style="zoom:67%;">
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207223414843.png" alt="image-20211207223414843" style="zoom: 67%;">
<p>当添加或删除vector或string的元素后，或在deque中首元素之外任何位置添加或删除元素后，原来的<code>end()</code>返回的迭代器总会失效，需要在循环程序中反复调用<code>end()</code>，而不能在循环之前保存<code>end()</code>返回的迭代器</p>
<h3 id="9-4、vector对象是如何增长的">9.4、vector对象是如何增长的</h3>
<p>标准库实现者采用了可以<strong>减少容器空间重新分配次数</strong>的策略，当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间(2倍扩容法)</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211207230934643.png" alt="image-20211207230934643"></p>
<p>只有当需要的内存空间<strong>超过</strong>当前容量时，reserve调用才会改变vector的容量，reserve<strong>至少</strong>分配与需求一样大的内存空间</p>
<p>如果需求大小<strong>小于或等于</strong>当前容量，reserve什么也不做，容器也不会退回内存空间</p>
<p>resize成员函数<strong>只改变容器中元素的数目</strong>，而不是容器的容量</p>
<p>调用<code>shrink_to_fit</code>只是一个请求，标准库并不保存退还内存</p>
<p><strong>每个vector实现都可以选择自己的内存分配策略，但必须遵守的一条原则是：只有当<code>迫不得已</code>时才可以分配新的内存空间</strong></p>
<h3 id="9-5、容器适配器">9.5、容器适配器</h3>
<p>顺序容器的适配器：<code>stack、queue、priority_queue</code></p>
<p><strong>一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样</strong>，一个容量适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型</p>
<h4 id="9-5-1、定义一个适配器">9.5.1、定义一个适配器</h4>
<p>每个适配器都定义两个构造函数：</p>
<ul>
<li>默认构造函数创建一个空对象</li>
<li>接受一个<code>容器</code>的构造函数拷贝该容器来初始化适配器</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line"><span class="function">stack&lt;<span class="keyword">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>; <span class="comment">// 从deq拷贝元素到stk</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>默认情况下，<code>stack, queue</code>都是基于<code>deque</code>实现的，<code>priority_queue</code>是基于<code>vector</code>实现的</strong></p>
<p>在创建一个适配器时可以将一个命名的<strong>顺序容器</strong>作为第二个类型参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk2;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>对于一个给定的适配器，可以使用哪些容器是有限制的，所有的适配器都要求<code>容器有添加、删除元素和访问尾元素</code>的能力</strong>，不能用<code>array</code>和<code>forward_list</code>来构造适配器</p>
<h4 id="9-5-2、栈适配器">9.5.2、栈适配器</h4>
<p><code>stack</code>只要求<code>push_back, pop_back, back</code>操作，可以使用<code>vector, deque, list</code>来构造stack</p>
<p><strong>栈的操作</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208004702497.png" alt="image-20211208004702497"></p>
<h4 id="9-5-3、队列适配器">9.5.3、队列适配器</h4>
<p><code>queue</code>只要求<code>push_front, pop_back, back, front</code>操作，可以使用<code>deque, list</code>来构造queue</p>
<p><strong>队列的操作</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208004752551.png" alt="image-20211208004752551"></p>
<p><code>priority_queue</code>只要求<code>front, push_back, pop_back, 随机访问能力</code>操作，可以使用<code>vector, deque</code>来构造priority_queue</p>
<h2 id="10、泛型算法">10、泛型算法</h2>
<h3 id="10-1、概述">10.1、概述</h3>
<p>大多数算法都定义在头文件<code>algorithm</code>和<code>numeric</code>中</p>
<p>一般情况下，算法并<strong>不直接操作容器</strong>，而是遍历<strong>由两个迭代器指定的一个元素范围</strong>来进行操作</p>
<p><strong>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作</strong>，例如<code>find</code>算法用元素类型的<code>==</code>运算符完成每个元素与给定值的比较</p>
<p><strong>算法永远不会执行容器的操作，不会改变底层容器的大小，不会<code>直接</code>添加、删除元素</strong></p>
<h3 id="10-2、初始泛型算法">10.2、初始泛型算法</h3>
<h4 id="10-2-1、只读算法">10.2.1、只读算法</h4>
<h5 id="10-2-1-1、accumulate算法">10.2.1.1、accumulate算法</h5>
<p><code>accumulate</code>算法定义在头文件<code>numeric</code>中，用来求一组数据的和；</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * accumulate接受三个参数：</span></span><br><span class="line"><span class="comment"> * 		前两个参数指出需求和的元素的范围</span></span><br><span class="line"><span class="comment"> *		第三个参数是和的初值</span></span><br><span class="line"><span class="comment"> * 返回值的类型由第三个参数的类型决定</span></span><br><span class="line"><span class="comment"> * 第三个参数也决定使用哪个加法运算符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(), <span class="number">0</span>); </span><br></pre></td></tr></tbody></table></figure>
<p><code>accumulate</code>将第三个参数作为<strong>求和起点</strong>，<strong>序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), c.<span class="built_in">cend</span>(), <span class="string">""</span>); <span class="comment">// 错误：""是const char *类型，字符串字面值没有+运算符</span></span><br><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), c.<span class="built_in">cend</span>(), <span class="built_in">string</span>(<span class="string">""</span>)); <span class="comment">// 正确 </span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="10-2-1-2、equal算法">10.2.1.2、equal算法</h5>
<p><code>equal</code>算法用于确定两个序列是否保存相同的值，只有<strong>所有元素相等</strong>，才返回<code>true</code>，否则返回<code>false</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * equal接受三个参数：</span></span><br><span class="line"><span class="comment"> *		前两个表示第一个序列的范围</span></span><br><span class="line"><span class="comment"> * 		第三个表示第二个序列的首元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">equal</span>(r.<span class="built_in">cbegin</span>(), r.<span class="built_in">cend</span>(), s.<span class="built_in">cbegin</span>()); <span class="comment">// 返回值为bool类型</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>equal</code>是通过迭代器完成操作，可以通过调用<code>equal</code>来比较<strong>两个不同类型</strong>的容器中的元素，而且元素也不必一样，只要能通过<code>==</code>来比较两个元素类型即可</p>
<p><code>equal</code>假定第二个序列<strong>至少与第一个序列一样长</strong>，以第一个序列为基准，比较完第一个序列的所有元素就停止比较操作</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string s1 = <span class="string">"asdfgh"</span>;</span><br><span class="line">string s2 = <span class="string">"asdfghjkl"</span>;</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="built_in">equal</span>(s1.<span class="built_in">cbegin</span>(), s1.<span class="built_in">cend</span>(), s2.<span class="built_in">cbegin</span>()); <span class="comment">// 结果为true，s1所有元素与s2对应位置的元素都相等</span></span><br><span class="line"><span class="keyword">int</span> a2 = <span class="built_in">equal</span>(s2.<span class="built_in">cbegin</span>(), s2.<span class="built_in">cend</span>(), s1.<span class="built_in">cbegin</span>()); <span class="comment">// 结果为false，s2后面的元素在s1中没有对应的元素</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：只接受一个<strong>单一迭代器</strong>来表示<strong>第二个序列</strong>的算法，都假定第二个序列<strong>至少</strong>与第一个序列一样长</p>
</blockquote>
<h4 id="10-2-2、写容器元素的算法">10.2.2、写容器元素的算法</h4>
<p>一些算法将新值赋予序列中的元素，必须<strong>保证序列原大小<code>至少不小于</code>要求算法写入的元素数目</strong></p>
<p>一些算法会自动向输入范围写入元素，这些算法本质上并不危险，最多写入与给定序列一样多的元素</p>
<h5 id="10-2-2-1、back-inserter">10.2.2.1、back_inserter</h5>
<p>插入迭代器是一种向容器添加元素的迭代器，通常情况，通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素，而<strong>通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被<code>添加</code>到容器中</strong></p>
<p><code>back_inserter</code>是一个函数，定义在头文件<code>iterator</code>中，<strong>接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器</strong>，当通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_iterator</span>(res);</span><br><span class="line">*it = <span class="number">42</span>; <span class="comment">// res中添加一个元素42</span></span><br></pre></td></tr></tbody></table></figure>
<p>常常使用<code>back_iterator</code>来创建一个迭代器，作为算法的目的位置来使用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_iterator</span>(vec), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<h5 id="10-2-2-2、拷贝算法">10.2.2.2、拷贝算法</h5>
<p>拷贝算法是一个向目的位置迭代器指向的输出序列中的元素写入数据的算法</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * copy算法接受三个参数：</span></span><br><span class="line"><span class="comment"> *		前两个参数表示一个输入范围</span></span><br><span class="line"><span class="comment"> *		第三个参数表示目的序列的起始位置，目的序列</span></span><br><span class="line"><span class="comment"> * 返回的是目的位置迭代器(递增后)的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> a1[] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="keyword">int</span> a2[<span class="built_in"><span class="keyword">sizeof</span></span>(a1) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)];</span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1), <span class="built_in">end</span>(a1), a2); <span class="comment">// 把a1的内容拷贝给a2</span></span><br></pre></td></tr></tbody></table></figure>
<p>多个算法都提供所谓的<code>拷贝(_copy)</code>版本，这些算法计算新元素的值，但<strong>不会将它们放置在输入序列的末尾，而是创建一个<code>新序列</code>保存这些结果</strong></p>
<h5 id="10-2-3、重排容器元素的算法">10.2.3、重排容器元素的算法</h5>
<h5 id="10-2-3-1、sort算法">10.2.3.1、sort算法</h5>
<p><code>sort</code>算法接受两个迭代器，表示要排序的元素范围</p>
<h5 id="10-2-3-2、unique算法">10.2.3.2、unique算法</h5>
<p><code>unique</code>算法重排输入序列，将<strong>相邻的重复项消除</strong>，<code>unique</code>算法不会改变容器的大小，并返回一个<strong>指向不重复值范围末尾</strong>的迭代器，此位置之后的元素仍然存在，但这些值是未定义的</p>
<h3 id="10-3、定制操作">10.3、定制操作</h3>
<h4 id="10-3-1、向算法传递函数">10.3.1、向算法传递函数</h4>
<p><code>谓词</code>是一个<code>可调用</code>的<strong>表达式</strong>，其返回结果是一个能用作条件的值；标准库算法所使用的谓词分为两类：一元谓词(只接受单一参数)、二元谓词(接受两个参数)；<strong>接受谓词参数的算法，对输入序列中的元素调用谓词</strong>，元素类型必须能转换为谓词的参数类型</p>
<p>根据<strong>算法接受一元谓词还是二元谓词</strong>，<strong>传递给算法的谓词必须严格接受一个或两个参数</strong></p>
<h4 id="10-3-2、lambda表达式">10.3.2、lambda表达式</h4>
<p>对于一个对象或表达式，如果可以<strong>对其使用调用运算符</strong>，则称它是可调用的；<strong>可以向一个算法传递<code>任何类型</code>的可调用对象</strong></p>
<p>可调用对象可以是<strong>函数、函数指针、重载函数调用运算符的类、lambda表达式</strong></p>
<p>一个<code>lambda</code>表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数，与任何函数类似，一个<code>lambda</code>具有一个返回类型、一个参数列表、一个函数体，但与函数不同，<strong>lambda可能定义在函数内部</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; <span class="keyword">return</span> type { function body }</span><br></pre></td></tr></tbody></table></figure>
<p><code>capture list</code>是一个lambda<strong>所在函数中定义的<code>局部变量</code>的列表</strong>，lambda必须<strong>使用尾置返回来指定返回类型</strong>，可以忽略参数列表和返回类型，但<strong>必须永远包含捕获列表和函数体</strong>，如果忽略括号和参数列表等价于<strong>指定一个空参数列表</strong>，如果忽略了返回类型，lambda根据函数体中的代码推断出返回类型</p>
<p>lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] { <span class="keyword">return</span> <span class="number">42</span>; }</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="10-3-2-1、向lambda传递参数">10.3.2.1、向lambda传递参数</h5>
<p>与普通函数不同，<strong>lambda不能有默认参数</strong>，因此lambda调用的实参数目必须与形参数目相等</p>
<h5 id="10-3-2-2、使用捕获列表">10.3.2.2、使用捕获列表</h5>
<p>虽然一个lambda可以出现在一个函数中，使用其局部变量，但只能使用<strong>那些明确指明的变量</strong>；一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量，但<strong>可以直接使用定义在当前函数之外的名字或者当前函数中的局部static变量</strong></p>
<p>当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名的)类类型，<strong>当向一个函数传递一个lambda时，同时定义了一个新类型和该类的一个对象</strong>，传递的参数就是此编译器生成的类类型的未命名对象</p>
<p>使用<code>auto</code>定义一个用lambda初始化的变量时，<strong>就是定义了一个从lambda生成的类型的对象</strong></p>
<p>默认情况下，从lambda生成的类都包含一个<strong>对应该lambda所捕获的变量的数据成员</strong>，lambda的数据成员也在lambda对象创建时被初始化</p>
<p>lambda的变量捕获可以是值或引用：</p>
<ul>
<li>值捕获：采用值捕获的前提是变量可以<strong>拷贝</strong>，与参数不同，<strong>被捕获的变量的值是在lambda<code>创建</code>时拷贝，而不是调用时拷贝</strong>，因此随后对变量的修改不会影响到lambda内对应的值</li>
<li>引用捕获：必须确保被引用的对象<strong>在lambda执行的时候是存在的</strong>，对于不可以拷贝的<code>ostream</code>，引用是必须的；如果<strong>函数返回一个lambda</strong>，则函数不能返回一个局部变量的引用类似，此lambda也<strong>不能包含引用捕获</strong></li>
<li>隐式捕获：应在捕获列表中写一个<code>&amp;</code>或<code>=</code>来指示编译器推断捕获列表</li>
</ul>
<p>可以混合使用显式捕获和隐式捕获，捕获列表的<strong>第一个元素</strong>必须是一个<code>&amp;</code>或<code>=</code>，并且显式捕获的变量必须使用与隐式捕获不同的方式：</p>
<ul>
<li>如果隐式是引用方式，显式必须采用值方式</li>
<li>如果隐式是值方式，显式必须采用引用方式</li>
</ul>
<h5 id="10-3-2-3、可变lambda">10.3.2.3、可变lambda</h5>
<p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果希望能改变一个被捕获的变量的值，就必须在<strong>参数列表首</strong>加上关键字<code>mutable</code></p>
<p>一个引用捕获的变量是否可以修改依赖于此引用指向的是一个const类型还是非const类型</p>
<blockquote>
<p><strong>说明</strong>：值捕获只是得到捕获变量值的拷贝，是不能通过捕获变量名修改变量值，除非是<code>mutable</code>修饰的；但引用捕获得到捕获变量本身，是否可以改变取决于捕获对象本身是否是<code>const</code>的</p>
</blockquote>
<h5 id="10-3-2-3、lambda是函数对象">10.3.2.3、lambda是函数对象</h5>
<p>当编写一个<code>lambda</code>后，编译器将该表达式翻译成一个<strong>未命名类的未命名对象</strong>，在lambda表达式产生的类中<strong>含有一个重载的函数调用运算符</strong></p>
<p>默认情况下，lambda不能改变它捕获的变量，因此在默认情况下，由lambda产生的类当中的<strong>函数调用运算符是一个const成员函数</strong>，如果lambda被声明为可变的，则调用运算符就不是const的了</p>
<p>当一个lambda表达式通过<strong>引用捕获变量</strong>时，编译器可以直接使用该引用而<strong>无须在lambda产生的类中将其存储为数据成员</strong>；相反，通过<strong>值捕获的变量</strong>被拷贝到lambda中，这种lambda产生的类<strong>必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数(定义相关参数的构造函数)，令其使用捕获的变量的值来初始化数据成员</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = [sz](<span class="keyword">const</span> string &amp;s) { <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; }</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式对应的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt; 没有默认构造函数 &lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line">    <span class="built_in">SizeComp</span>(<span class="keyword">size_t</span> n) : <span class="built_in">sz</span>(n) {} <span class="comment">// 定义相关参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> <span class="keyword">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> sz; <span class="comment">// 值捕获产生对应的数据成员</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>lambda表达式产生的类<code>不含默认构造函数、赋值运算符及默认析构函数</code>(百分百没有)，是否含有默认的拷贝、移动构造函数通常要视捕获的数据成员类型而定</strong><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<blockquote>
<p><strong>说明</strong>：由于lambda表达式没有默认构造函数，在容器中使用自定义的比较函数时，定义相关变量的时候需要指定<code>初始化器</code>来调用拷贝构造函数</p>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// cmp是lambda表达式</span></span><br><span class="line"><span class="comment">// decltype(cmp)获得lambda表达式的类型</span></span><br><span class="line"><span class="comment">// a(cmp)使用初始化器调用拷贝构造函数</span></span><br><span class="line"><span class="function">set&lt;string, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">a</span><span class="params">(cmp)</span></span>; </span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h4 id="10-3-3、参数绑定">10.3.3、参数绑定</h4>
<p>如果lambda的捕获列表为空，通常可以用函数来代替它；对于捕获局部变量的lambda，用函数替换就没有那么容易了</p>
<p><code>bind</code>函数定义在头文件<code>functional</code>中，可以将<code>bind</code>看作一个通用的<strong>函数适配器</strong>，它可以接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * callable：是一个可调用对象</span></span><br><span class="line"><span class="comment"> * arg_list：参数列表，对应给定的callable的参数</span></span><br><span class="line"><span class="comment"> * 当调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></tbody></table></figure>
<p><code>arg_list</code>中的参数可能包含如<code>_n</code>的名字，其中<code>n</code>是一个整数，这些参数是<code>占位符</code>，表示<code>newCallable</code>的参数，它们占据了传递给<code>newCallable</code>的参数的<strong>位置</strong>，数值<code>n</code>表示生成的可调用对象中参数的位置</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * check6是一个可调用对象，接受一个string类型的参数</span></span><br><span class="line"><span class="comment"> * 并用此string和6来调用check_size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, _1, <span class="number">6</span>); <span class="comment">// _1是指传递给check6参数的第一个参数</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>_n</code>定义在<code>std::placeholders</code>的命名空间中，使用<code>_n</code>时，需要指明命名空间</p>
<h5 id="10-3-3-1、bind的参数">10.3.3.1、bind的参数</h5>
<p>可以用<code>bind</code>修正参数的值，更一般的，可以<strong>用<code>bind</code>绑定给定可调用对象中的参数或重新安排其顺序</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// g是一个由两个参数的可调用对象</span></span><br><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f, a, b, _2, c, _1); <span class="comment">// 生成一个新的可调用对象g</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 按单词长度由短至长排序</span></span><br><span class="line"><span class="built_in">sort</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), isShorter);</span><br><span class="line"><span class="comment">// 按单词长度由长至短排序</span></span><br><span class="line"><span class="built_in">sort</span>(w.<span class="built_in">begin</span>(), w.<span class="built_in">end</span>(), <span class="built_in">bind</span>(isShorter, _2, _1)); <span class="comment">// 重排参数顺序</span></span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，<code>bind</code>的那些不是占位符的参数被<code>拷贝</code>到<code>bind</code>返回的可调用对象中；如果传递给<code>bind</code>一个对象而不是拷贝它，必须使用标准库<code>ref</code>函数，函数<code>ref</code>返回一个对象，<strong>包含给定的引用，此对象是可以拷贝的</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> string &amp;s, <span class="keyword">char</span> c)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 错误：bind拷贝其参数，不能拷贝一个ostream</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="built_in">bind</span>(print, os, _1, <span class="string">'');</span></span><br><span class="line"><span class="string">// 正确：</span></span><br><span class="line"><span class="string">auto ii = bind(print, ref(os), -1, '</span><span class="string">');</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="10-4、泛型算法结构">10.4、泛型算法结构</h3>
<p>任何算法的最基本的特性是它<strong>要求其迭代器提供哪些操作</strong>，C++标准指明了泛型和数值算法的每个迭代器参数的<strong>最小类别</strong>，<strong>每个迭代器参数的能力必须与规定的最小类别<code>至少</code>相当</strong></p>
<p><strong>迭代器类别</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208183729889.png" alt="image-20211208183729889" style="zoom:67%;">
<p><strong>迭代器支持的操作</strong>：</p>
<ul>
<li><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185225933.png" alt="image-20211208185225933"></li>
<li><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185103301.png" alt="image-20211208185103301"></li>
<li>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185413679.png" alt="image-20211208185413679" style="zoom:67%;">
</li>
<li>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185507489.png" alt="image-20211208185507489" style="zoom:67%;">
</li>
<li>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208185704848.png" alt="image-20211208185704848" style="zoom:67%;">
</li>
</ul>
<h3 id="10-5、算法形参模式">10.5、算法形参模式</h3>
<p><strong>大多数算法的形参形式</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208190014898.png" alt="image-20211208190014898">
<p>如果<code>dest</code>是一个直接指向容器的迭代器，算法将输出数据写到容器中已存在的元素内；一般<code>dest</code>被绑定到一个<code>插入迭代器</code>或是一个<code>ostream_iterator</code>，可以保证空间足够用</p>
<h3 id="10-6、特定容器算法">10.6、特定容器算法</h3>
<p>对于<code>list</code>和<code>forward_list</code>，应该<strong>优先使用成员函数版本的算法</strong>而不是通用算法</p>
<p><strong>链表特有的成员函数</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208190927778.png" alt="image-20211208190927778" style="zoom:67%;">
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208191250488.png" alt="image-20211208191250488" style="zoom:67%;">
<h2 id="11、关联容器">11、关联容器</h2>
<p>关联容器<strong>支持高效的关键字查找和访问</strong>，两个主要的关联容器类型是<code>map</code>和<code>set</code></p>
<ul>
<li>map中的元素是一些<code>关键字-值对</code>：关键字起<strong>索引</strong>的作用，值则表示与索引相关联的数据</li>
<li>set中每个元素只包含一个关键字，支持高效的关键字查询操作，检查一个给定的关键字是否在set中</li>
</ul>
<p>有序容器是使用<code>红黑树</code>来组织元素，无序容器使用<code>哈希函数</code>来组织元素，<code>map, muiltimap</code>定义在头文件<code>&lt;map&gt;</code>中，<code>set, nultiset</code>定义在头文件<code>&lt;set&gt;</code>中，无序容器定义在头文件<code>&lt;unordered_map&gt;, &lt;unordered_set&gt;</code>中</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208200648344.png" alt="image-20211208200648344" style="zoom:67%;">
<h3 id="11-1、关联容器概述">11.1、关联容器概述</h3>
<h4 id="11-1-1、定义关联容器">11.1.1、定义关联容器</h4>
<p>当定义一个<code>map</code>时，必须指明<strong>关键字类型和值类型</strong>；当定义一个<code>set</code>时，必须指明<strong>关键字类型</strong>；对于<code>set</code>，元素类型就是关键字的类型，对于<code>map</code>来说，元素类型包括关键字类型和值类型，将<strong>关键字-值对</strong>包围在花括号中<code>{key, value}</code>来构成一个元素</p>
<ul>
<li>每个关联容器都定义了默认构造函数，它创建一个指定类型的<strong>空容器</strong>；</li>
<li>可以将关联容器初始化为另一个<strong>同类型容器的拷贝</strong></li>
<li>从一个<strong>值范围</strong>来初始化关联容器，只要这些值可以转化为容器所需类型即可</li>
<li>通过**{}列表**进行值初始化</li>
</ul>
<p>一个<code>map, set</code>中的关键字必须是唯一的，容器<code>multimap, multiset</code>中的关键字可以不唯一</p>
<h4 id="11-1-2、关键字类型的要求">11.1.2、关键字类型的要求</h4>
<h5 id="11-1-2-1、有序容器的关键字类型">11.1.2.1、有序容器的关键字类型</h5>
<p>对于<strong>有序容器</strong>(<code>map, set, multimap, multiset</code>)，<strong>关键字类型必须定义元素比较的方法</strong>，默认情况下标准库使用关键字类型的<code>&lt;</code>运算符来比较两个关键字；在集合类型中，关键字类型就是元素类型，在映射类型中，关键字类型是元素第一部分的类型</p>
<p><strong>有序容器的关键字类型需满足</strong>：</p>
<ul>
<li>两个关键字不能同时<strong>小于等于</strong>对方，如果<code>k1 &lt;= k2</code>，那么<code>k2</code>绝不能<code>&lt;= k1</code></li>
<li>如果<code>k1 &lt;= k2</code>，且<code>k2 &lt;= k3</code>，那么<code>k1 &lt;= k3</code></li>
<li>如果存在两个关键字，任何一个都不<strong>小于等于</strong>另一个，那么这两个关键字是<strong>等价</strong>的</li>
</ul>
<p><strong>总之，关键字的类型必须能明确将两个元素分出大小来，是严格弱序的</strong></p>
<h5 id="11-1-2-2、使用关键字类型的比较函数">11.1.2.2、使用关键字类型的比较函数</h5>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分，必须在定义关联容器类型时提供此操作的类型</p>
<p>在<code>&lt;&gt;</code>中出现的每个类型，就仅仅是一个**类型(<code>是类型而不是对象</code>)**而已，<strong>只有在创建容器时，才会以构造函数参数的形式提供真正的比较操作，也就是说如果这个比较函数的类型没有默认构造函数，在定义关联容器对象时需要比较函数的类型的对象来初始化</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_date &amp;lhs, <span class="keyword">const</span> Sales_date &amp;rhs)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">}</span><br><span class="line"><span class="function">multiset&lt;Sales_date, <span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>; <span class="comment">// 用compareIsbn来初始化</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="11-1-3、pair类型">11.1.3、pair类型</h4>
<p><code>pair</code>定义在头文件<code>&lt;utility&gt;</code>中，一个<code>pair</code>保存两个数据成员，<code>pair</code>是一个用来生成特定类型的模板；当创建一个<code>pair</code>时，必须<strong>提供两个类型名</strong>，<code>pair</code>的数据成员将具有对应的类型</p>
<p><code>pair</code>的<strong>默认构造函数</strong>对数据成员进行<code>值初始化</code>，也可以为每个成员提供初始化器</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pair&lt;string, <span class="keyword">int</span>&gt; anom; <span class="comment">// anom对应的初始值为{"", 0}</span></span><br><span class="line">pair&lt;string, <span class="keyword">int</span>&gt; line{<span class="string">"Jame"</span>, <span class="number">23</span>}; </span><br></pre></td></tr></tbody></table></figure>
<p><code>pair</code>的数据成员时<code>public</code>的，两个成员分别命名为<code>first</code>和<code>second</code>，可以使用普通的成员访问符号访问它们</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">anom.first = <span class="string">"ahfe"</span>;</span><br><span class="line">anom.second = <span class="number">34</span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong><code>pair</code>上的操作</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208231645502.png" alt="image-20211208231645502" style="zoom:67%;">
<h3 id="11-2、关联容器操作">11.2、关联容器操作</h3>
<h4 id="11-2-1、关联容器额外的类型别名">11.2.1、关联容器额外的类型别名</h4>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208231852628.png" alt="image-20211208231852628" style="zoom:67%;">
<p>对于<code>set</code>，<code>key_type, value_type</code>是一样的，<code>set</code>中保存的值就是关键字；对于<code>map</code>，元素是<strong>关键字-值对</strong>，每个元素是一个<code>pair</code>对象，<strong>由于不能改变一个元素的<code>关键字</code>，因此这些<code>pair</code>的关键字部分是<code>const</code>的</strong></p>
<p>需要使用<strong>作用域运算符</strong>来提取一个类型的成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">map&lt;string, string&gt;::key_type</span><br></pre></td></tr></tbody></table></figure>
<h4 id="11-2-2、关联容器迭代器">11.2.2、关联容器迭代器</h4>
<p>当<strong>解引用一个关联容器迭代器</strong>时，得到一个类型为容器的<code>value_type</code>(元素类型)的值的引用</p>
<p><code>set</code>的迭代器是<code>const</code>的，和<code>map</code>一样不能改变元素关键字的值，可以用一个<code>set</code>迭代器来读取元素的值，但不能修改</p>
<p>可以通过<code>begin(), end()</code>遍历关联容器</p>
<p><strong>通常不对关联容器使用泛型算法</strong>，关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法</p>
<p>关联容器可以用于只读取元素的算法，关联容器定义了自己的<code>find</code>成员，它通过给定的关键字直接获取元素，比<code>泛型find</code>快得多</p>
<p>在实际编程中，如果我们真要对一个关联容器使用算法，<strong>要么是将它作为一个源序列，要么作为一个目的位置</strong>；可以用<code>泛型copy</code>算法将元素从一个关联容器拷贝到另一个序列，可以调用<code>inserter</code>将一个插入器绑定到一个关联容器，通过使用<code>inserter</code>可以将关联容器当作一个目的位置来调用另一个算法</p>
<h4 id="11-2-3、添加元素">11.2.3、添加元素</h4>
<p><strong>关联容器的<code>insert</code>操作</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211208235127990.png" alt="image-20211208235127990" style="zoom:67%;">
<p>对一个<code>map</code>进行插入操作时，必须记住元素类型是<code>pair</code>，对于想要插入的数据，并没有一个现成的<code>pair</code>对象，可以在参数列表中创建一个<code>pair</code>对象</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">c.<span class="built_in">insert</span>({word, <span class="number">1</span>});</span><br><span class="line">c.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">c.<span class="built_in">insert</span>(pair&lt;string, <span class="keyword">int</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">c.<span class="built_in">insert</span>(map&lt;string, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></tbody></table></figure>
<h4 id="11-2-4、删除元素">11.2.4、删除元素</h4>
<p><strong>关联容器的删除操作</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209002119895.png" alt="image-20211209002119895" style="zoom:67%;">
<p>关联容器提供一个额外的<code>erase</code>操作，接受一个<code>value_type</code>参数，删除所有匹配给定关键字的元素，<strong>返回实际删除的元素数量</strong>，对于保存不重复关键字的容器，<code>erase</code>的返回值总是<code>0</code>或<code>1</code></p>
<h4 id="11-2-5、map的下标操作">11.2.5、map的下标操作</h4>
<p><code>map, unordered</code>容器提供了下标运算符和一个对应的<code>at</code>函数，不能对一个<code>multimap, unordered_multimap</code>进行下标操作，因为这些容器中可能存在多个值与一个关键字相关联</p>
<p><strong>如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化</strong>，由于下标运算符可能插入一个新元素，只可以对<code>非const</code>的map使用下标操作</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209003238708.png" alt="image-20211209003238708"></p>
<p>通常情况下，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的；<strong>当对<code>map</code>进行下标操作时，会获得一个<code>mapped_type</code>，当解引用一个<code>map</code>迭代器时，会得到一个<code>value_type</code>对象</strong>；与其他下标运算符相同，<code>map</code>的下标运算符返回一个左值</p>
<h4 id="11-2-6、访问元素">11.2.6、访问元素</h4>
<p>对于不重复关键字的容器，可以使用<code>find, count</code>，对于重复关键字的容器，<code>count</code>还会统计有多少个元素有相同的关键字</p>
<p><strong>关联容器的查找操作</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209100306057.png" alt="image-20211209100306057" style="zoom:67%;">
<p><strong>对<code>map</code>使用<code>find</code>代替下标操作</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (c.<span class="built_in">find</span>(k) != c.<span class="built_in">end</span>()) {</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果一个<code>multimap, multiset</code>中有多个元素具有给定关键字，则这些元素<strong>在容器中会<code>相邻</code>存储</strong>(因为是有序的)；如果在<code>multimap, multiset</code>中查找关键字所有的元素，可以通过<code>find, count</code>结合使用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> cnt = c.<span class="built_in">count</span>(k);</span><br><span class="line"><span class="keyword">auto</span> iter = c,<span class="built_in">find</span>(k);</span><br><span class="line"><span class="keyword">while</span> (cnt--) {</span><br><span class="line">    <span class="comment">/* 相关操作 */</span></span><br><span class="line">    iter++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>或者通过<code>lower_bound, upper_bound</code>，如果关键字在容器中，<code>lower_bound</code>返回迭代器将指向<strong>第一个具有给定元素的位置</strong>，而<code>upper_bound</code>返回的迭代器将指向<strong>最后一个匹配给定关键字的元素之后的位置</strong>，如果关键字不在容器中，<code>lower_bound, upper_bound</code>返回相等的迭代器</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> iterBegin = c.<span class="built_in">lower_bound</span>(k);</span><br><span class="line"><span class="keyword">auto</span> iterEnd = c.<span class="built_in">upper_bound</span>(k);</span><br><span class="line"><span class="keyword">while</span> (iterBegin != iterEnd) {</span><br><span class="line">	<span class="comment">/* 相关操作 */</span></span><br><span class="line">    iterBegin++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>或者通过<code>equal_range</code>，由于无序关联容器中关键字相等的元素都会在同一个桶中，所以无序关联容器也可以使用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pos = c.<span class="built_in">equal_range</span>(k);</span><br><span class="line"><span class="keyword">auto</span> iterBegin = pos.first;</span><br><span class="line"><span class="keyword">auto</span> iterEnd = pos.second;</span><br><span class="line"><span class="keyword">while</span> (iterBegin != iterEnd) {</span><br><span class="line">    <span class="comment">/* 相关操作 */</span></span><br><span class="line">    iterBegin++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="11-4、无序容器">11.4、无序容器</h3>
<p>4个无序关联容器<strong>不是使用比较运算符来组织元素，而是使用一个<code>哈希函数</code>和关键字类型的<code>==</code>运算符</strong></p>
<p>无序容器可以使用<code>哈希管理操作</code>，无序关联容器也可以使用有序关联容器的<code>find, insert</code>等操作</p>
<p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素，<strong>无序容器使用一个哈希函数将元素映射到桶</strong>；为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶，容器将具有一个特定哈希值的所有元素都保存在相同的桶中；<strong>如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中</strong>，因此无序容器的性能依赖于哈希函数的质量和桶的数量和大小</p>
<p><strong>无序容器管理操作</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209103347407.png" alt="image-20211209103347407" style="zoom:67%;">
<p>默认情况下，无序容器使用关键字类型的<code>==</code>运算符来比较元素，还是用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值；标准库为<strong>内置类型、string、指针类型、智能指针类型</strong>提供了<code>hash</code>模板，可以直接定义<strong>关键字是内置类型(包括指针类型)、string、智能指针类型的无序容器</strong></p>
<p>但是<strong>不能直接定义关键字类型为自定义类类型的无序容器</strong>，自定义类类型必须提供自己的<code>hash</code>模板版本，也可以提供函数来替代<code>==</code>运算符和哈希值计算函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">unordered_multiset&lt;sales_data, <span class="keyword">decltype</span>(haster)*, <span class="keyword">decltype</span>(eqop)*&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="12、动态内存">12、动态内存</h2>
<h3 id="12-1、动态内存">12.1、动态内存</h3>
<h5 id="12-1-1、使用new动态分配的和初始化对象">12.1.1、使用new动态分配的和初始化对象</h5>
<p><code>new</code>无法为其分配的对象命名，只能返回一个<strong>指向该对象的指针</strong></p>
<p><strong>动态分配对象的初始化方式</strong>：</p>
<ul>
<li><strong>默认情况下，动态分配的对象是默认初始化的</strong>，意味着内置类型或组合类型的对象的值是未定义的，而类类型对象将用默认构造函数进行初始化</li>
<li>使用<strong>直接初始化方式</strong>
<ul>
<li>使用传统的构造方式(<code>圆括号</code>)，<strong>调用类型的构造函数来初始化</strong></li>
<li>使用列表初始化(<code>花括号</code>)</li>
</ul>
</li>
<li>使用<strong>值初始化</strong>：在类型名后跟一对<code>空括号</code>
<ul>
<li>值初始化只对<code>内置类型</code>有意义，对于内置类型，默认初始化的对象的值是未定义的，而使用值初始化的对象的值是有定义的</li>
<li>对于自定义类型，不管使用值初始化还是默认初始化，最终都会调用类的默认构造函数来完成初始化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始化</span></span><br><span class="line">string *ps = <span class="keyword">new</span> string; <span class="comment">// ps指向的对象是未定义的</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">int</span> *qi = <span class="keyword">new</span> <span class="keyword">int</span>{<span class="number">34</span>};</span><br><span class="line">string *str = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'9'</span>); <span class="comment">// 使用string的构造函数初始化对象</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; *vec = <span class="keyword">new</span> vector&lt;<span class="keyword">int</span>&gt;{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值初始化</span></span><br><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(); <span class="comment">// 适用于内置类型</span></span><br></pre></td></tr></tbody></table></figure>
<p><span id="autofenpeishuzu">如果使用<code>()</code>包围的初始化器，可以是使用<code>auto</code>从初始化器来推断想要分配的对象的类型，但括号中仅有<code>单一</code><strong>初始化器</strong>才可以</span></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(obj); <span class="comment">// auto的推断结果和obj的类型一致</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>new</code>可以分配<strong>const对象</strong>，但必须进行<strong>初始化</strong>，对于定义了<strong>默认构造函数的</strong><code>类类型</code>，可以隐式初始化，而<strong>其他类型的对象</strong>(内置类型)只能显式初始化，new返回的指针是一个<code>指向const的指针</code></p>
<h5 id="12-1-2、定位new运算符">12.1.2、定位new运算符</h5>
<p>一般来说，使用new申请空间时，是从系统的堆中分配空间。申请所得的空间的<strong>位置</strong>是根据当时的内存的实际使用情况决定的。但是，在某些特殊情况下，可能需要在程序员<strong>指定的特定内存</strong>创建对象，这就是所谓的<code>定位new</code>操作</p>
<p>定位new运算符<strong>直接使用传递给它的地址</strong>，它不负责判断哪些内存单元已被使用，也不查找未使用的内存块</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// place_address必须是一个指针</span></span><br><span class="line"><span class="keyword">new</span> (place_address) type </span><br><span class="line"><span class="built_in"><span class="keyword">new</span></span> (place_address) <span class="built_in">type</span>(initializers)</span><br><span class="line"><span class="built_in"><span class="keyword">new</span></span> (place_address) type[size]</span><br><span class="line"><span class="built_in"><span class="keyword">new</span></span> (place_address) type[size]{initializer list}</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="keyword">int</span> mem[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">    <span class="keyword">new</span> (mem + i) <span class="built_in"><span class="keyword">int</span></span>(i); <span class="comment">// 给mem数组每一个元素赋值</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">char</span> mem[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> *pi = <span class="built_in"><span class="keyword">new</span></span> (mem) <span class="keyword">int</span>;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="12-1-3、new和数组">12.1.3、new和数组</h5>
<p><code>new</code>分配一个对象数组，要<strong>在类型名之后跟一对方括号，指明要分配的对象的数目</strong>，方括号中的大小必须是<code>整形</code>，<strong>但不必是常量，可以用任意表达式来指定大小</strong>；new分配要求数量的对象并返回指向<code>第一个</code>对象的指针，不能对动态数组调用<code>begin</code>或<code>end</code>，也不能使用<code>范围for</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">get_size</span>()];</span><br><span class="line"><span class="comment">// 用表示数组类型的类型别名来分配一个数组 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>动态分配对象的数组初始化方式</strong>：</p>
<ul>
<li>默认情况下，new分配的对象，不管是单个分配的还是数组中，都是默认初始化的</li>
<li>对数组中的元素进行值初始化：在大小之后跟一对<strong>空括号</strong>，但<strong>不能在括号中给出初始化器</strong>，不能使用<a href="#autofenpeishuzu">auto分配数组</a></li>
<li>使用初始化列表</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">// 10个未初始化的int</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">// 10个值初始化为0的int</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：动态数组的大小允许为0，但没有实际意义，能够定义长度为0的数组，但不能解引用</p>
</blockquote>
<h5 id="12-1-4、释放动态内存">12.1.4、释放动态内存</h5>
<p>传递给delete的指针必须<strong>指向动态分配的内存，或者是一个<code>空指针</code></strong>，释放一块非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的</p>
<p>动态分配的const对象的值不能被改变，但它本身是可以被销毁的，只要delete指向const对象的指针即可</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">delete</span> pci;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>由<code>内置指针</code>(而不是智能指针)管理的动态内存在被显式释放前一直都会存在</strong></p>
<blockquote>
<p><strong>Tips</strong>：避免空悬指针的方法：在指针即将要离开其作用域之前释放掉它所关联的内存，这样就没有机会继续使用指针了。如果需要保留指针，可以在delete之后，将nullptr赋值给指针</p>
</blockquote>
<p>释放动态数组需要在指针前加上一对<code>空方括号</code>，数组中的元素被<strong>逆序销毁</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pi;</span><br><span class="line"><span class="comment">// 销毁使用类型别名定义的动态数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>];</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;</span><br><span class="line"><span class="keyword">delete</span> [] p; <span class="comment">// 即使用的是类型别名定义的动态数组，销毁时也需要[]</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="12-2、智能指针">12.2、智能指针</h4>
<h5 id="12-2-1、shared-ptr类">12.2.1、shared_ptr类</h5>
<p><code>shared_ptr</code>类也是一个模板类，类似于<code>vector</code>，<strong>模板参数为指针可以指向的类型</strong></p>
<p><strong>智能指针shared_ptr的初始化方式</strong>：</p>
<ul>
<li>默认初始化的智能指针中保存着一个空指针</li>
<li>使用标准库<strong>函数</strong><code>make_shared</code>，此函数在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code></li>
<li>使用new返回的指针初始化智能指针：接收指针参数的智能指针构造函数是<code>explicit</code>的，不能将内置指针隐式转换为一个智能指针，必须<strong>使用直接初始化形式</strong></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1 = make_shared&lt;string&gt;(<span class="number">10</span>, <span class="string">'9'</span>); <span class="comment">// 调用make_shared&lt;string&gt;时传递的参数必须与string的构造函数相匹配</span></span><br><span class="line">shared_ptr&lt;string&gt; p2 = make_shared&lt;string&gt;(); <span class="comment">// 值初始化</span></span><br><span class="line"><span class="keyword">auto</span> p3 = make_shared&lt;string&gt;(); <span class="comment">// 使用auto</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new指针初始化智能指针</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>; <span class="comment">// 正确：使用直接初始化</span></span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p4 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1024</span>); <span class="comment">// 错误：不能隐式转换</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>shared_ptr的相关操作</strong>：<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211129220029072.png" alt="image-20211129220029072"></p>
<p><strong>智能指针的使用方式和普通指针一样</strong>，解引用以及使用智能指针作为判断条件等</p>
<p><strong>拷贝一个shared_ptr，计数器都会递增，给shared_ptr<code>赋予一个新值</code>或是shared_ptr被销毁，计数器都会递减，当计数器为0时，自动释放所管理的对象</strong></p>
<p><strong>将一个shared_ptr赋予另一个shared_ptr会<code>递增</code>赋值号<code>右侧</code>的shared_ptr的引用计数，而<code>递减</code>赋值号<code>左侧</code>shared_ptr的引用计数</strong></p>
<p>shared_ptr的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它所占用的内存</p>
<blockquote>
<p><strong>说明</strong>：引用计数的递减操作都是在析构函数中进行的，并在析构函数中判断当引用计数为0时，就释放相应的内存</p>
</blockquote>
<p><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如果将shared_ptr存放在容器中，随后重排容器，而后不再需要全部元素，而只使用其中一部分，需要用erase删除不再需要的那些元素<span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>使用动态内存的场景：</p>
<ul>
<li>程序不知道自己需要使用多少对象：容器类</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<p>默认情况下，一个<strong>用来初始化智能指针的普通指针必须指向动态内存</strong>，因为智能指针默认使用delete释放它所关联的对象，<strong>可以将智能指针绑定到一个指向其他类型的资源的指针上，必须提供自己的操作来提到delete</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span>; <span class="comment">// 自定义释放操作</span></span><br><span class="line"><span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>; <span class="comment">// 用自定义释放操作end_connection代替默认的delete</span></span><br></pre></td></tr></tbody></table></figure>
<p>当将一个shared_ptr绑定到一个<strong>普通指针</strong>时，就将内存的管理责任交给了这个shared_ptr，不应该在使用<strong>内置指针</strong>来访问shared_ptr所指向的内存</p>
<p>智能指针类型的<code>get()</code>函数返回一个<code>内置指针</code>，指向智能指针管理的对象，使用get返回的指针的代码不能delete这个指针，<strong>不要用get初始化另一个智能指针或者为另一个智能指针赋值</strong></p>
<p><strong>如果使用智能指针，即使程序块过早结束(异常)，智能指针类也能确保在内存不再需要时将其释放</strong>；使用<strong>内置指针</strong>管理内存，在new之后在对象delete之前发生了异常，则内存不会被释放</p>
<p>shared_ptr不直接支持管理动态数组，需要<strong>提供自己定义的删除器</strong>，shared_ptr未定义下标运算符，必须<strong>使用get获取一个内置指针，通过内置指针访问元素</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p){ <span class="keyword">delete</span>[] p; })</span></span>;</span><br><span class="line">*(sp.<span class="built_in">get</span>() + <span class="number">3</span>) = <span class="number">45</span>;</span><br><span class="line">sp.<span class="built_in">get</span>()[<span class="number">3</span>] = <span class="number">45</span>;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="12-2-2、unique-ptr类">12.2.2、unique_ptr类</h5>
<p>与多个shared_ptr指针可以指向同一个对象不同，只能有一个unique_ptr指针指向一个对象，<strong>当unique_ptr被销毁时，所指向的对象也被销毁</strong></p>
<p>定义一个unique_ptr时，需要将其绑定到一个<strong>new返回的动态指针</strong>上，由于一个unique_ptr拥有它指向的对象，unique_ptr<strong>不支持普通的拷贝或赋值操作</strong>，可以通过<code>release</code>或<code>reset</code>将指针的所有权从一个(非const)unique_str转移给另一个unique，release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值，<strong>如果不用智能指针来保存release返回的指针，需要手动释放资源</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// release成员返回unique_ptr当前保存的指针并将其置为空</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>; <span class="comment">// release将p1置为空 </span></span><br><span class="line"><span class="comment">// reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针，如果unique_ptr不为空，它原来指向的对象被释放</span></span><br><span class="line">p2.<span class="built_in">reset</span>(); <span class="comment">// 释放p2指向的对象</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">// 释放p2指向的对象，将所有权从p3转移给p2</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>可以拷贝或赋值一个<code>将要被销毁</code>的unique_ptr</strong>，比如局部对象的拷贝，函数返回值等</p>
<p>unique_ptr管理删除器的方式与shared_ptr不同，需要在<strong>尖括号中unique_ptr指向类型之后提供删除器类型</strong>，在创建或reset这种unique_ptr类型的对象时，<strong>必须</strong>提供一个指定类型的可调用对象(删除器)</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;objT, delT&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> objT, fcn)</span></span>; <span class="comment">// &lt;objT, delT&gt;中提供删除器类型，p(new objT, fcn)必须提供可调用的删除器</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以使用<code>unique_ptr</code>智能指针管理new分配的数组，必须在尖括号中对象类型后面跟一对<code>[]</code>，当unique_ptr指向一个数组时，不能使用点或箭头成员运算符，只能使用<code>下标运算符</code>来访问数组中的元素，因为unique_ptr指向的是一个数组而不是单个对象</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="keyword">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up[<span class="number">2</span>] = <span class="number">34</span>; <span class="comment">// 只能使用下标运算符</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>unique_ptr的相关操作</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211129220213030.png" alt="image-20211129220213030"></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211129220128817.png" alt="image-20211129220128817"></p>
<h5 id="12-2-3、weak-ptr">12.2.3、weak_ptr</h5>
<p>weak_ptr是一种不控制所指向对象生存期的智能指针，指向一个由<code>shared_ptr</code>管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的<code>引用计数</code>。</p>
<p><strong>创建weak_ptr时，必须用shared_ptr来初始化</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">43</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>; <span class="comment">// weak_ptr必须用shared_ptr对象来初始化</span></span><br></pre></td></tr></tbody></table></figure>
<p>由于对象有可能不存在，不能直接使用weak_ptr直接访问对象，必须调用<code>lock</code>来检查weak_ptr指向的对象是否存在；如果存在，<code>lock</code>函数返回一个指向对象的<code>shared_ptr</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="keyword">int</span>&gt; np = wp.<span class="built_in">lock</span>()) { <span class="comment">// lock返回shared_ptr智能指针</span></span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>weak_ptr的相关操作</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211129220257506.png" alt="image-20211129220257506"></p>
<h2 id="13、重载运算与类型转换">13、重载运算与类型转换</h2>
<p>重载运算符函数的<strong>参数数量</strong>与该运算符作用的<strong>运算对象数量</strong>一样多，一元运算符有一个参数，二元运算符有两个参数；对于二元运算符来说，<strong>左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数</strong>；如果一个运算符函数是<strong>成员函数</strong>，则它的第一个运算对象绑定到隐式的<code>this</code>指针上</p>
<p>对于一个运算符函数来说，它<strong>或者是类的成员，或者至少含有一个类类型的参数</strong>，意味着当运算符作用域内置类型的运算对象时，无法改变该运算符的含义</p>
<p><strong>只能重载已有的运算符</strong>，而无权发明新的运算符号；对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致</p>
<p><strong>可被重载的运算符</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209194201559.png" alt="image-20211209194201559"></p>
<p>也可以像调用其他成员函数一样<strong>显式地调用成员运算符函数</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">date1.<span class="keyword">operator</span>+(date2);</span><br><span class="line">date1 + date2;</span><br></pre></td></tr></tbody></table></figure>
<p>如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209195321943.png" alt="image-20211209195321943" style="zoom: 80%;">
<p>运算符重载函数定义成成员函数还是非成员函数的标准：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209195732605.png" alt="image-20211209195732605" style="zoom:80%;">
<h3 id="13-1、输入和输出运算符">13.1、输入和输出运算符</h3>
<h4 id="13-1-1、重载输出运算符">13.1.1、重载输出运算符&lt;&lt;</h4>
<p>输出运算符的第一个形参是一个<strong>非常量<code>ostream</code>对象的引用</strong>，是因为向流写入内容会改变其状态，其次是<strong>无法复制一个<code>ostream</code>对象</strong>；第二形参一般是一个<strong>常量的引用</strong>；<code>operator&lt;&lt;</code>一般要返回它的<code>ostream</code>对象</p>
<p><strong>输出运算符尽量减少格式化操作</strong></p>
<p><strong>输入输出运算符必须是非const的</strong></p>
<p>如果<strong>自定义IO运算符，必须将其定义成非成员函数</strong>，IO运算符通常需要读写类的非公有数据成员，<strong>IO运算符一般被声明为</strong><code>友元</code></p>
<h4 id="13-1-2、重载输入运算符">13.1.2、重载输入运算符&gt;&gt;</h4>
<p>输入运算符的第一个形参是运算符将要读取的<strong>流的引用</strong>，第二个形参是要读入到的**(非常量)对象的引用**，该运算符返回<strong>某个给定流的引用</strong></p>
<p><strong>输入运算符必须处理输入可能失败的情况，而输出运算符不需要</strong></p>
<h3 id="13-2、算术和关系运算符">13.2、算术和关系运算符</h3>
<p>通常情况下，<strong>把算术和关系运算符定义成<code>非成员函数</code>以允许对左侧或右侧的运算对象进行转换</strong>，因为这些运算符一般不需要改变运算对象的状态，<strong>形参都是常量的引用</strong></p>
<p>算术运算符通常会计算它的两个运算对象并得到一个新值，这个新值有别于任意一个运算对象，常常<strong>位于局部变量之内，操作完成后返回该局部变量的副本作为其结果</strong>；如果类定义了算术运算符，则一般也会定义一个对应的复合赋值运算符，此时最有效的方式是使用复合赋值来定义算术运算符</p>
<h4 id="13-2-1、相等运算符">13.2.1、相等运算符</h4>
<p>相等运算符和不相等运算符中的一个应该把工作委托给另外一个，意味着<code>!=</code>需要通过<code>==</code>来实现</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> A&amp; b) {</span><br><span class="line">    <span class="keyword">return</span> !(a == b); <span class="comment">// 用==实现!=</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="13-2-2、关系运算符">13.2.2、关系运算符</h4>
<p>通常情况下关系运算符应该：</p>
<ul>
<li>定义顺序关系，必须有<strong>明确的顺序关系</strong></li>
<li>如果类同时含有<code>==</code>运算符的话，则定义一种关系令其与<code>==</code>保持一致，如果两个对象<code>!=</code>，则一个对象一定<code>&lt;</code>另一个对象</li>
</ul>
<p>通过定义<code>&lt;</code>，从而<code>&gt;, &lt;=, &gt;=</code>都是可以通过<code>&lt;</code>得出的</p>
<h3 id="13-3、赋值运算符">13.3、赋值运算符</h3>
<p>除了前面的<strong>形参是类对象的引用赋值运算符</strong>外，还可以以使用<strong>别的类型</strong>作为右侧运算对象，和前面的赋值运算符一样，其他重载的赋值运算符也<strong>必须先释放当前的内存，再创建一片新空间</strong>，不同的是，该运算符不需要检查对象向自身的赋值</p>
<p><strong>不管形参的类型是什么，赋值运算符都必须定义为成员函数</strong></p>
<p>复合赋值运算符也要返回其<strong>左侧运算对象的引用</strong></p>
<h3 id="13-4、下标运算符">13.4、下标运算符</h3>
<p><strong>下标运算符必须是成员函数</strong></p>
<p>下标运算符通常以<strong>所访问元素的引用</strong>作为返回值，最好同时定义下标运算符的常量版本和非常量版本，当作用于一个<strong>常量对象</strong>时，下标运算符返回<strong>常量引用</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> n) {</span><br><span class="line">    <span class="keyword">return</span> elements[n];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">const</span> string&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> n) <span class="keyword">const</span> { <span class="comment">// 常量版本返回常量引用</span></span><br><span class="line">    <span class="keyword">return</span> elements[n];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="13-5、递增和递减运算符">13.5、递增和递减运算符</h3>
<p><strong>前置运算符</strong>应该返回递增或递减后对象的<strong>引用(左值)</strong>，而后置运算符应该返回<strong>对象的原值</strong>，返回形式是<strong>一个值而非引用</strong></p>
<p><strong>后置版本接受一个额外的<code>int</code>类型的形参(无须命名)</strong>，当使用后置运算符时，编译器为这个形参提供一个值为0的实参，这个形参唯一的作用就是区分前置版本和后置版本的函数</p>
<p>对于后置版本来说，在<strong>递增、减对象之前需要首先记录对象的状态</strong>，好用来作为返回值返回</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">StrBlobPtr&amp; <span class="keyword">operator</span>++() { <span class="comment">// 前置++版本：返回递增后对象的引用</span></span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line">StrBlobPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>) { <span class="comment">// 后置++版本：返回原对象的值</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果显式的调用后置运算符，需要为<strong>它的整型参数传递一个值</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>); <span class="comment">// 调用后置++：可以传任何值</span></span><br><span class="line">p.<span class="keyword">operator</span>++(); <span class="comment">// 调用前置++</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：前置++需要判断有效性，后置++一般不需要，因为后置++通过前置++实现</p>
</blockquote>
<h3 id="13-6、成员访问运算符">13.6、成员访问运算符</h3>
<p><strong>解引用运算符返回的是引用，箭头运算符返回的是指针</strong></p>
<p>箭头运算符<code>必须</code>是类的成员，解引用运算符通常也是类的成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string&amp; <span class="keyword">operator</span>*() {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;cur;</span><br><span class="line">}</span><br><span class="line">string* <span class="keyword">operator</span>-&gt;() {</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="13-7、函数调用运算符">13.7、函数调用运算符</h3>
<p>如果类重载了函数调用运算符，则可以<strong>像使用函数一样使用该类的</strong><code>对象</code></p>
<p><strong>函数调用运算符必须是成员函数</strong>，一个类可以定义多个不同版本的的调用运算符，相互之间应该在参数数量或类型上有所区别</p>
<p>如果类定义了调用运算符，则该类的对象称作<strong>函数对象</strong></p>
<h4 id="13-7-1、标准库定义的函数对象">13.7.1、标准库定义的函数对象</h4>
<p>标准可定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符，这些类都被定义成模板的形式，使用时<strong>需要指定具体的应用类型</strong></p>
<p><strong>标准库函数对象</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209222107978.png" alt="image-20211209222107978" style="zoom:67%;">
<p>标准库规定其函数对象对于<strong>指针</strong>同样适用，之前介绍过比较两个无关指针将产生未定义的行为，可以适用标准库的函数对象来比较，比较的是实际地址的先后顺序</p>
<p>关联容器适用<code>less&lt;key_type&gt;</code>对元素排序，因此可以定义一个<strong>指针</strong>的<code>set</code>或者在<code>map</code>中适用<strong>指针作为关键值</strong>而无须直接声明<code>less</code></p>
<h4 id="13-7-2、可调用对象与function">13.7.2、可调用对象与function</h4>
<p>C++中有几种可调用的对象：<strong>函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类</strong></p>
<p>和其他对象一样，可调用的对象也有类型；<strong>调用形式指明了<code>调用返回的类型</code>以及传递给调用的<code>实参类型</code> ，一种调用形式对应一个函数类型</strong></p>
<h5 id="13-7-2-1、标准库function类型">13.7.2.1、标准库function类型</h5>
<p><strong>function的操作</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211209224331385.png" alt="image-20211209224331385" style="zoom:67%;">
<p><code>function</code>是一个模板，创建一个具体的<code>function</code>类型时必须提供该<code>function</code>类型能够表示的对象的调用形式</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line">function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="13-7-2-2、重载的函数与function">13.7.2.2、重载的函数与function</h5>
<p>不能直接将重载函数的名字存入<code>function</code>类型的对象中，容易产生二义性</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line">map&lt;string, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>({<span class="string">"+"</span>, add}); <span class="comment">// add不知道调用哪一个</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以通过<strong>函数指针</strong>而非函数名来消除二义性</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;, <span class="keyword">const</span> Sales_data &amp;)</span></span>;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">map&lt;string, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>({<span class="string">"+"</span>, fp}); <span class="comment">// 调用int(int,int)的add</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="13-8、重载、类型转换与运算符">13.8、重载、类型转换与运算符</h3>
<h4 id="13-8-1、类型转换运算符">13.8.1、类型转换运算符</h4>
<p><strong>类型转换运算符</strong>是类的一种特殊成员函数，它负责<strong>将一个类类型的值转换成其他类型</strong>；类型转换运算符可以<strong>面向任意类型(void除外)进行定义</strong>，只要该类型<strong>能作为函数的返回类型</strong>，因此不允许转换成数组或函数类型，但允许转换成指针(包括数组指针及函数指针)或引用类型</p>
<p>类型转换运算符<strong>既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数</strong>；类型转换运算符通常不应该改变转换对象的内容，一般被<strong>定义成const成员</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure>
<p>因为类型转换运算符是<strong>隐式执行</strong>的，无法给这些函数传递实参，也就<strong>不能在类型转换运算符的定义中使用任何形参</strong>；虽然类型转换函数不负责指定返回类型，但实际上<strong>每个类型转换函数都会返回一个对应类型的值</strong></p>
<h4 id="13-8-2、显式的类型转换运算符">13.8.2、显式的类型转换运算符</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">cin &lt;&lt; i; <span class="comment">// </span></span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中试图将输出运算符作用于输入流，因为<code>istream</code>没有定义<code>&lt;&lt;</code>，但此代码中使用<code>istream</code>的<code>bool</code>类型转换运算符将<code>cin</code>转换为<code>bool</code>，而这个<code>bool</code>值会提升为<code>int</code>并用作内置的左移运算符的左侧运算对象，也就相当于<code>1 &lt;&lt; 42</code></p>
<p>防止异常情况发生，需要定义<strong>显式的类型转换运算符</strong>；和显式的构造函数一样，编译器也不会将一个显式的类型转换运算符用于隐式类型转换；只能通过<strong>显式的强制类型转换</strong>才可调用类型转换运算符</p>
<p><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如果<strong>表达式被用作条件</strong>，则编译器会<strong>将显式的类型转换自动执行</strong><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211210001332969.png" alt="image-20211210001332969" style="zoom:67%;">
<p><strong>无论何时在条件中使用流对象，都会使用为IO类型定义的</strong><code>operator bool</code></p>
<h4 id="13-8-3、避免有二义性的类型转换">13.8.3、避免有二义性的类型转换</h4>
<p>如果类中包含一个或多个类型转换，则<strong>必须确保在类类型和目标类型之间只存在唯一一种转换方式</strong>，否则会产生二义性</p>
<p><strong>产生多重转换路径的两种情况</strong>：</p>
<ul>
<li>
<p>两个类定义相同的类型转换：A类定义了一个接受B类转换构造函数，同时B类定义了一个接受A类转换构造函数，它们提供了相同的类型转换</p>
</li>
<li>
<p>类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> {</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a); <span class="comment">// 二义性错误：不确定调用哪一个类型转换，int，double都能转换为long double</span></span><br><span class="line"><span class="keyword">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">// 二义性错误：不确定调用哪一个类型转换，long double能转换为int或者double</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>通常情况下，<strong>不要为类定义相同的类型转换，也不要在类中定义两个或两个以上转换源或转换目标是算术类型的转换</strong></p>
<p><strong>类型转换与运算符的使用经验</strong>：</p>
<ul>
<li>不要令两个类执行相同的类型转换：如果A类中有一个接受B类对象的构造函数，那么B类就不能定义转换目标为A类的类型转换运算符</li>
<li>避免转换目标是内置算术类型的类型转换，特别是已经定义了一个转换成算术类型的类型转换时，接下来
<ul>
<li>不要再定义接受算术类型的重载运算符</li>
<li>不要定义转换到多种算术类型的类型转换</li>
</ul>
</li>
</ul>
<p><strong>总之，除了显示地向<code>bool</code>类型的转换之外，应该尽量避免定义类型转换函数并尽可能地限制那些<code>显然正确</code>的非显式构造函数</strong></p>
<p>当通过类类型的对象进行函数调用时，只考虑该类的成员函数，而<strong>当在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是非成员函数</strong>，两者都在考虑的范围</p>
<p><strong>如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题</strong></p>
<h2 id="14、面向对象程序设计">14、面向对象程序设计</h2>
<h3 id="14-1、定义基类和派生类">14.1、定义基类和派生类</h3>
<h4 id="14-1-1、定义基类">14.1.1、定义基类</h4>
<p>在C++语言中，基类必须将它的两种成员函数区分开来：</p>
<ol>
<li>
<p>一种是基类希望其派生类进行覆盖的函数</p>
</li>
<li>
<p>一种是基类希望派生类直接继承而不要改变的函数</p>
</li>
</ol>
<p>对于第1种，基类通过将其定义成<strong>虚函数</strong>，使用<strong>指针或引用</strong>调用<strong>虚函数</strong>时，该调用将被<strong>动态绑定</strong>，根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类，<strong>是根据所绑定的对象类型决定执行虚函数的版本</strong></p>
<p>任何<strong>构造函数</strong>之外的<strong>非静态函数</strong>都可以是虚函数，关键字<code>virtual</code>只能<strong>出现在<code>类内部</code>的声明语句之前</strong>而不能用于类外部的函数定义；<strong>如果基类把一个函数声明称虚函数，则该函数在派生类中<code>隐式地</code>也是虚函数</strong></p>
<p>成员函数如果没有被声明成虚函数，则其解析过程发生<strong>在编译时</strong>(和普通函数一样，编译期就已确定)<strong>而非运行时</strong>(只有虚函数的解析发生在运行期，需要根据所绑定的对象来判断调用哪个版本的虚函数)</p>
<p><strong>派生类的成员</strong>(而不是派生的对象)能访问基类的<code>公有和受保护的</code>成员，而<strong>不能访问私有成员</strong></p>
<p><strong>基类通常都应该定义一个<code>虚析构函数</code>，即使该函数不执行任何实际操作也是如此</strong></p>
<h4 id="14-1-2、定义派生类">14.1.2、定义派生类</h4>
<p>派生类必须通过使用<code>类派生列表</code>明确指出它是从哪个(哪些)基类继承而来的，类派生列表的形式是：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 首先是一个冒号</span></span><br><span class="line"><span class="comment"> * 后面紧跟访问说明符：public, private, protected</span></span><br><span class="line"><span class="comment"> * 最后紧跟以逗号分隔的基类列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base {};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>派生类必须将其继承而来的成员函数中<code>需要覆盖</code>的那些重新声明</strong>，<a href="#xuhanshubuzongshixuyaofugaide">虚函数不总是需要覆盖的</a></p>
<h5 id="14-1-2-1、访问说明符">14.1.2.1、访问说明符</h5>
<p>访问说明符的作用是<strong>控制派生类从基类继承而来的成员是否对<code>派生类的用户</code>可见</strong>；如果一个<strong>派生是公有的</strong>，则<strong>基类的<code>公有成员</code>也是派生类的组成部分</strong>；<strong>能将<code>公有</code>派生类型的对象绑定到基类的引用或指针上，不能是<code>私有或受保护的</code>派生类型</strong></p>
<h5 id="14-1-2-2、派生类中的虚函数">14.1.2.2、派生类中的虚函数</h5>
<p><strong><span id="xuhanshubuzongshixuyaofugaide">&nbsp;派生类<code>经常(但不总是)</code>覆盖它继承的虚函数</span>，如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他普通成员，派生类会<code>直接继承</code>其在基类中的版本</strong></p>
<p>派生类可以在它覆盖的函数前使用<code>virtual</code>关键字，也可以不使用；可以通过<strong>在形参列表后面、或者在const成员函数的const关键字后面、或者在引用成员函数的引用限定符后面添加一个关键字<code>override</code>显式地注明它使用某个成员函数覆盖了它继承的虚函数</strong></p>
<h5 id="14-1-2-3、派生类对象及派生类向基类的类型转换">14.1.2.3、派生类对象及派生类向基类的类型转换</h5>
<p>一个派生类对象包含多个组成部分：</p>
<ul>
<li>含有派生类<strong>自己定义的</strong>(非静态)成员的子对象</li>
<li>与该派生类<strong>继承的基类对应</strong>的子对象</li>
</ul>
<p><strong>因为派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当成基类对象来使用，能将<code>基类的指针或引用</code>绑定到派生类的<code>基类部分</code>上</strong>，这种转换叫<strong>派生类到基类的</strong>类型转换，编译器会隐式地执行派生类到基类的转换  <strong>&lt;前提是公有继承&gt;</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A {};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> <span class="keyword">protected</span> A {};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> <span class="keyword">private</span> A {};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    A &amp;a = b; <span class="comment">// 正确</span></span><br><span class="line">    A &amp;a1 = c; <span class="comment">// 错误</span></span><br><span class="line">    A &amp;a2 = d; <span class="comment">// 错误</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="14-1-2-4、派生类的构造函数">14.1.2.4、派生类的构造函数</h5>
<p>派生类必须使用<strong>基类的构造函数</strong>来初始化它的基类部分，派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的，派生类的构造函数是<strong>通过初始化列表将实参传递给基类的构造函数的</strong>，<strong>每个类控制它自己的成员初始化过程</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(string &amp; book, <span class="keyword">double</span> p, <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) : <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) {}</span><br></pre></td></tr></tbody></table></figure>
<p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化；如果想使用其他的基类构造函数，需要<strong>以类名加圆括号内的实参列表的形式为构造函数提供初始值</strong>，这些实参能够帮助编译器决定应该选用哪个构造函数来初始化派生类对象的基类部分</p>
<p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员</p>
<h5 id="14-1-2-5、派生类使用基类的成员">14.1.2.5、派生类使用基类的成员</h5>
<p>派生类的<strong>类内成员</strong>(<em>对象是否可访问还与派生的访问说明符有关</em>)可以访问基类的公有成员和受保护成员，<strong>派生类的作用域是嵌套在基类的作用域之内的</strong>，对于派生类的一个成员来说，使用派生类成员的方式和使用基类成员的方式没什么不同</p>
<p><strong>每个类负责定义<code>各自的</code>接口，要想与<code>类的对象</code>交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此</strong>，因此，派生类对象不能直接初始化基类的成员，通过调用基类的构造函数来初始化从基类继承而来的成员</p>
<h5 id="14-1-2-6、继承与静态成员">14.1.2.6、继承与静态成员</h5>
<p>如果基类定义了一个静态成员，则在<strong>整个继承体系中只存在该成员的唯一定义</strong>，不论从基类派生出来多少个派生类，对于每个静态成员都只存在唯一的实例</p>
<p>静态成员遵循通用的访问控制规则，如果基类中的成员是<code>private</code>的，则派生类无权访问它；如果静态成员是可访问的，<strong>既能通过基类使用也能通过派生类使用</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> {</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmen</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base { <span class="comment">// 此处private只对外部Derived的对象有影响</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived&amp; derived_obj)</span> </span>{</span><br><span class="line">        Base::<span class="built_in">statmen</span>(); <span class="comment">// 正确</span></span><br><span class="line">        Derived::<span class="built_in">statmen</span>(); <span class="comment">// 正确</span></span><br><span class="line">        derived_obj.<span class="built_in">statmen</span>(); <span class="comment">// 正确：protected对于派生类的类内成员是可以访问的，此处dervied_obj出现在类内，是可以访问protected的statmen()成员，但不能通过Base的对象访问Base类中的protected对象</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h5 id="14-1-2-7、派生类的声明">14.1.2.7、派生类的声明</h5>
<p>派生类的声明中只包含类名但<strong>不能包含它的派生列表</strong>，派生类列表以及与定义有关的细节必须与类的主体一起出现</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote; <span class="comment">// 错误：声明不能包含派生列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span>;</span> <span class="comment">// 正确</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="14-1-2-8、被用作基类的类">14.1.2.8、被用作基类的类</h5>
<p>如果想将某个类用作基类，则该类必须<strong>已经定义而非仅仅声明</strong>，一个类不能派生它本身</p>
<p>每个类都会继承直接基类的所有成员，对于一个最终的派生类来说，会包含直接基类的子对象以及每个间接基类的子对象</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> :</span> <span class="keyword">protected</span> A { <span class="comment">// 此处的protected并不影响C的派生类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">9</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> <span class="keyword">private</span> C {</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; c &lt;&lt; endl; <span class="comment">// 正确：所有的继承都与派生访问说明符无关</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h5 id="14-1-2-9、防止继承的发生">14.1.2.9、防止继承的发生</h5>
<p>在类名后跟一个关键字<code>final</code>可以防止继承发生</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="keyword">final</span> {</span>}; <span class="comment">// NoDerived不能作基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="keyword">final</span> :</span> Base {}; <span class="comment">// Last不能作基类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad</span> :</span> Last {}; <span class="comment">// 错误</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bad2</span> :</span> NoDerived {}; <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="14-1-3、类型转换与继承">14.1.3、类型转换与继承</h4>
<p>通常情况下，如果把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的const类型转换规则；<strong>存在继承关系的类是一个例外：可以将基类的指针或引用绑定到派生类对象上</strong></p>
<p>和内置指针一样，智能指针类也支持派生类向基类的类型转换</p>
<p>当使用存在继承关系的类型时，必须将一个变量或其他表达式的<strong>静态类型</strong>与该表达式表示对象的<strong>动态类型</strong>区分开来，表达式的静态类型<strong>在编译时总是已知的</strong>，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到<strong>运行时</strong>才可知</p>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致，以静态类型为准</p>
<p><strong>不存在基类向派生类的转换</strong>，因为派生类除了包含基类的部分，还包含自己的部分；<strong>即使一个基类的指针或引用绑定在一个派生类对象上，也不能执行基类向派生类的转换</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">Bulk_quote *bulkP = itemP; <span class="comment">// 错误：不能将基类转换成派生类</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>派生类向基类的自动转换只对<code>指针或引用</code>类型有效，在<code>派生类类型和基类类型</code>之间不存在这样的转换</strong></p>
<p>因为拷贝构造函数、赋值运算符、移动构造函数都接受引用作为参数，所以派生类向基类的转换允许给这些成员函数传递一个派生类的对象，但<strong>因为这些成员函数不是虚函数</strong>，实际运行时还是执行基类自己的相关成员函数，而不是派生类的成员函数</p>
<p>当用派生类对象为一个基类对象初始化或赋值时，<strong>只有派生类对象中的基类部分会被拷贝、移动或赋值，派生类部分将被忽略掉</strong></p>
<h3 id="14-2、虚函数">14.2、虚函数</h3>
<p>通常情况下，如果不适用某个函数，则无须为该函数提供定义，但是<strong>虚函数必须提供定义，不管它是否被用到了</strong></p>
<p><strong>动态绑定只有当通过<code>指针、引用</code>调用虚函数时才会发生，当通过一个具有普通类型(非引用非指针)的表达式调用函数时，在<code>编译时</code>就会将调用的版本确定下来</strong></p>
<p><strong>基类中的虚函数在派生类中隐含地也是一个虚函数</strong>，一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的<strong>形参类型必须与被它覆盖的基类函数完全一致，同样的返回类型也必须一致，但如果虚函数的返回类型是类本身的指针或引用时，上述规则将无效</strong>，比如如果D由B派生得到，则基类的虚函数可以返回<code>B*</code>而派生类的对象可以返回<code>D*</code>，这样的返回值类型要求从D到B的类型转换是可访问的</p>
<p>虚函数也可以拥有<strong>默认实参</strong>，如果某次调用使用了默认实参，则该<strong>实参值由本次调用的<code>静态类型</code>决定</strong>；如果通过基类的引用或指针调用函数，则使用基类中定义的默认实参，<strong>即使实际运行的是派生类中的函数版本也是如此</strong>，<strong>传入派生类函数</strong>的将是<strong>基类函数定义的默认实参</strong></p>
<p>在某些情况下，希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本，可以使用<strong>作用域运算符</strong>来实现这一目的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>); <span class="comment">// 不管baseP实际指向的对象类型到底是什么，都会强制调用Quote类的net_price函数</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注意</strong>：如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析成<strong>对派生类版本的自身调用</strong>，从而导致无限递归</p>
</blockquote>
<h3 id="14-3、抽象基类">14.3、抽象基类</h3>
<p>和普通的虚函数不一样，<strong>纯虚函数无须定义</strong>，可以在函数体的位置书写<code>= 0</code>就可以将一个虚函数说明为纯虚函数，<code>= 0</code>只能出现在<strong>类内部的虚函数声明语句中</strong>；可以为纯虚函数提供定义，不过<strong>函数体必须定义在类的外部</strong>，不能在类的内部为一个<code>= 0</code>的函数提供函数体</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>含有(或未经覆盖直接继承)纯虚函数的类是<strong>抽象基类</strong>，抽象基类负责定义接口，而后续的其他类可以覆盖该接口；<strong>不能(直接)创建一个抽象基类的对象，可以定义抽象基类的派生类的对象，前提是这些类覆盖了基类中的纯虚函数</strong>，如果抽象基类的派生类没有给出自己的纯虚函数的定义，则派生类也是抽象基类</p>
<h3 id="14-4、访问控制与继承">14.4、访问控制与继承</h3>
<p>受保护的成员：</p>
<ul>
<li>
<p>和私有成员一样，受保护的成员对于类的用户来说是不可访问的</p>
</li>
<li>
<p>和公有成员一样，受保护的成员对于<strong>派生类的成员和友元</strong>来说是可访问的</p>
</li>
<li>
<p>&lt;span id = “teshuqingkuangjichengyupaisheng"&gt;<strong>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员，不能在派生类中通过基类对象访问基类的<code>protected</code>成员</strong>，派生类对于一个基类对象中的受保护成员没有任何访问特权</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;)</span></span>; <span class="comment">// 能访问Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;)</span></span>; <span class="comment">// 不能访问Base::prot_mem</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>{ s.j = s.prot_mem = <span class="number">0</span>; } <span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>{ b.prot_mem = <span class="number">0</span>; } <span class="comment">// 错误</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>派生类的成员和友元</strong>只能访问<code>派生类对象</code>中的基类部分的受保护成员，对于普通的<code>基类对象</code>中的成员不具有特殊的访问权限 <strong>&lt;在派生类的成员函数中，只能通过派生类对象来访问基类的受保护的成员，不能通过基类对象去访问&gt;</strong><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>
<p>某个类对其继承而来的成员的访问权限受到两个因素影响：</p>
<ul>
<li>在基类中该成员的访问说明符</li>
<li>派生类的派生列表中的访问说明符</li>
</ul>
<p><strong>派生访问说明符对于<code>派生类的成员(及友元)</code>能否访问其直接基类的成员没什么影响，对基类成员的访问权限只与<code>基类中的访问说明符</code>有关 &lt;此处只对派生类的类体中的成员而言，而不是派生类对象而言的&gt;</strong></p>
<p><strong>派生访问说明符的目的是控制<code>派生类用户</code>(包括派生类的派生类在内)对于基类成员的访问权限</strong></p>
<p>派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：</p>
<ul>
<li>只有当D<code>公有地</code>继承B时，<code>用户代码</code>才能使用<strong>派生类向基类的转换</strong>；如果D继承B的方式是<code>受保护的或私有的</code>，则用户代码<code>不能</code>使用该转换</li>
<li>不论D以什么方式继承B，D的<code>成员函数和友元</code>(派生类内)都能使用派生类向基类的转换；**派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的  **&lt;只与基类的成员访问权限有关，与派生访问权限无关&gt;</li>
<li>如果D继承B的方式是<code>公有的或受保护</code>的，则<strong>D的派生类的成员和友元可以使用D向B的类型转换</strong>；反之如果D继承B的方式是私有的，则不能使用</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>
<p>子类对父类的访问权限：取决于父类中成员的权限设置，与继承权限无关，此处有个<a href="#teshuqingkuangjichengyupaisheng">特殊情况</a></p>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:center">public</th>
<th style="text-align:center">protected</th>
<th style="text-align:center">private</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"><strong>public</strong></td>
<td style="text-align:center"><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
<td style="text-align:center"><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
<td style="text-align:center"><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
</tr>
<tr>
<td style="text-align:right"><strong>protected</strong></td>
<td style="text-align:center"><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
<td style="text-align:center"><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
<td style="text-align:center"><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
</tr>
<tr>
<td style="text-align:right"><strong>private</strong></td>
<td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
<td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
<td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>类外对子类中继承自父类部分的访问权限：取决于继承权限和父类中成员的权限</p>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:center">public</th>
<th style="text-align:center">protected</th>
<th style="text-align:center">private</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"><strong>public</strong></td>
<td style="text-align:center"><strong>public</strong></td>
<td style="text-align:center"><strong>protected</strong></td>
<td style="text-align:center"><strong>private</strong></td>
</tr>
<tr>
<td style="text-align:right"><strong>protected</strong></td>
<td style="text-align:center"><strong>protected</strong></td>
<td style="text-align:center"><strong>protected</strong></td>
<td style="text-align:center"><strong>private</strong></td>
</tr>
<tr>
<td style="text-align:right"><strong>private</strong></td>
<td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
<td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
<td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td>
</tr>
</tbody>
</table>
<p><code>protected</code>只是对于派生类的类内成员来讲是可以访问的，对于派生类的用户对象是最少是<code>protected</code>，不可以访问的</p>
</li>
</ul>
<p><strong>友元关系不能继承</strong>，基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随意访问基类的成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pa1</span>;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pa1</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>{ <span class="keyword">return</span> b.prot_mem; } <span class="comment">// 正确</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(Sneaky s)</span> </span>{ <span class="keyword">return</span> s.j; } <span class="comment">// 错误</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>{ <span class="keyword">return</span> s.prot_mem; } <span class="comment">// 正确</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><code>Paul</code>是<code>Base</code>的友元，所以<code>Paul</code>能够访问<code>Base</code>对象的成员，这种<strong>可访问性包括了<code>Base</code>对象内嵌在其派生类对象中</strong>的情况；也就是说，<strong><code>Paul</code>可以访问<code>Base</code>以及<code>Base</code>所有派生类中的继承自基类的部分</strong></p>
<p>当一个类将另一个类声明为友元时，这种友元关系<strong>只对做出声明的类有效</strong>，那么这个<strong>友元类的基类或派生类</strong>不具有特殊的访问能力</p>
<p><span id="类内`using`声明的一般规则同样适用于重载函数的名字">通过在派生类的内部使用<code>using</code>声明语句，可以将该类的直接或间接基类中的<strong>任何可访问成员(非私有成员)<strong>标记出来，<code>using</code>声明语句中的</strong>名字的访问权限由<code>using</code>声明语句<code>之前</code>的访问说明符</strong>来决定，如果一条<code>using</code>声明语句出现在类的<code>private</code>部分，则该名字只能被类的成员和友元访问，如果<code>using</code>声明语句位于<code>public</code>部分，则类的所有用户都能访问它，如果<code>using</code>声明语句位于<code>protected</code>部分，则该名字对于成员、友元和派生类都是可访问的</span></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> n; }</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认情况下继承来的size()和n是对于类外成员来讲是Derived的私有成员</span></span><br><span class="line">    <span class="keyword">using</span> Base::size; <span class="comment">// 类内、类外成员都能访问它</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n; <span class="comment">// 派生类类内成员、类内成员、友元都能访问</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的，使用<code>struct</code>关键字定义的派生类是公有继承的</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> Base {}; <span class="comment">// 默认是public继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> Base {}; <span class="comment">// 默认是private继承</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="14-5、继承中的类作用域">14.5、继承中的类作用域</h3>
<h4 id="14-5-1、在编译时进行名字查找">14.5.1、在编译时进行名字查找</h4>
<p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内，<strong>如果一个名字在派生类的作用域之内无法解析，则编译器将继续在外层的基类作用域中寻找该名字的定义</strong></p>
<p>一个对象、引用或指针的<strong>静态类型决定了该对象的哪些成员是可见的</strong>，即使静态类型和动态类型不一致，能使用哪些成员仍然由<code>静态类型</code>决定的；<code>静态类型</code>决定编译器查找该成员的<strong>起始位置</strong>，只会向上查找，先在该类中查找，如果没有再在基类中查找，不会向下查找</p>
<h4 id="14-5-2、名字冲突与继承">14.5.2、名字冲突与继承</h4>
<p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域(派生类)的名字将隐藏定义在外层作用域(基类)的名字</p>
<p>可以通过作用域运算符来使用一个被隐藏的基类成员</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base {</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_base_mem</span><span class="params">()</span> </span>{ <span class="keyword">return</span> Base::mem; } <span class="comment">// 指示编译器从Base作用域开始查找mem，确定了开始查找的位置后，遇到的第一个mem就是结果</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>Tips</strong>：除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字</p>
</blockquote>
<p><strong>函数调用的解析过程</strong>：调用<code>p-&gt;mem()</code>或<code>obj.mem()</code></p>
<ul>
<li>首先确定<code>p,obj</code>的<strong>静态类型</strong></li>
<li>在<code>p,obj</code>的静态类型对应的类中查找<code>mem</code>，如果找不到，则<strong>依次在直接基类中不断查找直至到达继承链的顶端</strong>，如果找遍了该类及其基类仍谈找不到，则编译器将报错</li>
<li>一旦找到<code>mem</code>，就进行常规的类型检查，已确认对于当前找到的<code>mem</code>，本次调用是否合法</li>
<li>假设合法，则编译器将根据调用是否是虚函数而产生不同的代码：
<ul>
<li>如果<code>mem</code>是虚函数且通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的那个版本，依据是对象的动态类型</li>
<li>如果<code>mem</code>不是虚函数或者通过对象而非引用或指针进行的调用，则编译器将产生一个常规函数调用</li>
</ul>
</li>
</ul>
<h4 id="14-5-3、名字查找先于类型检查">14.5.3、名字查找先于类型检查</h4>
<p><a href="#shengmingzaineicunzuoyongdehanshubingbuhuichongzaishengmingzaiwaicengzuoyongyudehanshu">声明在内存作用域的函数并不会重载声明在外层作用域的函数</a>，因此定义在派生类中的函数也不会重载其基类中的成员，如果派生类的成员与基类的某个成员<strong>同名</strong>，则派生类将在作用域内<code>隐藏</code>(不是覆盖，<strong>只有函数名、形参列表、返回值相同才是覆盖</strong>)该基类成员，即使派生类成员和基类成员的形参列表不一样，基类成员也仍然会被隐藏掉 <strong>&lt;名字查找先于类型检查&gt;</strong></p>
<p><strong>基类与派生类中的虚函数必须有相同的形参列表</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base { </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 由于没有定义和基类虚函数int func()相同类型的函数，此处func将隐藏从基类继承来的虚函数，只是隐藏而不是覆盖</span></span><br><span class="line">    <span class="comment">// 由于基类对派生类来讲属于外层作用域，当调用func时，会优先匹配int func(int)类型的函数，但是从基类继承而来的虚函数还是存在的</span></span><br><span class="line">    <span class="comment">// D1类中含有2个fcn函数：虚函数fcn，自定义的int func(int)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>; </span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1 {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 虽然D1类中的func(int)把基类的虚函数隐藏了，但还是存在的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 覆盖Base的虚函数fcn</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base bobj;</span><br><span class="line">    D1 d1obj;</span><br><span class="line">    D2 d2obj;</span><br><span class="line">    </span><br><span class="line">    Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">    bp1-&gt;<span class="built_in">func</span>(); <span class="comment">// 虚调用，将在运行时调用Base::fcn</span></span><br><span class="line">    bp2-&gt;<span class="built_in">func</span>(); <span class="comment">// 虚调用：将在运行时调用Base::fcn，此时虚函数是存在于D1的，是直接继承Base的，而没有被覆盖</span></span><br><span class="line">    bp3-&gt;<span class="built_in">func</span>(); <span class="comment">// 虚调用：将在运行时调用D2::fcn，D2定义的fcn覆盖了虚函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>和其他函数一样，成员函数无论是否是虚函数都能被重载，派生类可以覆盖(从基类继承来的)重载函数的0个或多个实例&lt;<strong>这样派生类中只能调用被负载的函数，其他没被负载的将被</strong><code>隐藏</code>&gt;；如果派生类希望所有的(从基类继承来的)重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖(全部使用继承自基类的重载函数)</p>
<p>有时一个类仅需要覆盖重载集合中的一些而非全部函数(没被覆盖的需要继承下来，并且不被隐藏)，此时，不得不覆盖基类中的每一个版本；除此之外，可以<strong>为重载的成员提供一条<code>using</code>声明语句</strong>，这样就不需要覆盖基类中的每一个重载版本了</p>
<p><code>using</code>声明语句<strong>指定一个名字而不指定形参列表</strong>，所以一条基类成员函数的<code>using</code>声明语句就可以<strong>把该函数的<code>所有重载实例</code>加到派生类作用域中，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义</strong></p>
<p><a href="#%E7%B1%BB%E5%86%85%60using%60%E5%A3%B0%E6%98%8E%E7%9A%84%E4%B8%80%E8%88%AC%E8%A7%84%E5%88%99%E5%90%8C%E6%A0%B7%E9%80%82%E7%94%A8%E4%BA%8E%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E7%9A%84%E5%90%8D%E5%AD%97">类内<code>using</code>声明的一般规则同样适用于重载函数的名字</a>，<strong>基类函数的每个实例在派生类中都必须是可访问的，需要声明在<code>public</code>下</strong>，对派生类没有定义的重载版本的访问实际上是对<code>using</code>声明点的访问</p>
<h3 id="15-6、构造函数和拷贝控制">15.6、构造函数和拷贝控制</h3>
<h4 id="15-6-1、虚析构函数">15.6.1、虚析构函数</h4>
<p>由于通过基类的指针可以指向基类或者派生类，发生指针的静态类型与被删除对象的动态类型不符的情况；<strong>通过在基类中将析构函数定义成为虚函数以确保执行正确的析构函数，确保根据动态绑定的类型执行相应的析构函数</strong></p>
<p><strong>虚析构函数的虚属性也会被继承</strong>，所以无论派生类使用合成的析构函数还是自定义的析构函数，都将是虚析构函数</p>
<p><strong>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为</strong></p>
<p><a href="#%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E4%B9%9F%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">前面介绍</a>，如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作；基类的析构函数并不遵循上述准则，一个基类<strong>总是需要析构函数</strong>，而且它能将析构函数设定为虚函数，此时该析构函数为了成为虚析构函数而令内容为空，显然无法由此推断该基类是否需要赋值运算或拷贝构造函数</p>
<p><strong>如果一个类定义了析构函数，即使它通过<code>=default</code>的形式使用了合成的版本，编译器也不会为这个类合成移动操作</strong></p>
<h4 id="15-6-2、合成拷贝控制与继承">15.6.2、合成拷贝控制与继承</h4>
<p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作；<strong>这些合成的成员还负责使用<code>直接基类</code>中对应的操作对一个对象的<code>直接基类部分</code>进行初始化、赋值或销毁操作</strong>，但要求相应的成员应该是可访问的并且不是一个删除的函数</p>
<p>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类，该直接基类优惠销毁他自己的直接基类，以此类推直至继承链的顶端</p>
<p><a href="#%E5%B0%B1%E5%83%8F%E5%85%B6%E4%BB%96%E4%BB%BB%E4%BD%95%E7%B1%BB%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%80%E6%A0%B7">就像其他任何类的情况一样</a>，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数,，此外，某些定义基类的方式也可能导致有的派生成员成为被删除的函数：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211215000841534.png" alt="image-20211215000841534"></p>
<p><strong>大多数基类都会定义一个虚析构函数，因此默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作</strong>；如果确实需要执行移动操作时<strong>应该首先在基类中进行<code>显式地</code>定义，并且同时需要显式地定义拷贝操作，接着派生类将自动获得合成的移动操作</strong>，除非派生类中含有排斥移动的成员</p>
<h4 id="15-6-3、派生类的拷贝控制成员">15.6.3、派生类的拷贝控制成员</h4>
<p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员(使用基类的拷贝构造和移动构造函数)，派生类的赋值运算符也必须为其基类部分的成员赋值(使用基类的赋值运算符)</p>
<p>和构造函数及赋值运算符不同的是，<strong>析构函数只负责销毁派生类自己分配的资源</strong>，派生类对象的基类部分也是自动销毁的</p>
<p><strong>定义派生类的拷贝或移动构造函数</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base {</span><br><span class="line">    <span class="built_in">D</span>(<span class="keyword">const</span> D&amp; d) : <span class="built_in">Base</span>(d) {} <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">D</span>(<span class="keyword">const</span> D&amp;&amp; d) : <span class="built_in">Base</span>(<span class="built_in">move</span>(d)) {} <span class="comment">// 移动构造</span></span><br><span class="line">    D&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs) { <span class="comment">// 赋值运算符</span></span><br><span class="line">        Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分；如果想拷贝或移动基类部分，则<strong>必须在派生类的构造函数初始值列表中<code>显式地</code>使用基类的拷贝或移动构造函数</strong>，派生类的赋值运算符必须显式地为其基类部分赋值，基类的赋值运算符不会自动调用</p>
<p><strong>如果构造函数或析构函数调用了某个虚函数，则执行与构造函数或析构函数<code>所属类型相对应的</code>虚函数版本，<code>不会</code>发生动态绑定</strong>；派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。</p>
<blockquote>
<p><strong>Tips</strong>：一般不要在构造函数和析构函数中调用虚函数</p>
</blockquote>
<h4 id="15-6-4、继承的构造函数">15.6.4、继承的构造函数</h4>
<p>派生类能够重用其<strong>直接基类定义</strong>的构造函数；<strong>类不能继承默认、拷贝和移动构造函数</strong>，如果派生类没有直接定义这些构造函数，则编译器将为将为派生类合成它们；<strong><code>派生类继承基类构造函数的方式</code>是提供一条注明了(直接)基类名的<code>using</code>声明语句</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// 继承Base的构造函数</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>通常情况下，<code>using</code>声明语句只是令某个名字在当前作用域内可见，而当作用于构造函数时，<code>using</code>声明语句将令编译器产生代码，对于基类的每一个构造函数，编译器都生成一个与之对应的(<strong>形参列表相同的</strong>)派生类构造函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">derived</span>(parms) : <span class="built_in">base</span>(args) {} <span class="comment">// 形参列表和基类的完全相同，派生类自己的数据成员将被默认初始化</span></span><br></pre></td></tr></tbody></table></figure>
<p>和普通成员的<code>using</code>声明不一样，<strong>一个构造函数的<code>using</code>声明不会改变该构造函数的访问级别</strong>，不管<code>using</code>声明出现在哪里，基类的私有构造函数在派生类中还是私有构造函数，公有的还是公有，受保护的还是受保护的</p>
<p>一个<code>using</code>声明的语句不能指定<code>explicit</code>或<code>constexpr</code>，如果基类的构造函数是<code>explicit, constexpr</code>的，则继承的构造函数也拥有相同的属性</p>
<p>当一个基类构造函数含有默认实参时，<strong>这些实参并不会被继承</strong>，相反，<strong>派生类将获得多个继承的构造函数</strong>，其中每个构造函数分别<strong>省略掉一个含有默认实参的形参</strong></p>
<p>如果基类含有几个构造函数，除了两个例外，大多数时候派生类会继承所有这些构造函数：</p>
<ul>
<li>派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本</li>
<li>默认、拷贝和移动构造函数不会被继承，这些构造函数按照正常规则被合成，<strong>继承的构造函数不会被作为用户定义的构造函数来使用，则还会生成一个合成的默认构造函数</strong></li>
</ul>
<h3 id="15-7、容器与继承">15.7、容器与继承</h3>
<p>使用容器存放继承体系中的对象时，必须采用<code>间接</code>存储的方式，<strong>存放基类的指针(智能指针)</strong>，指针所指对象的动态类型可以是基类类型或派生类类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;Base&gt;&gt; base;</span><br><span class="line">base.<span class="built_in">push_back</span>(make_shared&lt;Derived&gt;(derived));</span><br></pre></td></tr></tbody></table></figure>
<h3 id="15-8、多重继承">15.8、多重继承</h3>
<p>每个基类包含一个可选的访问说明符，如果访问说明符被忽略了，则关键字class对应的默认访问说明符是private，关键字struct对应的是public</p>
<p>多重继承的派生列表只能包含<strong>已经被定义过</strong>的类，而且这些类不能是final的</p>
<p>多重继承的派生类的构造函数初始值只能初始化它的<strong>直接基类</strong>，派生类的构造函数初始值列表将实参分别传递给每个直接基类，基类的构造顺序与<strong>派生类列表中的基类的出现顺序</strong>保持一致</p>
<p>派生类可以从它的一个或几个基类中继承构造函数，但如果从多个基类中继承了相同的构造函数(形参列表完全相同)，程序将产生错误；否则<strong>派生类必须为该构造函数定义自己的版本</strong>，同时还需要<strong>显式地定义</strong>默认构造函数</p>
<p>派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的</p>
<p>多重继承的派生类如果定义了自己的拷贝、赋值构造函数和赋值运算符，则必须在<em><strong>完整的对象上</strong></em>执行拷贝、移动或赋值操作；只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作，在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作</p>
<h4 id="15-8-1、类型转换与多个基类">15.8.1、类型转换与多个基类</h4>
<p>在多重继承中，也可以令某个<strong>可访问</strong>基类的指针或引用直接指向一个派生类对象</p>
<h4 id="15-8-2、多重继承下的类作用域">15.8.2、多重继承下的类作用域</h4>
<p>查找过程沿着继承体系自底向上进行，直到找到所需的名字，派生类的名字将隐藏基类的同名成员；在多重继承中，相同的查找过程在所有<strong>直接基类</strong>中<strong>同时</strong>进行，如果名字在多个基类中都被找到，则对该名字的使用将产生二义性，但可以通过添加前缀信息调用</p>
<h3 id="15-9-虚继承">15.9.虚继承</h3>
<p>虚继承的目的是令某个类做出声明，承诺愿意共享它的基类，共享的基类子对象成为<strong>虚基类</strong>，<strong>不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象</strong></p>
<p><strong>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身</strong></p>
<p>指定虚基类的方法：在派生列表中添加关键字<code>virtual</code></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccoon</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal {};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>不论基类是不是虚基类，派生类(或派生的派生类)对象都能被可访问基类的指针或引用操作</strong></p>
<p><strong>虚基类成员的可见性</strong>：</p>
<ul>
<li>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被(派生的派生类)直接访问，并不会产生二义性；</li>
<li>如果虚基类只被一条派生路径覆盖，则仍然可以直接访问被覆盖的成员，此时访问到的就是直接基类中成员，而不是虚基类的成员；</li>
<li>如果成员被多个基类覆盖，则一般情况下派生类必须为该成员自定义一个版本，否则会产生二义性</li>
</ul>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211219144139382.png" alt="image-20211219144139382"></p>
<h4 id="15-9-1、构造函数与虚继承">15.9.1、构造函数与虚继承</h4>
<p><strong>在虚派生中，虚基类是由最底层的派生类初始化</strong></p>
<p>含有虚基类的对象的构造顺序：首先使用提供给<strong>最底层</strong>基类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其初始化</p>
<p><strong>虚基类总是先于非虚基类构造</strong></p>
<p>一个类可以有多个虚基类，这些虚的子对象按照它们在派生列表中出现的顺序从左到右依次构造；编译器<strong>按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类，如果有，则先构造虚基类，然后按照声明的顺序依次构造其他非虚基类</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooAnimal</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccon</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookCharacter</span> :</span> <span class="keyword">public</span> Character {};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyAnimal</span> {</span>};</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeddyBear</span> :</span> <span class="keyword">public</span> BooKCharacter, <span class="keyword">public</span> Bear, <span class="keyword">public</span> <span class="keyword">virtual</span> ToyAnimal {};</span><br><span class="line">TeddyBear tb;</span><br><span class="line"><span class="comment">// tb的构造顺序</span></span><br><span class="line"><span class="comment">// 按照TeddyBear的直接基类声明的顺序对其依次检查，看是否有虚基类</span></span><br><span class="line"><span class="comment">// BooKCharacter没有，Bear有，ToyAnimal有</span></span><br><span class="line"><span class="built_in">ZooAnimal</span>();</span><br><span class="line"><span class="built_in">ToyAnimal</span>();</span><br><span class="line"><span class="comment">// 按照声明的顺序依次构造非虚基类</span></span><br><span class="line"><span class="built_in">Character</span>();</span><br><span class="line"><span class="built_in">BookCharacter</span>();</span><br><span class="line"><span class="built_in">Bear</span>();</span><br><span class="line"><span class="built_in">TeddyBear</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值，和往常一样，对象的销毁顺序与构造顺序正好相反</p>
<h2 id="16、模板与泛型编程">16、模板与泛型编程</h2>
<h3 id="16-1、定义模板">16.1、定义模板</h3>
<h4 id="16-1-1、函数模板">16.1.1、函数模板</h4>
<p>函数模板的定义形式</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;模板参数列表&gt;</span><br><span class="line">函数定义</span><br></pre></td></tr></tbody></table></figure>
<p>在函数模板的<strong>定义</strong>中，<strong>模板参数列表不能为空</strong></p>
<p>模板参数表示类或函数定义中用到的<strong>类型或值</strong>，使用模板时，可以隐式或显式地指定<strong>模板实参</strong>，将其绑定到模板参数上</p>
<p>调用函数模板时，<code>编译器</code>用函数实参来推断模板实参，用推断出来的模板实参来实例化一个特定版本的函数</p>
<p>函数模板可以声明为<code>inline</code>或<code>constexpr</code>的，<code>inline、constexpr</code>说明符放在模板参数列表之后，返回类型之前</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-1-1、类型参数">16.1.1.1、类型参数</h5>
<p>可以<strong>将类型参数看作类型说明符</strong>，像内置类型或类类型说明符一样使用，类型说明符可以用来<strong>指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">foo</span><span class="params">(T* p)</span> </span>{</span><br><span class="line">    T tmp = *p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>类型参数前必须使用关键字<code>class</code>或<code>typename</code></strong>，两者可以随便搭配着用</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt;  <span class="comment">// 错误：每个类型参数前都要使用关键字</span></span><br><span class="line"><span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> U&amp;)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-1-2、非类型参数">16.1.1.2、非类型参数</h5>
<p>非类型参数表示一个<strong>值</strong>而非一个类型，通过<strong>特定的类型名</strong>而非关键字<code>class、typename</code>来指定非类型参数</p>
<p>当一个模板被实例化时，<strong>非类型参数</strong>被一个用户提供的或编译器推断出的值所代替，这些值必须是<strong>常量表达式</strong>，从而允许编译器在<strong>编译时</strong>实例化模板</p>
<p>一个非类型参数可以是<strong>整型、指向对象或函数类型的指针、(左值)引用</strong>，绑定到<strong>非类型整型参数</strong>的实参必须是一个<strong>常量表达式</strong>，绑定到<strong>指针或引用的非类型参数</strong>的实参必须<strong>具有静态的生存期</strong>，指针参数也可以用<code>nullptr、0</code>来实例化</p>
<p>模板非类型参数是一个常量值，在需要常量表达式的地方，可以使用非类型参数，例如指定数组的大小</p>
<blockquote>
<p><strong>说明</strong>：模板的实例化是在编译器进行的</p>
</blockquote>
<h4 id="16-1-2、类模板">16.1.2、类模板</h4>
<p>类模板以关键字<code>template</code>开始，后跟<strong>模板参数列表</strong>，在类模板及其成员的定义中将模板参数当作替身，代替使用模板时用户需要提供的类型和值</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 定义模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span> {</span>};</span><br><span class="line"></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; blob; <span class="comment">// 使用模板</span></span><br></pre></td></tr></tbody></table></figure>
<p>与函数模板不同，<strong>编译器不能为类模板推断模板参数类型</strong>，使用类模板<strong>必须使用<code>显式模板实参</code>，在模板名后的尖括号中提供额外信息</strong>，用来代替模板参数的模板实参列表；但<strong>在类模板的作用域内，可以直接使用模板名而不提供实参</strong>；如果<strong>在类外定义其成员，直到遇到类名才表示进入类的作用域，函数的返回值位于类的作用域之外</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlobPtr</span>() {}</span><br><span class="line">    BlobPtr&amp; <span class="keyword">operator</span>++(); <span class="comment">// 模板作用域内，直接使用模板名，而不用指定显式模板实参</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++() {</span><br><span class="line">    <span class="comment">//可以直接使用BlobPtr，不需要指定显式实参</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>一个类模板的每个实例都形成一个<code>独立</code>的类</strong></p>
<p><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>类模板的名字不是一个类型名</strong><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>👈</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f448.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，类模板用来实例化类型，而一个<strong>实例化的类型总是包含模板参数</strong>的，所以只有实例化的模板才是类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// vector&lt;int&gt;是类型</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-2-1、类模板的成员函数">16.1.2.1、类模板的成员函数</h5>
<p>成员函数既可以在类模板内部定义，也可以在类模板外部定义；类模板的<strong>每个实例都有自己版本的成员函数</strong>，类模板的成员函数具有和模板相同的模板参数，所以</p>
<ul>
<li><strong>定义在类模板之外的成员函数必须以关键字<code>template</code>开始，后接类模板参数列表</strong>；</li>
<li>同时还需要说明成员属于哪一个类，从一个模板生成的类的名字中必须包含模板实参，当定义一个成员函数时，<strong>模板实参和模板形参相同</strong></li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 需要指明模板参数</span></span><br><span class="line">ret-type Blob&lt;T&gt;::member-<span class="built_in">name</span>(parm-list) {} <span class="comment">// 需要指明该函数属于哪一个类，类名包含模板实参，模板实参和模板形参相同 Blob&lt;T&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>构造函数也属于成员函数，类模板外部定义也需要和成员函数的要求一样</p>
<p>默认情况下，<strong>一个类模板的成员函数只有当程序用到它时才进行实例化</strong>；如果一个成员函数没有被使用，则它不会被实例化；这一特性使得某种类型不能完全符合模板操作的要求，仍能用该类型实例化类</p>
<h5 id="16-1-2-2、类模板和友元">16.1.2.2、类模板和友元</h5>
<p>如果一个类模板包含一个非模板友元，则友元被授权可以访问<strong>所有模板实例</strong>；如果友元自身是模板，可以授权给所有友元模板实例，也可以授权给特定实例</p>
<h6 id="16-1-2-2-1、一对一友好关系">16.1.2.2.1、一对一友好关系</h6>
<p>类模板与另一个模板间友好关系的最常见形式是<strong>建立<code>对应实例</code>及其友元间的友好关系</strong>，友元的声明用类模板的模板形参作为自己的模板实参</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span> {</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;</span>T&gt;; <span class="comment">// 用类模板的形参作为友元的模板实参，可以建立对应实例间的友元关系 </span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h6 id="16-1-2-2、通用和特定的模板友好关系">16.1.2.2、通用和特定的模板友好关系</h6>
<p>一个类可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> {</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>C&gt;; <span class="comment">// 限定特定的实例为友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span> <span class="comment">// 每一个实例都声明为友元</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> {</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;</span>T&gt;; <span class="comment">// 一对一友好关系，也是特定友好关系</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span> <span class="comment">// Pal2所有的实例都是C2的每个实例的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span> <span class="comment">// Pal3是非模板类，C2所有实例的友元</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><strong>类模板所有的实例都成为友元，友元声明中必须使用与类模板本身<code>不同</code>的模板参数</strong></p>
<h6 id="16-1-2-3、令模板自己的类型参数成为友元">16.1.2.3、令模板自己的类型参数成为友元</h6>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> {</span></span><br><span class="line">    <span class="keyword">friend</span> Type; <span class="comment">// 令模板自己的类型参数成为友元</span></span><br><span class="line">    <span class="comment">/////////</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-2-3、模板类型别名">16.1.2.3、模板类型别名</h5>
<p>类模板的<strong>一个实例定义了一个类类型</strong>，可以定义一个<code>typedef</code>来引用实例化的类</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;string&gt; StrBlob;</span><br></pre></td></tr></tbody></table></figure>
<p>由于模板不是一个类型，不能定义一个<code>typedef</code>引用一个模板，但可以通过<code>using</code>为模板定义一个类型别名</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="keyword">int</span>&gt; win_loss; <span class="comment">// == pair&lt;int, int&gt;</span></span><br><span class="line">twin&lt;string&gt; win_str; <span class="comment">// == pair&lt;string, string&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>当定义一个模板类型别名时，可以<strong>固定一个或多个模板参数</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNp = pair&lt;string, T&gt;;</span><br><span class="line">partNp&lt;string&gt; books; <span class="comment">// == pair&lt;string, string&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-2-4、类模板的static成员">16.1.2.4、类模板的static成员</h5>
<p>模板类的每个<code>static</code>数据成员必须有且仅有一个定义，类模板的每个实例都有一个<code>独有</code>的static对象，<strong>在类外定义<code>static</code>数据成员也需要定义成模板</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>与非模板类的静态成员相同，可以通过类类型对象来访问一个类模板的static成员，也可以使用作用域运算符直接访问成员，通过类直接访问时，必须引用一个特定的实例；和其他成员函数一样，static成员函数只有在使用时才会实例化</p>
<h4 id="16-1-3、模板参数">16.1.3、模板参数</h4>
<p>模板参数遵循普通的作用域规则，一个<strong>模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前</strong>；模板参数会隐藏外层作用域中声明的相同名字，<strong>在模板内不能重用模板类型参数名</strong>，并且一个模板参数名在一个模板参数列表中只能出现一次</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span> </span>{</span><br><span class="line">    A tmp = a; <span class="comment">// A是模板参数A的类型，不是double的别名</span></span><br><span class="line">    <span class="keyword">double</span> B; <span class="comment">// 错误：不能重用模板参数B</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-3-1、模板声明">16.1.3.1、模板声明</h5>
<p><strong>模板声明必须包含模板参数</strong>，但可以不指定具体的模板参数名；声明中的模板参数名不必与定义中的相同，但一个给定模板的每个声明和定义必须有相同数量和种类(类型参数、非类型参数)的参数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> D, <span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">ff</span>;</span> <span class="comment">// 必须包含模板参数，但可以不指定模板参数名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt; <span class="comment">// 声明和定义的参数数量和种类需要相同，参数名可以不同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fff</span> {</span>};</span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-3-2、使用类的类型成员">16.1.3.2、使用类的类型成员</h5>
<p>默认情况下，<strong>C++语言假定通过作用域运算符访问的名字不是类型</strong>，如果使用一个<strong>模板类型的类型成员</strong>，必须<strong>通过<code>typename</code>显式告诉编译器该名字是一个类型</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> T::value_type</span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-3-3、默认模板实参">16.1.3.3、默认模板实参</h5>
<p>与函数默认实参一样，对于一个模板参数，只有当<strong>它右侧所有参数都有默认实参</strong>时，它才可以有<strong>默认实参</strong></p>
<p>无论何时<strong>使用</strong>一个<strong>类模板，都必须在模板名之后接上尖括号</strong>，尖括号指出类必须从一个模板实例化而来；如果一个类模板为其所有模板参数都提供了默认实参，且使用这些默认实参，就必须在模板名之后跟一个空尖括号对</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt; <span class="comment">// 提供默认模板实参 </span></span><br><span class="line">class Numbers {};</span><br><span class="line">Numbers&lt;&gt; average; <span class="comment">// 使用默认实参</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="16-1-4、成员模板">16.1.4、成员模板</h4>
<p>一个类(模板类或普通类)可以包含本身是模板的成员函数，这种成员称为成员模板，<strong>成员模板不能是虚函数</strong></p>
<h5 id="16-1-4-1、普通类的成员模板">16.1.4.1、普通类的成员模板</h5>
<p>成员模板也是以模板参数列表开始，在调用时会编译器会自动推断模板实参类型</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T *p)</span> <span class="keyword">const</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-1-4-2、类模板的成员模板">16.1.4.2、类模板的成员模板</h5>
<p>对于类模板，可以为其定义成员模板，<strong>类和成员各自有自己的、独立的模板参数</strong>；与类模板的普通函数不同，成员模板是函数模板，当在类模板<strong>外定义一个成员模板</strong>时，必须<strong>同时为类模板和成员模板提供模板参数列表</strong>，类模板参数列表在前，后跟成员自己的模板参数列表</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 类模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="comment">// 成员模板参数</span></span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(It b, It e) {}</span><br></pre></td></tr></tbody></table></figure>
<p>实例化一个类模板的成员函数，必须<strong>同时提供类和函数模板的实参</strong>，在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参，根据传递给成员模板的函数实参来推断它的模板实参</p>
<h4 id="16-1-5、控制实例化">16.1.5、控制实例化</h4>
<p>当模板使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中；当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中都会有该模板的一个实例；可以通过<code>显式实例化</code>来避免在多个文件中生成同类型的实例化</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration; <span class="comment">// 实例化定义</span></span><br><span class="line"><span class="comment">// declaration是一个&lt;&lt;&lt;||||||类或函数声明||||||&gt;&gt;&gt;，其中所有模板参数已被替换为模板实参</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;</span>string&gt;; <span class="comment">// 实例化定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>当编译器遇到<code>extern</code>模板声明时，它不会在本文件中生成实例化代码，而遇到实例化定义时，会为它生成代码；<strong>对于一个给定的实例化版本，可能有多个<code>extern</code>声明，但必须只有一个定义</strong></p>
<p><strong><code>extern</code>声明必须出现在任何使用此实例化版本的代码之前</strong></p>
<p>与处理模板的普通实例化不同，一个类的<strong>实例化定义会实例化该模板的<code>所有</code>成员</strong>，包括内联的成员函数，此时需要保证所用类型能用于模板的所有成员</p>
<h3 id="16-2、函数模板实参推测">16.2、函数模板实参推测</h3>
<h4 id="16-2-1、类型转化与模板类型参数">16.2.1、类型转化与模板类型参数</h4>
<p>与非模板函数一样，在一次调用中传递给<strong>函数模板</strong>的<strong>实参</strong>被用来<strong>初始化函数的形参</strong>；如果一个<strong>函数形参的类型使用了模板类型参数</strong>，那么<strong>采用特殊的初始化规则</strong>；编译器通常<strong>不是对实参进行类型转换</strong>，而是生成一个新的模板实例</p>
<p><a href="#xingcandedingcengconst">和往常一样</a>，顶层<code>const</code>(本身是const的)无论在<strong>形参</strong>还是<strong>实参</strong>中都会被忽略；在其他类型转换中，能在调用中应用于函数模板的包括如下两项：</p>
<ul>
<li><code>const</code>转换：可以将一个非<code>const</code>对象的引用或指针传递给一个<code>const</code>的引用或指针形参，也就是说，<strong>非<code>const</code>对象可以赋值给<code>const</code>的引用</strong></li>
<li>数组或函数指针转换：如果<strong>函数形参不是引用类型</strong>，则<strong>可以对数组类型的实参应用正常的指针转换</strong>。一个数组实参可以转换为一个指向其首元素的指针，一个函数实参可以转换为一个该函数类型的指针</li>
</ul>
<p><strong>其他类型转换，如算数转换、派生类向基类的转换、用户定义的转换都不能用于函数模板</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fobj</span><span class="params">(T, T)</span></span>; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">fref</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// 底层引用</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">"a value"</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">const</span> string <span class="title">s2</span><span class="params">(<span class="string">"another value"</span>)</span></span>;</span><br><span class="line"><span class="built_in">fobj</span>(s1, s2); <span class="comment">// 调用fobj(string, string)，const string s2的顶层const被忽略</span></span><br><span class="line"><span class="built_in">fref</span>(s1, s2); <span class="comment">// 调用fref(const T&amp;, const T&amp;)，将string s1非const引用传递给const的引用</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], b[<span class="number">42</span>];</span><br><span class="line"><span class="built_in">fobj</span>(a, b); <span class="comment">// 形参不是引用类型，数组名可以转换为指针，调用fobj(int *, int *)</span></span><br><span class="line"><span class="built_in">fref</span>(a, b); <span class="comment">// 错误：形参是引用类型，数组名不能转化为指针，两个数组的类型不统一</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有<code>const</code>转换及数组或函数到指针的转换</p>
</blockquote>
<p><strong>一个模板类型参数可以用作多个函数形参的类型，由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line"><span class="built_in">compare</span>(lng, <span class="number">1024</span>); <span class="comment">// 错误：不能实例化compare(long, int)</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以通过将函数模板的每一个形参类型单独取名定义，这样可以对函数实参进行正常的类型推断</p>
<p>函数模板可以有用<strong>普通类型定义的参数</strong>，这种实参<strong>不进行特殊处理</strong>，可以正常进行类型转换</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span> </span>{}</span><br><span class="line"><span class="built_in">print</span>(cout, <span class="number">42</span>); <span class="comment">// os可以进行正常的类型转换，调用print(ostream&amp;, int)</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="16-2-2、函数模板显式实参">16.2.2、函数模板显式实参</h4>
<p>对于<strong>函数模板的返回类型，编译器无法推断出返回类型，需要用户显式控制返回类型</strong></p>
<p>显式模板<strong>实参在尖括号中给出</strong>，位于函数名之后，实参列表之前；<strong>显式模板实参按由左至右的顺序与对应的模板参数匹配</strong>：第一个模板实参与第一个模板参数匹配，依次类推；<strong>只有<code>最右边参数</code>的显式模板实参才可以忽略，前提是它们可以从函数参数推断出来</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng); <span class="comment">// long long sum(int, long)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">sum1</span><span class="params">(T2, T1)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> val4 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng); <span class="comment">// 错误：T3的类型未知</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>对于模板参数已经<code>显式指定</code>了的函数实参，可以进行正常的类型转换</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(T a, T b)</span></span>;</span><br><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">43</span>); <span class="comment">// 正确：long能转换为int</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="16-2-3、尾置返回类型与类型转换">16.2.3、尾置返回类型与类型转换</h4>
<p>尾置返回类型的形式：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">function</span><span class="params">(param)</span> -&gt; <span class="title">decltype</span><span class="params">(param)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>由于尾置返回类型出现在参数列表之后，它可以使用函数的参数</strong></p>
<blockquote>
<p><strong>注</strong>：<code>decltype</code>对左值的推断结果是一个<strong>引用</strong>类型</p>
</blockquote>
<p><strong>进行类型转换的标准库模板类</strong></p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211223232211097.png" alt="image-20211223232211097"></p>
<h4 id="16-2-4、函数指针和实参推断">16.2.4、函数指针和实参推断</h4>
<p>当用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用<strong>指针的类型</strong>来推断<strong>模板实参</strong></p>
<p>如果不能从函数指针类型确定模板实参，则会产生错误</p>
<p><strong>当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数能唯一确定其类型和值</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> string&amp;, <span class="keyword">const</span> string&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>(*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line"><span class="built_in">func</span>(compare); <span class="comment">// 错误：不知道使用哪一个版本的实例</span></span><br><span class="line"><span class="built_in">func</span>(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">// 可以通过显式模板实参消除歧义</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="16-2-5、模板实参的推断和引用">16.2.5、模板实参的推断和引用</h4>
<h5 id="16-2-5-1、从左值引用函数参数推断类型">16.2.5.1、从左值引用函数参数推断类型</h5>
<p>当一个函数参数是<strong>模板类型参数的一个普通左值引用</strong>时，<strong>只能传递它一个左值</strong>；实参可以是<code>const</code>的，也可以不是，如果实参是<code>const</code>的，则被推断为<code>const</code>类型的</p>
<p>当一个函数参数是<strong>模板类型参数的一个<code>const</code>的左值引用</strong>时，可以传递它<strong>任何类型</strong>的实参，可以是(<code>const</code>或非<code>const</code>)对象、临时对象、字面常量值；此时推断的类型结果不会是一个<code>const</code>类型，<code>const</code>已经是函数参数类型的一部分了</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f1</span>(<span class="number">42</span>); <span class="comment">// T推断结果是int，而不是const int</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="16-2-5-2、从右值引用函数参数推断类型">16.2.5.2、从右值引用函数参数推断类型</h5>
<p>当一个函数参数是一个右值引用时，可以传递一个右值，也<strong>可以是一个左值，前提是函数的右值引用参数必须指向模板类型参数</strong></p>
<p>正常绑定规则之外的两个例外规则：</p>
<ul>
<li>当一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数时，编译器<strong>推断模板类型参数为实参的左值引用类型</strong></li>
<li>如果间接的创建一个引用的引用，则这些引用形成了<code>折叠</code>；除了右值引用的右值引用会折叠成右值引用外，其他所有折叠结果都是左值</li>
</ul>
<blockquote>
<p><strong>说明</strong>：引用折叠只能应用于<strong>间接创建</strong>的引用的引用，如类型别名或模板参数</p>
</blockquote>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">32</span>;</span><br><span class="line"><span class="built_in">fun</span>(i); <span class="comment">// i是一个左值，编译器推断T为一个左值引用类型int&amp;，因此int&amp; &amp;&amp;折叠为int&amp;，可以传递左值实例化fun</span></span><br></pre></td></tr></tbody></table></figure>
<p>总结：</p>
<ul>
<li>如果一个函数参数是一个指向模板类型参数的右值引用，则它可以被绑定到一个左值</li>
<li>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个普通左值引用参数</li>
</ul>
<p>如果一个函数参数是<strong>指向模板参数类型</strong>的<strong>右值引用</strong>，则可以传递给它<strong>任意类型的实参</strong>；如果将一个左值传递给它，则函数参数被实例化为一个普通的左值引用</p>
<p>在实际中，右值引用通常用于两种情况：</p>
<ul>
<li>模板转发其实参</li>
<li>模板被重载</li>
</ul>
<blockquote>
<p><strong>说明</strong>：虽然不能<strong>直接</strong>将一个左值绑定到右值引用上，但可以通过<a href="#moveshixianyouzhiyinyongbangdingzuozhiyinyong"><code>move</code></a>实现；也可以通过<code>static_cast</code>强制将一个左值转换为右值引用</p>
</blockquote>
<h4 id="16-2-6、转发">16.2.6、转发</h4>
<p>通过将一个函数参数定义为<strong>一个指向模板类型参数的<code>右值</code>引用</strong>，可以<strong>保持其对应实参的所有类型信息</strong>，而使用<strong>引用参数</strong>(无论是左值还是右值)都可以<strong>保持<code>const</code>属性</strong>，因为在引用类型中的<code>const</code>是底层的</p>
<p>可以使用<code>forward</code>传递那些定义为模板类型参数的<strong>右值引用</strong>的函数参数，通过其返回类型上的引用折叠，<code>forward</code>可以保持给定实参的左值、右值属性</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="built_in">intermediary</span>(Type &amp;&amp;arg) { <span class="comment">// 这里的arg是右值</span></span><br><span class="line">    <span class="built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg)); <span class="comment">// 此处的arg成为左值，如果保持arg的右值属性，forward可以保持右值属性</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="16-3、重载与模板">16.3、重载与模板</h3>
<p>函数模板可以被另一个模板或一个普通非模板函数重载，名字相同的函数必须具有不同数量或类型的参数</p>
<p>如果涉及函数模板，则函数匹配规则会在以下方面受到影响：</p>
<ul>
<li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例</li>
<li>候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板</li>
<li>可行函数(包括模板与非模板函数)按类型转换来排序</li>
<li>如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数；如果有多个函数提供同样好的匹配，则：
<ul>
<li>如果同样好的函数中只有一个是非模板函数，则选择此函数</li>
<li>如果同样好的函数没有非模板函数，而且有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板</li>
<li>否则，此调用有歧义</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *)</span></span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">const</span> string *sp = &amp;s;</span><br><span class="line">cout &lt;&lt; <span class="built_in">debug_rep</span>(sp) &lt;&lt; endl; <span class="comment">// 因为T*比const T&amp;更特例化，调用debug_rep(T *)</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>当有多个重载模板对一个调用提供同样好的匹配时，应选择<code>最特例化</code>的版本</strong></p>
<p>在定义任何函数之前，记得<strong>声明所有重载的函数版本</strong>，这样就不必担心编译器由于未遇到希望调用的函数而实例化一个并非所需的版本</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">string <span class="title">debug_rep</span><span class="params">(T *p)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> string &amp;)</span></span>; <span class="comment">// 此处需要声明，否则编译器会自己实例化一个</span></span><br><span class="line"><span class="function">string <span class="title">debug_rep</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">debug_rep</span>(<span class="built_in">string</span>(p));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="16-4、可变参数模板">16.4、可变参数模板</h3>
<p><strong>可变参数模板</strong>是一个接受可变数目参数的模板函数或模板类，可变数目的<strong>参数</strong>被称为<strong>参数包</strong>；存在两种参数包：</p>
<ul>
<li>模板参数包：表示零个或多个模板参数</li>
<li>函数参数包：表示零个或多个函数参数</li>
</ul>
<p>用一个省略号来<strong>指出</strong>一个模板参数或函数参数表示一个包；在一个模板参数列表中，<code>class...</code>或<code>typename...</code>指出接下来的参数表示零个或多个类型的列表；一个类型名跟一个省略号表示零个或多个给定类型的非类型参数的列表；在函数参数列表中，如果一个参数的类型是一个模板参数包，则此<strong>参数</strong>也是一个函数参数包</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ARGS&gt; <span class="comment">// ARGS是一个模板参数包</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> ARGS&amp; ... rest)</span></span>; <span class="comment">// rest是一个函数参数包</span></span><br></pre></td></tr></tbody></table></figure>
<p>与往常一样，编译器从函数的实参推断模板参数类型；对于一个可变参数模板，编译器还会推断包中参数的数目</p>
<p>可以使用<code>sizeof...</code>运算符查看包中有多少元素</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ARGS&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> ARGS&amp; ... rest)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(ARGS) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">sizeof</span>...(rest) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>可变参数函数通常是递归的</strong>，第一步调用处理包中的第一个实参，然后用剩余实参调用自身；为了终止递归，还需要定义一个<strong>非可变参数</strong>的函数版本，此函数<strong>必须在可变参数版本定义之前声明</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span> <span class="comment">// 终止递归版本</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> os &lt;&lt; t; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">", "</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...); <span class="comment">// 递归调用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于最后一个调用，两个函数模板提供同样好的匹配，但是非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本</p>
<h5 id="16-4-1、包扩展">16.4.1、包扩展</h5>
<p>当扩展一个参数包(包括模板参数包和函数参数包)时，还要提供用于<strong>每个扩展元素的模式</strong>；<strong>扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表</strong>；通过在<strong>模式右边</strong>(模式是…左边的内容)放一个省略号来触发扩展操作</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span> </span>{ <span class="comment">// 扩展Args，模式是const Args&amp;，每个元素的类型都是const type&amp;，此模式扩展结果是一个逗号分隔的零个或多个类型的列表</span></span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...); <span class="comment">// 扩展rest，模式是函数参数包的名字rest，此模式扩展的结果是一个由包中元素组成的、逗号分隔的列表</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>第一个扩展操作扩展模板参数包</strong>，为模板函数生成<strong>函数参数列表</strong>，此模式扩展结果是一个逗号分隔的零个或多个<strong>类型的列表</strong>；<strong>第二个扩展操作扩展函数参数包</strong>，出现在<strong>递归调用</strong>中，为调用生成实参列表，此模式扩展的结果是一个由<strong>包中元素</strong>组成的、逗号分隔的列表</p>
<p>函数参数包扩展仅仅将包扩展为构成元素，允许更复杂的扩展模式</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args&amp;... rest)</span> </span>{ </span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, <span class="built_in">debug_rep</span>(rest)...); <span class="comment">// 扩展rest，模式是debug_rep(rest)</span></span><br><span class="line">    <span class="comment">// return print(os, debug_rep(rest...)); // 错误</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>扩展中的模式会<code>独立地</code>应用于包中的每个元素</strong></p>
<h5 id="16-4-2、转发参数包">16.4.2、转发参数包</h5>
<p>可变参数函数通常将它们的参数转发给其他函数，可以组合使用可变参数模板与<code>forward</code>机制来编写函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    alloc.<span class="built_in">construct</span>(first_free++, std::forward&lt;Args&gt;(args)...);  <span class="comment">// 既扩展了模板参数Args，又扩展了函数参数包args</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="16-5、模板特例化">16.5、模板特例化</h3>
<h4 id="16-5-1、定义函数模板特例化">16.5.1、定义函数模板特例化</h4>
<p>当特例化一个函数模板时，必须为原模板中的<strong>每个模板参数</strong>都提供实参；为了指出正在实例化的一个模板，应使用关键字<code>template</code>后跟一个<strong>空括号对</strong><code>&lt;&gt;</code>，空括号指出将为原模板的所有模板参数提供实参</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> &amp;p2)</span> </span>{} <span class="comment">// T的类型是const *</span></span><br></pre></td></tr></tbody></table></figure>
<p>当定义一个特例化版本时，<strong>函数参数类型必须与一个之前声明的模板中对应的类型匹配</strong></p>
<p>当定义函数模板的特例化版本时，本质上接管了编译器的工作，为原模板的一个特殊实例提供定义；<strong>一个特例化版本本质上是一个实例，而非函数名的一个重载版本，因此特例化不影响函数匹配</strong></p>
<p>将一个特殊的函数定义为一个<strong>特例化版本</strong>还是一个<strong>独立的非模板函数</strong>，会影响到匹配；如果都同时匹配时，会匹配非模板函数；而如果没有定义非模板函数，则优先匹配特例化版本</p>
<p><strong>为了特例化一个模板，原模板的声明必须在作用域中，而且在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中</strong></p>
<blockquote>
<p><strong>Tips</strong>：模板及其特例化版本应该声明在同一个头文件中，所有同名模板的声明应该放在前面，然后是这些模板的特例化版本</p>
</blockquote>
<h4 id="16-5-2、类模板特例化">16.5.2、类模板特例化</h4>
<h5 id="16-5-2-1、全特化">16.5.2.1、全特化</h5>
<p>全特化一个类模板时，使用关键字<code>template</code>后跟一个<strong>空括号对</strong><code>&lt;&gt;</code>，<strong>类模板名后跟<code>&lt;&gt;</code>以及指出所有特例化的参数类型</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span>};</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span><span class="keyword">int</span>, <span class="keyword">int</span>&gt; {}; <span class="comment">// 全特化</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>模板特例化必须定义在<code>原始模板</code>所属的命名空间中</strong>，只要在命名空间中声明了特例化，就可以在命名空间外部定义它</p>
<h5 id="16-5-2-2、偏特化">16.5.2.2、偏特化</h5>
<p>与函数模板不同，类模板的特例化不必为所有模板参数提供实参；可以指定一部分而非所有模板参数，或是参数的一部分而非全部特性</p>
<p><strong>一个类模板的部分特例化本身是一个模板</strong>，与往常一样，首先<strong>定义模板参数</strong>，部分特例化版本的<strong>名字与原模板名字相同</strong>，对每个<strong>未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应</strong>，在<strong>类名之后，为要特例化的模板参数指定实参</strong>，这些实参<strong>列于模板名之后的括号中</strong>，这些实参<strong>与原始模板中的参数按位置对应</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> {</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;</span><span class="keyword">int</span>, U&gt; {}; <span class="comment">// 偏特化</span></span><br></pre></td></tr></tbody></table></figure>
<p>部分特例化版本的模板参数列表是原始模板的参数列表的<strong>一个子集</strong>或者<strong>一个特例化版本</strong></p>
<p>可以<strong>只特例化特定成员函数而不是特例化整个模板</strong></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> {</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">const</span> T &amp;t = <span class="built_in">T</span>()): <span class="built_in">mem</span>(t) { }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>{ <span class="comment">/* ... */</span> }</span><br><span class="line">    T mem;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="comment">// 只特例化成员函数</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::<span class="built_in">Bar</span>() <span class="comment">// 用int之外的类型时，成员像往常一样进行实例化</span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>说明</strong>：</p>
<ul>
<li><strong>模板程序应该尽量减少对实参类型的要求</strong>，比如只使用<code>&lt;</code>而不是<code>&gt;, &lt;</code>，因为有的类型并没有重载<code>&gt;</code></li>
<li>当编译器遇到一个模板定义时，它并不生成代码；只有实例化出模板的一个特定版本时，编译器才会生成代码</li>
<li><strong>函数模板和类模板的成员函数的定义通常放在头文件中</strong></li>
</ul>
</blockquote>
<h2 id="20、编程技巧">20、编程技巧</h2>
<h3 id="1、编写自己的头文件">1、编写自己的头文件</h3>
<p>头文件通常包含那些<strong>只能被定义一次</strong>的<strong>实体</strong>，如类、const和constexpr变量等。类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字一样，如<code>string.h</code>中包含类<code>string</code>。</p>
<p>变量、函数应<strong>在头文件中进行声明</strong>，<strong>在源文件中进行定义</strong>，同时源文件中需包含头文件；<strong>如果函数在概念上属于类但是不定义在类中，则它一般应与类声明(而非定义)在同一个头文件内</strong><!--P234--></p>
<p><strong>预处理器</strong>(编译之前执行的一段程序)能确保头文件多次包含仍能安全工作，预处理变量有两种状态：<strong>已定义和未定义</strong></p>
<p><code>#define</code>指令把一个名字设定为<strong>预处理变量</strong>，<code>#ifdef</code>和<code>ifndef</code>来分别处理<strong>预处理变量</strong>在<strong>已定义和未定义</strong>时的相关操作，最终以<code>#endif</code>结束。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> {</span></span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>头文件保护符</strong>(上面例子中的<code>SALES_DATA_H</code>)必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，一般把预处理变量的名字<strong>全部大写</strong>来作为头文件保护符</p>
<blockquote>
<p><strong>Tips</strong>：只要是头文件，就应该设置保护符</p>
</blockquote>
<h2 id="遗留问题">遗留问题</h2>
<h3 id="1、priority-queue等容器和sort算法中比较函数的用法">1、priority_queue等容器和sort算法中比较函数的用法</h3>
<h4 id="1-1、容器中-内是比较函数的类型，-内可以是decltype-lambda（lambda需要通过过decltype得到lambda的类型，同时容器对象中需要相对应的实参，因为lambda构成的类没有默认构造函数，是不能调用容器的默认构造函数，只能调用-x-参数的构造函数）-函数名（和lambda的情况一样，但需要加上-）-或者是函数对象的类名-这个类是有默认构造函数的，类名就是类型，容器对象不需要传实参">1.1、容器中<code>&lt;&gt;</code>内是比较函数的类型，<code>&lt;&gt;</code>内可以是<code>decltype(lambda（lambda需要通过过decltype得到lambda的类型，同时容器对象中需要相对应的实参，因为lambda构成的类没有默认构造函数，是不能调用容器的默认构造函数，只能调用(_x)参数的构造函数）, 函数名（和lambda的情况一样，但需要加上*）)或者是函数对象的类名(这个类是有默认构造函数的，类名就是类型，容器对象不需要传实参)</code></h4>
<h3 id="1-2、算法中的比较函数和容器中的不一样，算法中不需要是类型，只要是实参就可以，所以可以直接传入lambda作为实参，在模板部分了解了解">1.2、算法中的比较函数和容器中的不一样，算法中不需要是类型，只要是实参就可以，所以可以直接传入lambda作为实参，在模板部分了解了解</h3>
<p>哪些是在编译期进行的，哪些是在运行期进行的，全局变量、static变量、const等都是在什么时候确定的</p>
<p>P589声明问题，友元类的声明，哪些需要，哪些不需要</p>
]]></content>
      <categories>
        <category>笔记 - 专业笔记 - 基础知识 - 语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>算法刷题笔记</title>
    <url>/post/23889.html</url>
    <content><![CDATA[<h2 id="数组">数组</h2>
<h3 id="1、数组的理论要点">1、数组的理论要点</h3>
<ul>
<li><strong>数组的元素是不能删除的，只能覆盖。</strong></li>
</ul>
<h3 id="2、重点题型">2、重点题型</h3>
<h4 id="2-1、二分查找">2.1、二分查找</h4>
<h5 id="2-1-1、普通二分">2.1.1、普通二分</h5>
<ul>
<li>
<p><strong>适用条件</strong>：区间内元素是<strong>单调的、无重复的</strong></p>
</li>
<li>
<p><strong>算法要点</strong>：注意<strong>区间的循环不变量</strong></p>
<ul>
<li><strong><code>[left, right]</code></strong>：循环判断条件对应<code>(left &lt;= right)</code>，因为对于闭区间来说，<code>left</code>可能和<code>right</code>相等，同时对应的<code>right</code>值的更新应为<code>right = mid - 1</code>。</li>
<li><strong><code>[left, right)</code></strong>：循环判断条件对应<code>(left &lt; right)</code>，因为对于左闭右开区间来说，<code>left</code>不可能和<code>right</code>相等，同时对应的<code>right</code>值的更新应为<code>right = mid</code>。</li>
</ul>
</li>
<li>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//[left, right]</span></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) {</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">//可以避免left + right造成整形溢出</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//[left, right)</span></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) {</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">//可以避免left + right造成整形溢出</span></span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt; target) right = mid;</span><br><span class="line">    <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h6 id="LC704-二分查找"><strong><a href="https://leetcode-cn.com/problems/binary-search/">LC704. 二分查找</a></strong></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//// [left, right]</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) {</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="LC35-搜索插入位置"><strong><a href="https://leetcode-cn.com/problems/search-insert-position/">LC35. 搜索插入位置</a></strong></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) {</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 此时 left &gt; right</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之前 </span></span><br><span class="line">        <span class="comment">// 目标值插入数组中的位置</span></span><br><span class="line">        <span class="comment">// 目标值在数组所有元素之后的情况</span></span><br><span class="line">        <span class="comment">// 都可以返回 l</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="LC367-有效的完全平方数"><a href="https://leetcode-cn.com/problems/valid-perfect-square/">LC367.有效的完全平方数</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = num;</span><br><span class="line">        <span class="comment">// [left, right]</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) {</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid == num) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)mid * mid &lt; num) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="HZOJ386-吃瓜群众"><a href="http://oj.haizeix.com/problem/386">HZOJ386.吃瓜群众</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序之后，位置就变了，需要使用cnt记住位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> amount;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M, N, l, r;</span><br><span class="line">node num[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">    l = <span class="number">0</span>, r = M - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[mid].amount == x) <span class="keyword">return</span> num[mid].cnt;</span><br><span class="line">        <span class="keyword">if</span> (num[mid].amount &gt; x) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a.amount &lt; b.amount;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) {</span><br><span class="line">        cin &gt;&gt; num[i].amount;</span><br><span class="line">        num[i].cnt = i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(num, num + M, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">bs</span>(temp) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="2-1-2、特殊二分">2.1.2、特殊二分</h5>
<ul>
<li>
<p><strong>适用条件</strong>：区间内元素是单调的，题中要求的是满足条件的第一个或最后一个元素的位置</p>
</li>
<li>
<p><strong>算法要点</strong>：</p>
<ul>
<li>根据题意确定是<code>11110000</code>还是<code>00001111</code>类型</li>
</ul>
</li>
<li>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 00001111型：选取最左边的1</span></span><br><span class="line"><span class="keyword">while</span> (l != r) {</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//上取整：尽量多的满足1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &lt;= target) r = mid;  <span class="comment">//为1的情况</span></span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>; <span class="comment">//为0的情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11110000型：选取最右边的1</span></span><br><span class="line"><span class="keyword">while</span> (l != r) {</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//下取整：尽量多的满足1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &gt;= target) l = mid; <span class="comment">//为1的情况</span></span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>; <span class="comment">//为0的情况</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h6 id="LC69-Sqrt-x"><strong><a href="https://leetcode-cn.com/problems/sqrtx/">LC69. Sqrt(x)</a></strong></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">        <span class="comment">// 类型：11110000</span></span><br><span class="line">        <span class="keyword">while</span> (l != r) {</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid * mid &lt;= x) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="HZOJ387-吃瓜群众升级版"><a href="http://oj.haizeix.com/problem/387">HZOJ387.吃瓜群众升级版</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 类型：00001111</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序之后，位置就变了，需要使用cnt记住位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> amount;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> M, N, l, r;</span><br><span class="line">node num[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">long</span> x)</span> </span>{</span><br><span class="line">    l = <span class="number">0</span>, r = M - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[mid].amount &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> num[l].amount &gt;= x ? num[l].cnt : <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a.amount &lt; b.amount;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">//cin &gt;&gt; M &gt;&gt; N;</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;M, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) {</span><br><span class="line">        <span class="comment">//cin &gt;&gt; num[i].amount;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;num[i].amount);</span><br><span class="line">        num[i].cnt = i + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(num, num + M, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; temp;</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;temp);</span><br><span class="line">        <span class="comment">//cout &lt;&lt; bs(temp) &lt;&lt; endl;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">bs</span>(temp));</span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="LC34-在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LC34.在排序数组中查找元素的第一个和最后一个位置</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;{<span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用特殊二分确定目标值的起始位置</span></span><br><span class="line">        <span class="comment">//类型：00001111</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l != r) {</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;{<span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从起始位置遍历到结束的位置</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; nums.<span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">if</span> (nums[r] != target) <span class="keyword">break</span>;</span><br><span class="line">            r += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;{l, r - <span class="number">1</span>};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="2-1-3、二分答案">2.1.3、二分答案</h5>
<ul>
<li>
<p><strong>适用条件</strong>：答案满足单调性，题中要求的是<strong>最大的最小或者最小的最大</strong></p>
</li>
<li>
<p><strong>算法要点</strong>：确认以下4点</p>
<ul>
<li><strong>分谁</strong>：分的是题目中要求得是谁</li>
<li><strong>求谁</strong>：由<strong>分谁</strong>可以直接唯一确定的值就是<strong>求谁</strong>，<strong>求谁</strong>就是答案，答案需要是单调的</li>
<li><strong>确认左右边界，更新动态指针</strong></li>
<li><strong>确定是二分的哪种特殊情况</strong>：11110000  或  00001111</li>
</ul>
</li>
<li>
<p><strong>算法模板</strong>：</p>
<ul>
<li>套用特殊二分的算法模板</li>
</ul>
</li>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h6 id="HZOJ389-暴躁的程序猿"><a href="http://oj.haizeix.com/problem/389">HZOJ389. 暴躁的程序猿</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 分谁：题中求距离，按照距离分</span></span><br><span class="line"><span class="comment">// 求谁：距离的不同会导致能够安排的员工数量不一样，答案就是员工数量</span></span><br><span class="line"><span class="comment">// 距离：1  2  3  4  5  6</span></span><br><span class="line"><span class="comment">// 数量：3  3  3  2  2  2</span></span><br><span class="line"><span class="comment">// 类型：1  1  1  0  0  0</span></span><br><span class="line"><span class="comment">// 左边界：距离最小为1 ==&gt;&gt; l = 1</span></span><br><span class="line"><span class="comment">// 右边界：距离最大为两端之间的距离 ==&gt;&gt; r = num[m - 1] - num[0]</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, num[<span class="number">100005</span>], l, r;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分答案最难的部分：答案的计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>, last = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">if</span> (last + mid &lt;= num[i]) {</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            last = num[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; num[i];</span><br><span class="line">    <span class="built_in">sort</span>(num, num + m);</span><br><span class="line">    l = <span class="number">1</span>, r = num[m - <span class="number">1</span>] - num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (l != r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &gt;= n) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    } </span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="HZOJ390-原木切割"><a href="http://oj.haizeix.com/problem/390">HZOJ390.原木切割</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 分谁：题目中要求的是每一小段原木的最大长度，按照每一小段长度不同进行分，分谁指的是段长</span></span><br><span class="line"><span class="comment">// 求谁：小段原木的长度不同，切成的总数量就不一样，求谁指的是数量</span></span><br><span class="line"><span class="comment">// 段长：1   2   3   4  5  6  7  8</span></span><br><span class="line"><span class="comment">// 数量：43  21  14  9  8  6  5  3</span></span><br><span class="line"><span class="comment">// 类型：1   1   1   1  1  0  0  0</span></span><br><span class="line"><span class="comment">// 左边界：段长最小为1 ==&gt;&gt; l = 1</span></span><br><span class="line"><span class="comment">// 右边界：段长最大为最长原木的长度 ==&gt;&gt; r = max(r, num[i])</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num[<span class="number">100005</span>], l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//答案的计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans += num[i] / mid;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">     	cin &gt;&gt; num[i];</span><br><span class="line">        r = <span class="built_in">max</span>(r, num[i]);  <span class="comment">//分谁：段长，段长最大值只能是原木中最长的</span></span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">while</span> (l != r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &gt;= m) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    }   </span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="HZOJ391-数列分段"><a href="http://oj.haizeix.com/problem/391">HZOJ391. 数列分段</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 分谁：求的是每段和的最大值，按照每段和最大值进行划分</span></span><br><span class="line"><span class="comment">// 求谁：每段和的最大值不同，影响分的段数，答案是段数</span></span><br><span class="line"><span class="comment">// 最值： 5  6  7  8  9  10  11</span></span><br><span class="line"><span class="comment">// 段数： 5  3  3  3  3  2   2</span></span><br><span class="line"><span class="comment">// 类型： 0  1  1  1  1  1   1   //可以根据题目反推类型，最大的最小就是00001111型</span></span><br><span class="line"><span class="comment">// 左边界：数组中的最大值 ==&gt;&gt; l = max(l, num[i])</span></span><br><span class="line"><span class="comment">// 右边界：数组所有元素的和 ==&gt;&gt; r += num[i]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">100005</span>], l, r;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最难的部分：答案的计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> mid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (now + num[i] &gt; mid) {</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">            now = num[i];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (now + num[i] == mid) {</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">            now = <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            now += num[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (now) cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">        l = <span class="built_in">max</span>(l, num[i]);</span><br><span class="line">        r += num[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (l != r) {</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &lt;= m) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="HZOJ392-丢瓶盖"><a href="http://oj.haizeix.com/problem/392">HZOJ392. 丢瓶盖</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 分谁：求的是距离，按照距离划分</span></span><br><span class="line"><span class="comment">// 求谁：距离影响的是需要找出的瓶盖数，答案是瓶盖数量</span></span><br><span class="line"><span class="comment">// 距离： 1  2  3  4  5  6  7</span></span><br><span class="line"><span class="comment">// 数量： 5  3  2  2  1  1  1</span></span><br><span class="line"><span class="comment">// 类型： 1  1  0  0  0  0  0</span></span><br><span class="line"><span class="comment">// 左边界：距离的最小值为1 ==&gt;&gt; l = 1</span></span><br><span class="line"><span class="comment">// 右边界：距离的最大值为两端之差 ==&gt;&gt; num[A - 1] - num[0] + 1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A, B;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> num[<span class="number">100005</span>], l = <span class="number">1</span>, r;</span><br><span class="line"><span class="comment">//答案的计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> mid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> last = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A; i++) {</span><br><span class="line">        <span class="keyword">if</span> (last &lt;= num[i] - mid) {</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">            last = num[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; A &gt;&gt;  B;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A; i++) </span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">    <span class="built_in">sort</span>(num, num + A);</span><br><span class="line">    r = num[A - <span class="number">1</span>] - num[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != r) {</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &gt;= B) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="HZOJ393-切绳子"><a href="http://oj.haizeix.com/problem/393">HZOJ393.切绳子</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 分谁：求的是每段绳子的最长长度，按照绳子的长度划分</span></span><br><span class="line"><span class="comment">// 求谁：绳子长度影响切出来的数量，答案是数量</span></span><br><span class="line"><span class="comment">// 长度：  1  2  3  4  5  6</span></span><br><span class="line"><span class="comment">// 数量：  28 13 7  6  3  2</span></span><br><span class="line"><span class="comment">// 类型：  1  1  0  0  0  0</span></span><br><span class="line"><span class="comment">// 左边界：0.0即可</span></span><br><span class="line"><span class="comment">// 右边界：最大绳子的长度 ==&gt;&gt; r = max(r, num[i])</span></span><br><span class="line"><span class="comment">// 特别：对于浮点数的二分，在求mid时是不区分上取整和下取整的，并且l,r是不需要考虑+/-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">double</span> num[<span class="number">100005</span>], l, r;</span><br><span class="line"><span class="comment">//答案的计算方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> mid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        cnt += (<span class="keyword">int</span>)(num[i] / mid);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">        r = <span class="built_in">max</span>(r, num[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">0.00001</span>) {</span><br><span class="line">        <span class="keyword">double</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &gt;= k) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, l - <span class="number">0.005</span>); <span class="comment">//printf可以设置格式的输出，-0.005再加上四舍五入即可满足题目要求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="HZOJ394-跳石头"><a href="http://oj.haizeix.com/problem/394">HZOJ394.跳石头</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 分谁：求的是最短跳跃距离，按照最短跳跃距离划分</span></span><br><span class="line"><span class="comment">// 求谁：最短跳跃距离影响的是移走石头的数量，答案是移走石头的数量</span></span><br><span class="line"><span class="comment">// 距离：0  1  2  3  4  5  6  7  8  9</span></span><br><span class="line"><span class="comment">// 数量：0  0  0  1  2  3  3  4  4  4</span></span><br><span class="line"><span class="comment">// 类型：1  1  1  1  1  0  0  0  0  0  </span></span><br><span class="line"><span class="comment">// 左边界：跳跃的最短距离可以为0 ==&gt;&gt; l = 0</span></span><br><span class="line"><span class="comment">// 右边界：跳跃距离的最大值不能超过终点到起点的距离 ==&gt;&gt; r = L</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> L, num[<span class="number">50005</span>], l, r;</span><br><span class="line"><span class="keyword">int</span> M, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> mid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= M; i++) {</span><br><span class="line">    	<span class="keyword">if</span> (last + mid &gt; num[i]) {</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            last = num[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cnt;    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; L &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) cin &gt;&gt; num[i];</span><br><span class="line">    num[M] = L;</span><br><span class="line">    r = L;</span><br><span class="line">    <span class="keyword">while</span> (l != r) {</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &lt;= N) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h6 id="HZOJ395-复制书稿"><a href="http://oj.haizeix.com/problem/395">HZOJ395.复制书稿</a></h6>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 分谁：求的是复制时间，按照复制时间进行划分</span></span><br><span class="line"><span class="comment">// 求谁：复制时间影响的抄写的人数，答案是人数</span></span><br><span class="line"><span class="comment">// 时间：12  13  14  15  16  17  18  19 </span></span><br><span class="line"><span class="comment">// 人数：5   5   5   4   4   3   3   3</span></span><br><span class="line"><span class="comment">// 类型：0   0   0   0   0   1   1   1  </span></span><br><span class="line"><span class="comment">// 左边界：复制时间的最小值就是一人负责一本，最后的那一本需要的时间 ==&gt;&gt; l = max(l, num[i])</span></span><br><span class="line"><span class="comment">// 右边界：复制时间的最大值就是一个人复制所有 ==&gt;&gt; r += num[i]</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> m, k, num[<span class="number">505</span>], res[<span class="number">505</span>][<span class="number">2</span>], l, r;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, now = num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">if</span> (now + num[i] &lt; mid) {</span><br><span class="line">            now += num[i];</span><br><span class="line">           } <span class="keyword">else</span> <span class="keyword">if</span> (now + num[i] == mid) {</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">            now = <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            now = num[i];</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (now) cnt += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">}</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">        r += num[i];</span><br><span class="line">        l = <span class="built_in">max</span>(l, num[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l != r) {</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &lt;= k) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//题中要求尽量让后面的人多抄，需要从后往前遍历</span></span><br><span class="line">    <span class="keyword">int</span> j = k, now = num[m - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (now + num[i] &gt; l) {</span><br><span class="line">            res[j][<span class="number">0</span>] = i + <span class="number">2</span>; <span class="comment">// i + 1 + 1</span></span><br><span class="line">            j--; <span class="comment">// 去掉一个人</span></span><br><span class="line">            now = num[i]; </span><br><span class="line">            res[j][<span class="number">1</span>] = i + <span class="number">1</span>; <span class="comment">// 下一个人的终止位置</span></span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (now + num[i] == l) {</span><br><span class="line">            res[j][<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">            j--;</span><br><span class="line">            i--; <span class="comment">//这本书已经被抄过了，要到下一本书了</span></span><br><span class="line">            now = num[i];</span><br><span class="line">            res[j][<span class="number">1</span>] = i + <span class="number">1</span>; <span class="comment">// 下一个人的终止位置</span></span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            now += num[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    res[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//第一个人抄的起始位置</span></span><br><span class="line">    res[k][<span class="number">1</span>] = m; <span class="comment">//最后一个人抄的终止位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) cout &lt;&lt; res[i][<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; res[i][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h6 id="LC278-第一个错误的版本"><a href="https://leetcode-cn.com/problems/first-bad-version/">LC278. 第一个错误的版本</a></h6>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);  </span></span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">   </span><br><span class="line">        <span class="comment">// 分析：</span></span><br><span class="line">        <span class="comment">// 检测最先坏的版本，属于00001111型</span></span><br><span class="line">   </span><br><span class="line">        <span class="keyword">while</span> ( l != r) {</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//向上取整</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="2-1-4、二分查找总结">2.1.4、二分查找总结</h5>
<ul>
<li>
<h6 id="二分的本质"><strong>二分的本质</strong></h6>
<p><strong>删掉不存在答案的区间</strong></p>
</li>
<li>
<h6 id="整数范围"><strong>整数范围</strong></h6>
<ol>
<li><strong>普通二分</strong>：
<ul>
<li>注意<code>区间的循环不变量</code>，确定<code>循环条件</code>，最好选择一种，长期坚持使用，本人习惯使用<code>[left, right]</code></li>
<li>中间值的计算方法，采用<code>int mid = l + (r - l) / 2</code>方式，避免整形溢出</li>
<li>对于<code>r = mid - 1</code>还是<code>l = mid + 1</code>要考虑清楚，还是在特殊情况下会发生变化</li>
</ul>
</li>
<li><strong>特殊二分</strong>：
<ul>
<li>根据题意确定是<code>00001111</code>还是<code>11110000</code>类型</li>
<li>根据类型套用模板</li>
<li>类型模板：注意区分是<code>下取整</code>还是<code>上取整</code>，是<code>r = mid; l = mid + 1;</code>还是<code>l = mid; r = mid - 1;</code><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 00001111型：选取最左边的1</span></span><br><span class="line"><span class="keyword">while</span> (l != r) {</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>; <span class="comment">//上取整：尽量多的满足1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &lt;= target) r = mid;  <span class="comment">//为1的情况</span></span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>; <span class="comment">//为0的情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11110000型：选取最右边的1</span></span><br><span class="line"><span class="keyword">while</span> (l != r) {</span><br><span class="line">    <span class="keyword">int</span> mid = l + (r - l + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//下取整：尽量多的满足1的情况</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">func</span>(mid) &gt;= target) l = mid; <span class="comment">//为1的情况</span></span><br><span class="line">	<span class="keyword">else</span> r = mid - <span class="number">1</span>; <span class="comment">//为0的情况</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><strong>二分答案</strong>：
<ul>
<li>根据题意按照如下顺序进行分析：
<ol>
<li>分谁：</li>
<li>求谁：</li>
<li>“分谁”：在分谁中确定的量</li>
<li>“求谁”：在求谁中确定的量</li>
<li>类型：  根据提议正推类型，或者根据题目中要求的反向推类型：最大的最小是<code>11110000</code>型，最小的最大是<code>00001111</code>型</li>
<li>左边界：</li>
<li>右边界：</li>
</ol>
</li>
<li>根据类型套用特殊二分的类型模板</li>
</ul>
</li>
</ol>
</li>
<li>
<h6 id="浮点数范围"><strong>浮点数范围</strong></h6>
<ol>
<li><strong>普通二分</strong>：
<ul>
<li>循环条件使用<code>精度</code>来控制</li>
<li>中间值的计算方法：<code>double mid = l + (r - l) / 2;</code></li>
<li>对于<code>r, l</code>的变更全部采用<code>r = mid, l = mid</code></li>
</ul>
</li>
<li><strong>特殊二分</strong>：
<ul>
<li>循环条件使用<code>精度</code>来控制</li>
<li>中间值的计算不存在上取整和下取整之说，统一使用<code>double mid = l + (r - l) / 2;</code></li>
<li>对于<code>r, l</code>的变更全部采用<code>r = mid, l = mid</code></li>
</ul>
</li>
<li><strong>二分答案</strong>：(与整数不同的地方)
<ul>
<li>循环条件使用<code>精度</code>控制</li>
<li>中间值的计算不存在上取整和下取整之说，统一使用<code>double mid = l + (r - l) / 2;</code></li>
<li>对于<code>r, l</code>的变更全部采用<code>r = mid, l = mid</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：二分查找的使用条件：单调，有时需要对给的数据进行<code>sort</code>操作</p>
</blockquote>
<h5 id="2-1-5、牛顿迭代法">2.1.5、牛顿迭代法</h5>
<ul>
<li>
<p><strong>适用情景</strong>：求高阶方程根的问题</p>
</li>
<li>
<p><strong>递推公式</strong>：</p>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211121203040691.png" alt="image-20211121203040691" style="zoom:80%;">
</li>
<li>
<p><strong>函数模板</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">newton</span><span class="params">(type (*F)(type, ...), type (*f)(type, ...), type x, ...)</span></span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     F：原函数  </span></span><br><span class="line"><span class="comment">     f：原函数的导函数  </span></span><br><span class="line"><span class="comment">     x, ...`：原函数中的系数  </span></span><br><span class="line"><span class="comment">     高阶方程根的求解判断依据：`使用精度判断迭代次数`，要使用`fabs(F(x,n))`来判断精度  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>相关样例</strong>：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x * x - n;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">newton</span><span class="params">(<span class="keyword">double</span> (*F)(<span class="keyword">double</span>, <span class="keyword">double</span>), <span class="keyword">double</span> (*f)(<span class="keyword">double</span>), <span class="keyword">double</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">double</span> x = n / <span class="number">2.0</span>;  <span class="comment">//随便取，但不能取0</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> EPLS 1e-7</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fabs</span>(<span class="built_in">F</span>(x, n)) &gt; EPLS) {   </span><br><span class="line">        x -= <span class="built_in">F</span>(x, n) / <span class="built_in">f</span>(x);   <span class="comment">//循环迭代</span></span><br><span class="line">    }</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> EPLS</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="2-2、移除元素">2.2、移除元素</h4>
<ul>
<li>
<p><strong>解题思路</strong>：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖来移除元素。</p>
</li>
<li>
<p><strong>解题方法</strong>：</p>
<ul>
<li>双指针法：<strong>快指针按照正常速度遍历数组，慢指针只有满足条件时再移动，慢指针控制新数组的长度</strong></li>
</ul>
</li>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h5 id="LC27-移除元素"><a href="https://leetcode-cn.com/problems/remove-element/">LC27.移除元素</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; fast &lt; nums.<span class="built_in">size</span>(); fast++) { <span class="comment">//fast正常速度遍历数组</span></span><br><span class="line">            <span class="keyword">if</span> (nums[fast] == val) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//满足条件时，更新slow位置上的值，再更新slow的位置</span></span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;  <span class="comment">//此时slow的位置为最后一个元素的下标+1，也就是数组的长度值</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC26-删除有序数组中的重复项"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">LC26.删除有序数组中的重复项</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分析：本题和27题的区别是val没有只要，需要一直更新</span></span><br><span class="line">        <span class="comment">// val更新的位置：val应为slow标记的新数组的元素，需要在新数组元素更新后更新val</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>, val = INT_MAX; <span class="comment">//val = INT_MAX 保证第一个元素不被覆盖</span></span><br><span class="line">        <span class="keyword">for</span> ( ; fast &lt; nums.<span class="built_in">size</span>(); fast++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] == val) <span class="keyword">continue</span>;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            val = nums[slow]; <span class="comment">//新数组元素更新后更新val</span></span><br><span class="line">            slow += <span class="number">1</span>;     </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC283-移动零"><a href="https://leetcode-cn.com/problems/move-zeroes/">LC283.移动零</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( ; fast &lt; nums.<span class="built_in">size</span>(); fast++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = slow; i &lt; nums.<span class="built_in">size</span>(); i++) nums[i] = <span class="number">0</span>; <span class="comment">//后面补零</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC844-比较含退格的字符串"><a href="https://leetcode-cn.com/problems/backspace-string-compare/">LC844.比较含退格的字符串</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// 解法：用S_skip, T_skip来记录s, t串最后位置的#个数，每次循环先处理回退，再比较对应</span></span><br><span class="line">        <span class="comment">//      位置是否相同</span></span><br><span class="line">           </span><br><span class="line">        <span class="keyword">int</span> S_skip = <span class="number">0</span>, T_skip = <span class="number">0</span>, l = s.<span class="built_in">size</span>() - <span class="number">1</span>, r = t.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (s[l] == <span class="string">'#'</span>) S_skip += <span class="number">1</span>; <span class="comment">// 如果是#，记下个数</span></span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (S_skip) S_skip -= <span class="number">1</span>; <span class="comment">//处理回退</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                l -= <span class="number">1</span>; <span class="comment">// 勿忘</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span> (r &gt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (t[r] == <span class="string">'#'</span>) T_skip += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    <span class="keyword">if</span> (T_skip) T_skip -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (l &lt; <span class="number">0</span> || r &lt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//比较</span></span><br><span class="line">            <span class="keyword">if</span> (s[l] != t[r]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            l -= <span class="number">1</span>, r -= <span class="number">1</span>; <span class="comment">//勿忘</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">-1</span> &amp;&amp; r == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC977-有序数组的平方"><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">LC977.有序数组的平方</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ind = nums.<span class="built_in">size</span>() - <span class="number">1</span>; ind &gt;= <span class="number">0</span>; ind--) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(nums[slow]) &gt; <span class="built_in">abs</span>(nums[fast])) {</span><br><span class="line">                res[ind] = nums[slow] * nums[slow];</span><br><span class="line">                slow += <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                res[ind] = nums[fast] * nums[fast];</span><br><span class="line">                fast -= <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h5 id="移除元素总结"><strong>移除元素总结</strong></h5>
<ol>
<li>解题方法：双指针</li>
<li>方法思想：(特别是对<strong>数组元素按条件覆盖移除问题</strong>，像LC26、27、283题型)
<ul>
<li>快指针正常遍历数组</li>
<li>慢指针满足条件时在更新，同时用快指针指向的值进行覆盖</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="2-3、滑动窗口法">2.3、滑动窗口法</h4>
<ul>
<li>
<p><strong>算法概念</strong>：不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</p>
</li>
<li>
<p><strong>算法要点</strong>：确定如下3点</p>
<ol>
<li>窗口内是什么</li>
<li>如何移动窗口的起始位置：关键之处</li>
<li>如何移动窗口的结束位置</li>
</ol>
</li>
<li>
<p><strong>算法优点</strong>：根据当前子序列和大小的情况，不断调节子序列的起始位置，从而降低时间复杂度</p>
</li>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h5 id="LC3-无重复字符的最长子串">[LC3.无重复字符的最长子串</h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 滑动窗口法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; uset;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); r++) {</span><br><span class="line">            <span class="keyword">while</span> (uset.<span class="built_in">find</span>(s[r]) != uset.<span class="built_in">end</span>() &amp;&amp; l &lt; r) {</span><br><span class="line">                uset.<span class="built_in">erase</span>(s[l]);</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            uset.<span class="built_in">insert</span>(s[r]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 二分答案</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(string &amp;s, <span class="keyword">int</span> len)</span> </span>{  <span class="comment">// 验证s是否存在最长无重复的字符串长度为len</span></span><br><span class="line">    <span class="keyword">char</span> cnt[<span class="number">128</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) {</span><br><span class="line">            cnt[s[i]] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt[s[i]] == <span class="number">1</span>) k++;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len) {</span><br><span class="line">                cnt[s[i - len]] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[s[i - len]] == <span class="number">0</span>) k -= <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (k == len) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) {</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">func</span>(s, mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC209-长度最小的子数组"><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">LC209.长度最小的子数组</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 窗口内是什么：满足和&gt;= target的长度最小的连续子数组</span></span><br><span class="line">    <span class="comment">// 起始位置移动：如果当前窗口值大于target时，窗口向前移动</span></span><br><span class="line"><span class="comment">// 结束位置移动：遍历整个数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//用来限制窗口的大小</span></span><br><span class="line">            <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//窗口的起始位置</span></span><br><span class="line">            <span class="keyword">int</span> subLength = <span class="number">0</span>; <span class="comment">//记录窗口的长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                sum += nums[j]; <span class="comment">//先扩大窗口，使其满足条件</span></span><br><span class="line">                <span class="keyword">while</span> (sum &gt;= target) { <span class="comment">//此处调整窗口的起始位置，需要使用while，求的是最小子数组</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>;</span><br><span class="line">                    res = <span class="built_in">min</span>(subLength, res); <span class="comment">//更新答案</span></span><br><span class="line">                    sum -= nums[i]; <span class="comment">//</span></span><br><span class="line">                    i += <span class="number">1</span>; <span class="comment">//更新窗口起始位置</span></span><br><span class="line">                } </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">        }</span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC904-水果成篮"><a href="https://leetcode-cn.com/problems/fruit-into-baskets/">LC904.水果成篮</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 分析：</span></span><br><span class="line"><span class="comment">// 窗口内是什么：满足只有两种果子的连续子数组</span></span><br><span class="line"><span class="comment">// 起始位置移动：如果当前窗口内超过两种果子时，窗口向前移动</span></span><br><span class="line"><span class="comment">// 结束位置移动：遍历整个数组</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fruits)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap; <span class="comment">//记录果子种类</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; fruits.<span class="built_in">size</span>(); j++) {</span><br><span class="line">            umap[fruits[j]] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (umap.<span class="built_in">size</span>() &gt; <span class="number">2</span>) {<span class="comment">//窗口起始位置的移动处理</span></span><br><span class="line">                umap[fruits[i]] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (umap[fruits[i]] == <span class="number">0</span>) umap.<span class="built_in">erase</span>(fruits[i]); <span class="comment">//只有这种果子全清才可以</span></span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC76-最小覆盖子串"><a href="https://leetcode-cn.com/problems/minimum-window-substring/">LC76.最小覆盖子串</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; umap, ucnt; <span class="comment">//umap记录子串的情况，ucnt记录窗口情况</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;[ch, cnt] : umap) </span><br><span class="line">            <span class="keyword">if</span> (ucnt[ch] &lt; cnt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> lans = <span class="number">-1</span>, rans = <span class="number">-1</span>;  <span class="comment">//由于要返回的是子串，用lans和rans记录子串的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : t) umap[i] += <span class="number">1</span>;<span class="comment">//记录子串的字母情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) { <span class="comment">//进行滑动窗口的操作</span></span><br><span class="line">            <span class="keyword">if</span> (umap.<span class="built_in">find</span>(s[i]) != umap.<span class="built_in">end</span>()) ucnt[s[i]] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">check</span>()) { <span class="comment">//检查是不是包含子串</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; i - l + <span class="number">1</span>) { </span><br><span class="line">                    lans = l; <span class="comment">//标记新的结果子串的位置</span></span><br><span class="line">                    rans = i;</span><br><span class="line">                    len = i - l + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (umap.<span class="built_in">find</span>(s[l]) != umap.<span class="built_in">end</span>()) </span><br><span class="line">                    ucnt[s[l]] -= <span class="number">1</span>;  </span><br><span class="line">                l++; <span class="comment">//移动滑动窗口的起始位置</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lans == <span class="number">-1</span> ? <span class="string">""</span> : s.<span class="built_in">substr</span>(lans, len);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h5 id="滑动窗口总结"><strong>滑动窗口总结</strong></h5>
<ol>
<li>
<p>分析要点：</p>
<ul>
<li>窗口内是什么</li>
<li>窗口的起始位置何时移动</li>
<li>窗口的终止位置何时移动</li>
</ul>
</li>
<li>
<p>算法模板：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//窗口的起始位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) { <span class="comment">//遍历整个数组</span></span><br><span class="line">    <span class="comment">/* 窗口终止位置后移后，对窗口内新增加元素的处理 */</span></span><br><span class="line">    <span class="keyword">while</span> (...) {	<span class="comment">// 窗口内需要满足的条件,循环体中更新窗口的位置,一定要用while</span></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	更新相应的值</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        i += <span class="number">1</span>; <span class="comment">//窗口的起始位置后移</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    其他操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<blockquote>
<p><strong>注</strong>：移动窗口时，一定要使用<code>while</code></p>
</blockquote>
</li>
</ul>
<h4 id="2-4、螺旋矩阵">2.4、螺旋矩阵</h4>
<ul>
<li>
<p><strong>解题要点</strong>：区间的循环不变量，本人采用[left, right)</p>
</li>
<li>
<p><strong>解题思路</strong>：模拟顺时针画矩阵的过程</p>
<ol>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ol>
</li>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h5 id="LC59-螺旋矩阵-II-star-star-star"><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">LC59.螺旋矩阵 II <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="keyword">int</span> n) {</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 每循环一个圈的起始位置，最一开始从[0,0]位置开始</span></span><br><span class="line">        <span class="keyword">int</span> loop = n / <span class="number">2</span>; <span class="comment">//总循环的次数，n为奇数，循环n/2次，中间位置(n/2, n/2)须单独处理</span></span><br><span class="line">        <span class="keyword">int</span> mid = n / <span class="number">2</span>; <span class="comment">//n为奇数才会有中间位置(n/2, n/2)</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//用来给矩阵赋值</span></span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>; <span class="comment">//每一圈循环，需要控制每一条边遍历的长度</span></span><br><span class="line">        <span class="keyword">int</span> i, j; </span><br><span class="line">        <span class="keyword">while</span> (loop--) { </span><br><span class="line">            i = startx;  <span class="comment">//从起点开始遍历</span></span><br><span class="line">            j = starty;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//模拟填充上行从左到右[左闭右开）</span></span><br><span class="line">            <span class="keyword">for</span> ( ; j &lt; starty + n - offset; j++) {</span><br><span class="line">                res[i][j] = count;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//模拟填充右列从上到下[左闭右开）</span></span><br><span class="line">            <span class="keyword">for</span> ( ; i &lt; startx + n - offset; i++) {</span><br><span class="line">                res[i][j] = count;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//模拟填充下行从右到左[左闭右开）</span></span><br><span class="line">            <span class="keyword">for</span> ( ; j &gt; starty; j--) {</span><br><span class="line">                res[i][j] = count;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//模拟填充左列从下到上[左闭右开）</span></span><br><span class="line">            <span class="keyword">for</span> ( ; i &gt; startx; i--) {</span><br><span class="line">                res[i][j] = count;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            startx += <span class="number">1</span>; <span class="comment">//更新下一轮循环的起点</span></span><br><span class="line">            starty += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            offset += <span class="number">2</span>; <span class="comment">//更新下一轮循环的每一条边遍历需要去除的长度</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) res[mid][mid] = count; <span class="comment">//处理中心位置</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC54-螺旋矩阵"><a href="https://leetcode-cn.com/problems/spiral-matrix/">LC54.螺旋矩阵</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> loop = <span class="built_in">min</span>(m, n) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">while</span> (loop--) {</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( ; j &lt; starty + n - offset; j++) res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            <span class="keyword">for</span> ( ; i &lt; startx + m - offset; i++) res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            <span class="keyword">for</span> ( ; j &gt; starty; j--) res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            <span class="keyword">for</span> ( ; i &gt; startx; i--) res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line"></span><br><span class="line">            startx += <span class="number">1</span>;</span><br><span class="line">            starty += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            offset += <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span>(n, m) % <span class="number">2</span>) { <span class="comment">// 特殊处理 自己画一画找找规律</span></span><br><span class="line">            <span class="keyword">if</span> (m &gt; n) {</span><br><span class="line">                <span class="comment">//上面循环体中，最终startx未赋值给i，同时使用[]，遍历整行剩余的元素</span></span><br><span class="line">                <span class="keyword">for</span> (i = startx ; i &lt;= startx + m - offset; i++) </span><br><span class="line">                    <span class="comment">//上面循环体中，最终starty未赋值给j</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(matrix[i][starty]); <span class="comment">//注意细节处理</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">//上面循环体中，最终starty未赋值给j，同时使用[]，遍历整列剩余的元素</span></span><br><span class="line">                <span class="keyword">for</span> (j = starty ; j &lt;= starty + n - offset; j++) </span><br><span class="line">                    <span class="comment">//上面循环体中，最终starty未赋值给j</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(matrix[startx][j]); <span class="comment">//注意细节处理</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h5 id="螺旋矩阵的总结"><strong>螺旋矩阵的总结</strong></h5>
<ol>
<li>记住<code>LC59</code>题的模拟顺序</li>
</ol>
</li>
</ul>
<h2 id="链表">链表</h2>
<h3 id="1、链表的理论要点">1、链表的理论要点</h3>
<ul>
<li>需要返回整个链表时，借助<code>虚拟头节点</code>。</li>
</ul>
<h3 id="2、重点题型-2">2、重点题型</h3>
<h4 id="2-1、链表元素的移除">2.1、链表元素的移除</h4>
<ul>
<li>
<p><strong>解题思想</strong>：</p>
<ul>
<li>需要返回链表时使用虚拟头节点指向头节点</li>
<li>对链表的节点删除操作时，需要定义指向待删除节点前面的一个节点，使用cur-&gt;next指向待删除的节点，方便删除操作</li>
<li>删除链表节点时，需要释放掉被删除的节点</li>
</ul>
</li>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h5 id="LC203-移除链表元素"><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">LC203.移除链表元素</a></h5>
</li>
</ul>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head); <span class="comment">// 定义虚拟头节点</span></span><br><span class="line">        ListNode *cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) { <span class="comment">// 循环条件一般看循环体中的实现来确定</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val != val) { <span class="comment">//使用cur-&gt;next指向待删除的元素</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            ListNode *tmp = cur-&gt;next;  <span class="comment">//方便释放节点</span></span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//这里可以体现使用cur-&gt;next指向待删除节点的遍历</span></span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        }</span><br><span class="line">        head = dummyHead-&gt;next; </span><br><span class="line">        <span class="keyword">delete</span> dummyHead; <span class="comment">//释放虚拟头节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC237-删除链表中的节点"><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/">LC237.删除链表中的节点</a></h5>
</li>
</ul>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment">     * struct ListNode {</span></span><br><span class="line"><span class="comment">     *     int val;</span></span><br><span class="line"><span class="comment">     *     ListNode *next;</span></span><br><span class="line"><span class="comment">     *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment">     * };</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>{</span><br><span class="line">            node-&gt;val = node-&gt;next-&gt;val; <span class="comment">//用后面一个节点值替代node的值，删除后面的节点</span></span><br><span class="line">            ListNode *tmp = node-&gt;next;</span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC83-删除排序链表中的重复元素"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">LC83.删除排序链表中的重复元素</a></h5>
</li>
</ul>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; p-&gt;next) {</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val == p-&gt;next-&gt;val) {</span><br><span class="line">                ListNode *tmp = p-&gt;next;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC82-删除排序链表中的重复元素-II"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">LC82.删除排序链表中的重复元素 II</a></h5>
</li>
</ul>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head); <span class="comment">//需要返回链表，使用虚拟头节点</span></span><br><span class="line">        ListNode *l = dummyHead; </span><br><span class="line">        <span class="keyword">while</span> (l-&gt;next) {<span class="comment">//由于循环体中用到l-&gt;next-&gt;next，此处的判断条件要为l-&gt;next</span></span><br><span class="line">            ListNode *r = l-&gt;next-&gt;next; </span><br><span class="line">            <span class="keyword">while</span> (r &amp;&amp; r-&gt;val == l-&gt;next-&gt;val) { <span class="comment">//去除重复的元素</span></span><br><span class="line">                ListNode *tmp = r;</span><br><span class="line">                r = r-&gt;next;<span class="comment">//r指向重复节点后面的一位</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (l-&gt;next-&gt;next == r) l = l-&gt;next; <span class="comment">// 没有重复节点，l = l-&gt;next</span></span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                ListNode *tmp = l-&gt;next;</span><br><span class="line">                l-&gt;next = r; <span class="comment">// 有重复节点，l-&gt;next = r</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            }    </span><br><span class="line">        }</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<h5 id="LC19-删除链表的倒数第N个结点"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LC19.删除链表的倒数第N个结点</a></h5>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211103231204267.png" alt="image-20211103231204267"></p>
</li>
</ul>
  <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">        ListNode *slow = dummyHead, *fast = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (n--) fast = fast-&gt;next; <span class="comment">//fast先后移n个节点</span></span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) { <span class="comment">//slow和fast整体后移</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListNode *tmp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="2-2、链表元素的交换">2.2、链表元素的交换</h4>
<ul>
<li>
<p><strong>解题方法</strong>：双指针法等</p>
<ul>
<li>需要确定<code>pre</code>，<code>cur</code>指针的初始值</li>
<li><code>pre</code>，<code>cur</code>是如何更新的</li>
</ul>
</li>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h5 id="LC206-翻转链表"><a href="https://leetcode-cn.com/problems/reverse-linked-list/">LC206.翻转链表</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>, *cur = head; <span class="comment">//使用双指针</span></span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="comment">//另一种解法，借助虚拟头节点，把后面的节点依次出入虚拟头节点的后面</span></span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            ListNode *tmp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = dummyHead-&gt;next;</span><br><span class="line">            dummyHead-&gt;next = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h5 id="LC24-两两交换链表中的节点"><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs">LC24.两两交换链表中的节点</a></h5>
<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211103224928048.png" alt="image-20211103224928048" style="zoom:67%;">
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">        ListNode *cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) {</span><br><span class="line">            ListNode *tmp = cur-&gt;next, *tmp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = tmp;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = tmp1;</span><br><span class="line">            cur = cur-&gt;next-&gt;next; <span class="comment">//保证cur-&gt;next指向要处理的节点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="2-3、链表相关操作的实现">2.3、链表相关操作的实现</h4>
<ul>
<li>
<p><strong>相关题目</strong>：</p>
<ul>
<li>
<h5 id="LC707-设计链表"><a href="https://leetcode-cn.com/problems/design-linked-list/">LC707.设计链表</a></h5>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//需要自己创建链表节点，使用单链表，节点只记录val、next</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> {</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="keyword">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) {}</span><br><span class="line">    };</span><br><span class="line">    <span class="comment">//链表记录虚拟头节点、节点数量</span></span><br><span class="line">    ListNode* dummyHead;</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() { <span class="comment">//链表的构造函数：初始化链表的内容</span></span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{ <span class="comment">//获取指定位置节点的val值</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//索引不存在的情乱</span></span><br><span class="line">        ListNode *cur = dummyHead; <span class="comment">//统一使用cur-&gt;next指向待处理的节点位置</span></span><br><span class="line">        <span class="keyword">while</span> (index--) cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;next-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{ <span class="comment">//插入头节点</span></span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val); </span><br><span class="line">        tmp-&gt;next = dummyHead-&gt;next; </span><br><span class="line">        dummyHead-&gt;next = tmp;</span><br><span class="line">        _size += <span class="number">1</span>; <span class="comment">//勿忘</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{ <span class="comment">//插入尾节点</span></span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) cur = cur-&gt;next; <span class="comment">//遍历到尾节点的位置</span></span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size += <span class="number">1</span>; <span class="comment">//勿忘</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>{ <span class="comment">//在指定位置插入节点</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size || index &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        ListNode *tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode *cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index--) cur = cur-&gt;next;</span><br><span class="line">        tmp-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp;</span><br><span class="line">        _size += <span class="number">1</span>; <span class="comment">//勿忘</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{ <span class="comment">//删除指定位置的节点</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= _size || index &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        ListNode *cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index--) cur = cur-&gt;next;</span><br><span class="line">        ListNode *tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp; </span><br><span class="line">        _size -= <span class="number">1</span>; <span class="comment">//勿忘</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="2-4、其他题型">2.4、其他题型</h4>
<ul>
<li>
<h5 id="LC面试题02-07-链表相交"><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">LC面试题02.07.链表相交</a></h5>
<ul>
<li>
<p><strong>解题思想</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211104135625408.png" alt="image-20211104135625408"></p>
</li>
<li>
<p><strong>代码演示</strong>：</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        ListNode *a = headA, *b = headB;</span><br><span class="line">        <span class="keyword">while</span> (a != b) {</span><br><span class="line">            a = a != <span class="literal">nullptr</span> ? a-&gt;next : headB;</span><br><span class="line">            b = b != <span class="literal">nullptr</span> ? b-&gt;next : headA;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>解题思想</strong>：将链表A和链表B尾部对其，同时移动curA和curB，进行查找相同的位置</li>
</ul>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211104095242646.png" alt="image-20211104095242646"></p>
<ul>
<li><strong>代码演示</strong>：</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode { </span></span><br><span class="line"><span class="comment"> * 	int val;</span></span><br><span class="line"><span class="comment"> * 	ListNode *next;</span></span><br><span class="line"><span class="comment"> * 	ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cntA = <span class="number">0</span>, cntB = <span class="number">0</span>;</span><br><span class="line">        ListNode *curA = headA, *curB = headB;</span><br><span class="line">        <span class="keyword">while</span> (curA) cntA += <span class="number">1</span>, curA = curA-&gt;next; <span class="comment">//统计链表A的长度</span></span><br><span class="line">        <span class="keyword">while</span> (curB) cntB += <span class="number">1</span>, curB = curB-&gt;next; <span class="comment">//统计链表B的长度</span></span><br><span class="line"></span><br><span class="line">        curA = headA, curB = headB; <span class="comment">//重置回指向头节点，或者重新定义两个指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cntA &gt; cntB) { <span class="comment">// 保证curA指向的是长度短的链表，curB指向的是长度长的链表</span></span><br><span class="line">            <span class="built_in">swap</span>(curA, curB);</span><br><span class="line">            <span class="built_in">swap</span>(cntA, cntB);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> gap = cntB - cntA; <span class="comment">//两个链表的长度差</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) curB = curB-&gt;next; <span class="comment">//此时链表A,B尾部已经对其</span></span><br><span class="line">        <span class="keyword">while</span> (curA) {</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) <span class="keyword">return</span> curA;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h5 id="LC142-环形链表II"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LC142.环形链表II</a></h5>
<ul>
<li>
<p><strong>解题思想</strong>：</p>
<ul>
<li>
<p><strong>判断链表是否有环</strong>：使用快慢指针，<strong>fast指针一定先进入环中，如果fast 指针和slow指针相遇的话，一定是在环中相遇。</strong></p>
</li>
<li>
<p><strong>如果有环，找到这个环的入口</strong>：</p>
<p>假设从头结点到环形入口节点的节点数为<code>x</code>，环形入口节点到 <code>fast</code>指针与<code>slow</code>指针相遇节点的节点数为<code>y</code>， 从相遇节点再到环形入口节点节点数为<code>z</code>。 如图所示：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211104095631645.png" alt="image-20211104095631645"></p>
<p>那么相遇时： <code>slow</code>指针走过的节点数为: <code>x + y</code>， <code>fast</code>指针走过的节点数：<code>x + y + n (y + z)</code>，<code>n</code>为<code>fast</code>指针在环内走了<code>n</code>圈才遇到<code>slow</code>指针，<code>(y+z)</code>为 一圈内节点的个数<code>A</code>。</p>
<p>因为<code>fast</code>指针是一步走两个节点，<code>slow</code>指针一步走一个节点， 所以<code>fast</code>指针走过的节点数 = <code>slow</code>指针走过的节点数 <code>* 2</code>；</p>
<p>因为要找环形的入口，那么要求的是<code>x</code>，<code>x</code>表示 头结点到环形入口节点的的距离；</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211104112828853.png" alt="image-20211104112828853"></p>
</li>
</ul>
</li>
<li>
<p><strong>代码演示</strong>：</p>
</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next) { <span class="comment">//判断是否有环</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next; <span class="comment">//快指针两倍速后移</span></span><br><span class="line">            slow = slow-&gt;next; <span class="comment">//慢指针一倍速后移</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>; <span class="comment">//相遇退出，执行入口位置的确认</span></span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">//判断是否有环</span></span><br><span class="line">        ListNode *index = head; <span class="comment">//从头节点出发一个指针</span></span><br><span class="line">        <span class="keyword">while</span> (index != slow) { <span class="comment">//从相遇点出发一个指针，两个指针一次移动一步</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            index = index-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> index; <span class="comment">//相遇之处即是入口        </span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="2-5、链表总结">2.5、链表总结</h4>
<ul>
<li>
<p><strong>解题方法</strong>：</p>
<ul>
<li>快慢指针法：
<ul>
<li>相关题目：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LC142.环形链表 II</a>，<a href="https://leetcode-cn.com/problems/reverse-linked-list/">LC206.反转链表</a>，<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LC19.删除链表的倒数第 N 个结点</a></li>
</ul>
</li>
<li>普通遍历法：
<ul>
<li>相关题目：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">LC203.移除链表元素</a>，<a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/submissions/">LC24.两两交换链表中的节点</a></li>
</ul>
</li>
<li>其他特殊处理：
<ul>
<li>相关题目：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">LC面试题 02.07.链表相交</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>解题技巧</strong>：</p>
<ul>
<li>需要返回整个链表时，借助<code>虚拟头节点</code></li>
<li>涉及到前后节点之间的操作，需要定位到目标节点的前一个节点，使用<code>cur-&gt;next</code>指向目标节点</li>
<li>对于<code>while</code>循环的条件，需要根据循环体中用到的<code>cur,cur-&gt;next,cur-&gt;next-&gt;next</code>的情况来确定</li>
</ul>
</li>
</ul>
<h2 id="哈希表">哈希表</h2>
<h3 id="1、哈希表的理论要点">1、哈希表的理论要点</h3>
<ul>
<li>
<p>哈希碰撞的解决方法：</p>
<ol>
<li>拉链法</li>
<li>线性探测法</li>
</ol>
</li>
<li>
<p><code>C++</code>提供哈希表的结构：</p>
<ol>
<li>数组</li>
<li>集合</li>
</ol>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211110191759224.png" alt="image-20211110191759224"></p>
<ol start="3">
<li>映射</li>
</ol>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211110191901490.png" alt="image-20211110191901490"></p>
</li>
<li>
<p>哈希表结构的选择：</p>
<ol>
<li>数组 <code>&gt;</code> 集合 <code>&gt;</code> 映射</li>
<li>无序 <code>&gt;</code> 有序</li>
</ol>
</li>
</ul>
<h3 id="2、重点题型-3">2、重点题型</h3>
<ul>
<li>
<h4 id="LC242-有效的字母异位词"><a href="https://leetcode-cn.com/problems/valid-anagram/">LC242.有效的字母异位词</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 26个字母是确定数量，使用数组浪费不了多少空间，但是高效</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> record[<span class="number">30</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) record[s[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.<span class="built_in">size</span>(); i++) record[t[i] - <span class="string">'a'</span>] -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) </span><br><span class="line">            <span class="keyword">if</span> (record[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC383-赎金信"><a href="https://leetcode-cn.com/problems/ransom-note/">LC383.赎金信</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> record[<span class="number">30</span>] = {<span class="number">0</span>};</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.<span class="built_in">size</span>(); i++) record[magazine[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            record[ransomNote[i] - <span class="string">'a'</span>] -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (record[ransomNote[i] - <span class="string">'a'</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC49-字母异位词分组"><a href="https://leetcode-cn.com/problems/group-anagrams/">LC49.字母异位词分组</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) {</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt; &gt; umap;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : strs) {</span><br><span class="line">            string tmp = i;</span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            umap[tmp].<span class="built_in">push_back</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [s, v] : umap) {</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC438-找到字符串中所有字母异位词"><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">LC438.找到字符串中所有字母异位词</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">umap_p</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">umap_s</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : p) umap_p[i - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; s.<span class="built_in">size</span>(); fast++) { <span class="comment">//滑动窗口</span></span><br><span class="line">            umap_s[s[fast] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (fast &gt;= n) {</span><br><span class="line">                umap_s[s[slow] - <span class="string">'a'</span>] -= <span class="number">1</span>;</span><br><span class="line">                slow += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (umap_s == umap_p) res.<span class="built_in">push_back</span>(slow);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC349-两个数组的交集"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">LC349.两个数组的交集</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 本题相当于求集合的交集，是不能有重复元素存在的，使用unordered_set集合即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; uset, ures;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums1) uset.<span class="built_in">insert</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums2) {</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(i) != uset.<span class="built_in">end</span>()) ures.<span class="built_in">insert</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : ures) res.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC202-快乐数"><a href="https://leetcode-cn.com/problems/happy-number/">LC202.快乐数</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当出现循环时，sum会重复，可以使用哈希表标记sum值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_set&lt;<span class="keyword">int</span>&gt; uset;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) {</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">            sum = <span class="built_in">func</span>(sum);</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(sum) != uset.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//陷入循环中</span></span><br><span class="line">            uset.<span class="built_in">insert</span>(sum);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC1-两数之和-star-star-star"><a href="https://leetcode-cn.com/problems/two-sum/">LC1.两数之和 <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (umap.<span class="built_in">find</span>(target - nums[i]) != umap.<span class="built_in">end</span>()) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;{umap[target - nums[i]], i};</span><br><span class="line">            umap[nums[i]] = i; <span class="comment">//umap的值记录下标</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> {};</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>注意</strong>：与<a href="https://leetcode-cn.com/problems/3sum/">LC15.三数之和</a>、<a href="https://leetcode-cn.com/problems/4sum/">LC18.四数之和</a>的解法区别，三数、四数之和采用<strong>双指针</strong>更简单</p>
</blockquote>
</li>
<li>
<h4 id="LC454-四数相加II-star-star-star"><a href="https://leetcode-cn.com/problems/4sum-ii/">LC454.四数相加II <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, vector&lt;<span class="keyword">int</span>&gt;&amp; nums3, vector&lt;<span class="keyword">int</span>&gt;&amp; nums4)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums1) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : nums2) {</span><br><span class="line">                umap[i + j] += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums3) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : nums4) {</span><br><span class="line">                <span class="keyword">if</span> (umap.<span class="built_in">find</span>(<span class="number">0</span> - i - j) != umap.<span class="built_in">end</span>()) {</span><br><span class="line">                    count += umap[<span class="number">0</span> - i - j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="3、哈希表总结">3、哈希表总结</h3>
<ul>
<li>
<p><strong>数组作为哈希表</strong>：</p>
<ol>
<li>使用场景：元素数量是确定的，并且数量少，数组即可满足哈希要求</li>
<li>优点：数组在时间上是效率最高的</li>
<li>相关题目：<a href="https://leetcode-cn.com/problems/valid-anagram/">LC242.有效的字母异位词</a>，<a href="https://leetcode-cn.com/problems/ransom-note/">LC383.赎金信</a></li>
</ol>
</li>
<li>
<p><strong>集合<code>set</code>作为哈希表</strong>：</p>
<ol>
<li>使用场景：当使用数组时，哈希值比较分散，会造成空间的极大浪费，此时可以使用集合。优先选择使用底层是<strong>哈希表</strong>实现的<code>unordered_set</code>，其次如果需要排序时，使用底层是<strong>红黑树</strong>实现的<code>set</code>，如果不需要去重，使用底层是<strong>红黑树</strong>实现的<code>multiset</code></li>
<li>相关题目：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">LC349.两个数组的交集</a>，<a href="https://leetcode-cn.com/problems/happy-number/">LC202.快乐数</a></li>
</ol>
</li>
<li>
<p><strong>映射<code>map</code>作为哈希表</strong>：</p>
<ol>
<li>使用场景：集合<code>set</code>只能记录<code>key</code>值，如果还需要记录<code>key</code>对应的<code>数值</code>构成<strong>键值对</strong>，就需要使用<code>map</code>。优先选择使用底层是<strong>哈希表</strong>实现的<code>unordered_map</code>，其次如果需要排序时，使用底层是<strong>红黑树</strong>实现的<code>map</code>，如果不需要去重，使用底层是<strong>红黑树</strong>实现的<code>multimap</code></li>
<li>相关题目：<a href="https://leetcode-cn.com/problems/two-sum/">LC1.两数之和</a>，<a href="https://leetcode-cn.com/problems/4sum-ii/">LC454.四数相加 II</a></li>
</ol>
</li>
</ul>
<h2 id="字符串">字符串</h2>
<h3 id="1、字符串的理论要点">1、字符串的理论要点</h3>
<ul>
<li><strong>C++中常用的字符串操作函数</strong>：
<ol>
<li>返回子串<code>substr</code>(成员函数)：<code>对象.substr(pos, count)</code>
<ul>
<li><code>pos</code>：要包含的首个字符的位置</li>
<li><code>count</code>：子串的长度</li>
<li>返回值：含子串<code>[pos, pos + count)</code>或者<code>[pos, pos + size()]</code>的string</li>
</ul>
</li>
<li>更改存储的字符数<code>resize</code>：<code>对象.resize(count)</code>
<ul>
<li><code>count</code>：string的新大小</li>
<li>无返回值</li>
</ul>
</li>
<li>翻转字符串<code>reverse</code>：<code>reverse(s.begin(), s.begin() + count)</code>
<ul>
<li>迭代器通用的操作</li>
</ul>
</li>
<li>数值转换(非成员函数)
<ul>
<li><code>stoi,stol,stoll,stoul,stoull,stof,stod,stold</code></li>
<li><code>to_string</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2、重点题型-4">2、重点题型</h3>
<ul>
<li>
<h4 id="LC344-反转字符串"><a href="https://leetcode-cn.com/problems/reverse-string/">LC344.反转字符串</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; i++, j--) { <span class="comment">//双指针法</span></span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC541-反转字符串-II"><a href="https://leetcode-cn.com/problems/reverse-string-ii/">LC541.反转字符串 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i += (<span class="number">2</span> * k)) {</span><br><span class="line">            <span class="comment">// 每隔2K个字符的前K个字符进行反转</span></span><br><span class="line">            <span class="comment">// 剩余字符小于2K但大于或等于K个，则反转前K个字符</span></span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) {</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + i + k); <span class="comment">//都是反转前K个字符</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 剩余字符小于K个字符，将剩余的字符全部反转</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + s.<span class="built_in">size</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC剑指Offer05-替换空格"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">LC剑指Offer05.替换空格</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：先统计空格的数量，将字符串的长度扩展到填充%20后的长度，使用双指针从后往前遍历字符串，完成替换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) {</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">' '</span>) count += <span class="number">1</span>; <span class="comment">//统计空格数量</span></span><br><span class="line">        }</span><br><span class="line">        s.<span class="built_in">resize</span>(oldSize + count * <span class="number">2</span>); <span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">int</span> newSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> j = oldSize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--, j--) { <span class="comment">//从后往前遍历</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] != <span class="string">' '</span>) s[i] = s[j];</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                s[i--] = <span class="string">'0'</span>;</span><br><span class="line">                s[i--] = <span class="string">'2'</span>;</span><br><span class="line">                s[i] = <span class="string">'%'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC151-翻转字符串里的单词"><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">LC151.翻转字符串里的单词</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *     1、移除多余的空格</span></span><br><span class="line"><span class="comment"> * 	   2、将整个字符串反转</span></span><br><span class="line"><span class="comment"> *     3、将每个单词反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="comment">// 1、移除多余的空格</span></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1.1、移除开头的空格</span></span><br><span class="line">        <span class="keyword">while</span> (cur &lt; s.<span class="built_in">size</span>() &amp;&amp; s[cur] == <span class="string">' '</span>) cur += <span class="number">1</span>; <span class="comment">//cur指向开头不是空格的位置</span></span><br><span class="line">        <span class="comment">// 1.2、将内部的连续空格，替换成单个空格</span></span><br><span class="line">        <span class="keyword">while</span> (cur &lt; s.<span class="built_in">size</span>()) { </span><br><span class="line">            <span class="keyword">if</span> (cur - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s[cur - <span class="number">1</span>] == <span class="string">' '</span> &amp;&amp; s[cur] == <span class="string">' '</span>) cur += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                s[pre] = s[cur];</span><br><span class="line">                pre += <span class="number">1</span>;</span><br><span class="line">                cur += <span class="number">1</span>;</span><br><span class="line">            }         </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 1.3、移除尾部的空格，并重新定义字符串的大小</span></span><br><span class="line">        <span class="keyword">if</span> (pre - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[pre - <span class="number">1</span>] == <span class="string">' '</span>) s.<span class="built_in">resize</span>(pre - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">resize</span>(pre);</span><br><span class="line">		<span class="comment">// 2、反转整个字符串</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 3、将每个单词反转</span></span><br><span class="line">        cur = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; s.<span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; s.<span class="built_in">size</span>() &amp;&amp; s[cur] != <span class="string">' '</span>) cur += <span class="number">1</span>; <span class="comment">//cur定位单词的结尾位置</span></span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + pre, s.<span class="built_in">begin</span>() + cur);</span><br><span class="line">            pre = cur + <span class="number">1</span>; <span class="comment">//重新定位下一个单词的开始</span></span><br><span class="line">            cur += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC剑指Offer58-II-左旋转字符串"><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">LC剑指Offer58 - II.左旋转字符串</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *	1、反转前n个字符</span></span><br><span class="line"><span class="comment"> *  2、反转后 s.size() - n 个字符</span></span><br><span class="line"><span class="comment"> *  3、反转整个字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == len) <span class="keyword">return</span> s;</span><br><span class="line">        n %= len;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n); <span class="comment">// 1</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + n, s.<span class="built_in">end</span>()); <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用字符串拼接，空间复杂度变大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == len) <span class="keyword">return</span> s;</span><br><span class="line">        n %= len;</span><br><span class="line">        string str1 = s.<span class="built_in">substr</span>(<span class="number">0</span>, n); </span><br><span class="line">        string str2 = s.<span class="built_in">substr</span>(n, len - n);</span><br><span class="line">        str2 += str1;</span><br><span class="line">        <span class="keyword">return</span> str2;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC28-实现-strStr"><a href="https://leetcode-cn.com/problems/implement-strstr/">LC28.实现 strStr()</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> *next, string &amp;t)</span> </span>{</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>; t[i]; i++) {</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; t[j] != t[i]) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (t[i] == t[j]) j += <span class="number">1</span>;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> next[t.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">getNext</span>(next, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>, j = <span class="number">0</span>; s[i]; i++) {</span><br><span class="line">            <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; s[i] != t[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) j += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (t[j] == <span class="number">0</span>) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC459-重复的子字符串"><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">LC459.重复的子字符串</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">// KMP算法，只需求next数组</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> *next, string &amp;s)</span> </span>{</span><br><span class="line">            next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>; s[i]; i++) {</span><br><span class="line">                <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; s[j] != s[i]) j = next[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) j += <span class="number">1</span>;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>{</span><br><span class="line">            <span class="keyword">int</span> next[s.<span class="built_in">size</span>()];</span><br><span class="line">            <span class="built_in">getNext</span>(next, s);</span><br><span class="line">            <span class="keyword">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (next[len - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; len % (len - next[len - <span class="number">1</span>]) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="3、字符串总结">3、字符串总结</h3>
<ul>
<li>
<p>双指针法：<a href="https://leetcode-cn.com/problems/reverse-string/">LC344.反转字符串</a>，<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">LC剑指Offer05.替换空格</a>，<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">LC151.翻转字符串里的单词</a></p>
</li>
<li>
<p>字符串匹配(KMP算法)：<a href="https://leetcode-cn.com/problems/implement-strstr/">LC28.实现 strStr()</a>，<a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">LC459.重复的子字符串</a></p>
</li>
</ul>
<h2 id="双指针">双指针</h2>
<h3 id="1、重点题型">1、重点题型</h3>
<ul>
<li>
<h4 id="LC27-移除元素-2"><a href="https://leetcode-cn.com/problems/remove-element/">LC27.移除元素</a></h4>
</li>
<li>
<h4 id="LC344-反转字符串-2"><a href="https://leetcode-cn.com/problems/reverse-string/">LC344.反转字符串</a></h4>
</li>
<li>
<h4 id="LC剑指Offer05-替换空格-2"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">LC剑指Offer05.替换空格</a></h4>
</li>
<li>
<h4 id="LC206-翻转链表-2"><a href="https://leetcode-cn.com/problems/reverse-linked-list/">LC206.翻转链表</a></h4>
</li>
<li>
<h4 id="LC19-删除链表的倒数第N个结点-2"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">LC19.删除链表的倒数第N个结点</a></h4>
</li>
<li>
<h4 id="LC面试题02-07-链表相交-2"><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">LC面试题02.07.链表相交</a></h4>
</li>
<li>
<h4 id="LC142-环形链表-II"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">LC142.环形链表 II</a></h4>
</li>
<li>
<h4 id="LC2-两数相加"><a href="https://leetcode-cn.com/problems/add-two-numbers/">LC2.两数相加</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line">        ListNode *head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(), *tail = head;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || sum) {</span><br><span class="line">            <span class="keyword">int</span> n1 = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n2 = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            l1 = l1 ? l1-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            l2 = l2 ? l2-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">            sum += n1 + n2;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC15-三数之和"><a href="https://leetcode-cn.com/problems/3sum/">LC15.三数之和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="comment">// 进行排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="comment">// 对于排序好的序列，如果第一个元素大于0，后面两个元素之和必然大于0，都不满足情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++) { </span><br><span class="line">            <span class="comment">// 第一个元素去重，不能使用nums[i] == nums[i + 1]去重，那样会过度去重 -1 -1 2</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 使用双指针，寻找后面满足条件的两个元素</span></span><br><span class="line">            <span class="keyword">int</span> fast = size - <span class="number">1</span>, slow = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (fast &gt; slow) {</span><br><span class="line">                <span class="keyword">if</span> (nums[fast] + nums[slow] &gt; sum) fast -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[fast] + nums[slow] &lt; sum) slow += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> {</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;{nums[i], nums[slow], nums[fast]});</span><br><span class="line">                    <span class="comment">//第2个元素去重</span></span><br><span class="line">                    <span class="keyword">while</span> (fast &gt; slow &amp;&amp; nums[fast] == nums[fast - <span class="number">1</span>]) fast -= <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//第3个元素去重</span></span><br><span class="line">                    <span class="keyword">while</span> (fast &gt; slow &amp;&amp; nums[slow] == nums[slow + <span class="number">1</span>]) slow += <span class="number">1</span>;</span><br><span class="line">                    slow += <span class="number">1</span>;</span><br><span class="line">                    fast -= <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC18-四数之和"><a href="https://leetcode-cn.com/problems/4sum/">LC18.四数之和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="keyword">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 此处不能通过 nums[i] &lt;= target 进行剪枝</span></span><br><span class="line">        <span class="comment">// 如果 target &lt; 0, 是不可以的剪枝的, target = -5, 那么 -3 + -2 + 0 + 0 = -5</span></span><br><span class="line">        <span class="comment">// 如果 target &gt;= 0, 是可以剪枝的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">3</span>; i++) {</span><br><span class="line">            <span class="comment">// 第一个元素去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 此处同样不能剪枝</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size - <span class="number">2</span>; j++) {</span><br><span class="line">                <span class="comment">// 第二个元素去重</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> fast = size - <span class="number">1</span>, slow = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = target - nums[i] - nums[j];</span><br><span class="line">                <span class="keyword">while</span> (slow &lt; fast) {</span><br><span class="line">                    <span class="keyword">if</span> (nums[fast] + nums[slow] &gt; sum) fast -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[fast] + nums[slow] &lt; sum) slow += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;{nums[i], nums[j], nums[slow], nums[fast]});</span><br><span class="line">                        <span class="comment">// 第三、四个元素去重</span></span><br><span class="line">                        <span class="keyword">while</span> (slow &lt; fast &amp;&amp; nums[fast] == nums[fast - <span class="number">1</span>]) fast -= <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span> (slow &lt; fast &amp;&amp; nums[slow] == nums[slow + <span class="number">1</span>]) slow += <span class="number">1</span>;</span><br><span class="line">                        slow += <span class="number">1</span>;</span><br><span class="line">                        fast -= <span class="number">1</span>; </span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="2、双指针总结">2、双指针总结</h3>
<ul>
<li>同一数组中查找<code>N</code>(<strong>N &gt; 2</strong>)数之和问题，前面<code>N - 2</code>个数通过<strong>for循环</strong>进行遍历，后面<code>2</code>个数通过双指针确定，使用双指针处理N数之和问题，便于去重，而哈希表不适合去重，注意区分<a href="https://leetcode-cn.com/problems/two-sum/">LC1.两数之和</a>，<a href="https://leetcode-cn.com/problems/4sum-ii/">LC454.四数相加 II</a>，<a href="https://leetcode-cn.com/problems/3sum/">LC15.三数之和</a>，<a href="https://leetcode-cn.com/problems/4sum/">LC18.四数之和</a>的解法。</li>
</ul>
<h2 id="栈与队列">栈与队列</h2>
<h3 id="1、栈与队列的理论要点">1、栈与队列的理论要点</h3>
<h3 id="2、重点题型-5">2、重点题型</h3>
<ul>
<li>
<h4 id="LC232-用栈实现队列"><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">LC232.用栈实现队列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 元素的插入直接插入到staPush栈中</span></span><br><span class="line"><span class="comment">// 元素的弹出从staPop栈弹出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="comment">// 元素的插入直接插入到staPush中</span></span><br><span class="line">        staPush.<span class="built_in">push</span>(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{ <span class="comment">// 元素的弹出从staPop栈中弹出</span></span><br><span class="line">        <span class="comment">// 如果staPop栈为空，将staPush栈中的元素全部插入到staPop栈中</span></span><br><span class="line">        <span class="keyword">if</span> (staPop.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">while</span> (!staPush.<span class="built_in">empty</span>()) {</span><br><span class="line">                staPop.<span class="built_in">push</span>(staPush.<span class="built_in">top</span>());</span><br><span class="line">                staPush.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// staPop栈不为空，直接弹出staPop栈的栈首元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = staPop.<span class="built_in">top</span>();</span><br><span class="line">        staPop.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>{ <span class="comment">// 借助pop操作，实现peek操作</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        staPop.<span class="built_in">push</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> staPop.<span class="built_in">empty</span>() &amp;&amp; staPush.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; staPush, staPop;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC225-用队列实现栈"><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">LC225.用队列实现栈</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用另外一个que2队列用来周转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="comment">// que1队列用来插入元素</span></span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{ </span><br><span class="line">        <span class="comment">// 将que1队列中弹出压入que2中，只剩下最后一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (que1.<span class="built_in">size</span>() &gt; <span class="number">1</span>) {</span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 弹出最后一个元素</span></span><br><span class="line">        <span class="keyword">int</span> temp = que1.<span class="built_in">front</span>();</span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 再将弹出的元素压入队列中</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>()) {</span><br><span class="line">            que1.<span class="built_in">push</span>(que2.<span class="built_in">front</span>());</span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{ <span class="comment">// 栈顶元素就是que1的队尾元素</span></span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">back</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que1, que2;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que; <span class="comment">// 使用一个队列模拟实现</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> size = que.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (size--) {</span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">back</span>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC20-有效的括号"><a href="https://leetcode-cn.com/problems/valid-parentheses/">LC20.有效的括号</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) {</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">'('</span>) sta.<span class="built_in">push</span>(<span class="string">')'</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">'{'</span>) sta.<span class="built_in">push</span>(<span class="string">'}'</span>); </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">'['</span>) sta.<span class="built_in">push</span>(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!sta.<span class="built_in">empty</span>() &amp;&amp; sta.<span class="built_in">top</span>() == i) {</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sta.<span class="built_in">empty</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC1047-删除字符串中的所有相邻重复项"><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">LC1047.删除字符串中的所有相邻重复项</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        stack&lt;<span class="keyword">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) {</span><br><span class="line">            <span class="keyword">if</span> (!sta.<span class="built_in">empty</span>() &amp;&amp; sta.<span class="built_in">top</span>() == i) {</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            sta.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        string str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            str += sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        string str = <span class="string">""</span>; <span class="comment">// 使用string模拟栈操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) {</span><br><span class="line">            <span class="keyword">if</span> (str.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; str.<span class="built_in">back</span>() == i) {</span><br><span class="line">                str.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            } </span><br><span class="line">            str.<span class="built_in">push_back</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC150-逆波兰表达式求值"><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">LC150.逆波兰表达式求值</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>{</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : tokens) {</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="string">"+"</span> || i == <span class="string">"-"</span> || i == <span class="string">"*"</span> ||i == <span class="string">"/"</span>) {</span><br><span class="line">                <span class="keyword">int</span> s1 = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> s2 = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> sum;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="string">"+"</span>) sum = s1 + s2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">"-"</span>)  sum = s2 - s1;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="string">"*"</span>) sum = s1 * s2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( i == <span class="string">"/"</span>) sum = s2 / s1;</span><br><span class="line">                sta.<span class="built_in">push</span>(sum); <span class="comment">// 将结果压入栈</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                sta.<span class="built_in">push</span>(<span class="built_in">stoi</span>(i));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sta.<span class="built_in">top</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC239-滑动窗口最大值"><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">LC239.滑动窗口最大值</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 单调队列：队首元素保存当前的最大值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Myque</span> {</span> <span class="comment">// 实现单调队列</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; deq; <span class="comment">// 需要在队尾、队首删除元素，使用双端队列</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{  <span class="comment">// 当队首元素需要移出窗口时</span></span><br><span class="line">            <span class="keyword">if</span> (!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">front</span>() == val) deq.<span class="built_in">pop_front</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">back</span>() &lt; val) { <span class="comment">// 可以保证插入后，队列元素的顺序和原顺序一致</span></span><br><span class="line">                deq.<span class="built_in">pop_back</span>();</span><br><span class="line">            }</span><br><span class="line">            deq.<span class="built_in">push_back</span>(val);     </span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> deq.<span class="built_in">front</span>();</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        Myque que;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        }</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC347-前-K-个高频元素"><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">LC347.前 K 个高频元素</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">mycompare</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) umap[i] += <span class="number">1</span>;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, mycompare&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[fi, se] : umap) {</span><br><span class="line">            que.<span class="built_in">push</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;{fi, se});</span><br><span class="line">            <span class="keyword">if</span> (que.<span class="built_in">size</span>() &gt; k) {</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">            } </span><br><span class="line">        }</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            res.<span class="built_in">push_back</span>(que.<span class="built_in">top</span>().first);</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="二叉树">二叉树</h2>
<h3 id="1、二叉树的理论要点">1、二叉树的理论要点</h3>
<ul>
<li>
<p><strong>递归算法的三要素</strong>：</p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
</li>
<li>
<p><strong>递归函数的返回值，递归函数什么时候需要返回值？什么时候不需要返回值？总结如下三点</strong>：</p>
</li>
</ul>
<ol>
<li>
<p>如果需要<strong>搜索整颗二叉树且不用处理递归返回值</strong>，递归函数就不要返回值。</p>
</li>
<li>
<p>如果需要搜索整颗二叉树且需要<strong>处理递归返回值</strong>，递归函数就需要返回值。</p>
</li>
<li>
<p>如果要<strong>搜索其中一条符合条件的路径</strong>，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。</p>
</li>
</ol>
<ul>
<li><strong>一般情况来说：如果让空节点（空指针）进入递归，就不加if，如果不让空节点进入递归，就加if限制一下， 终止条件也会相应的调整。</strong></li>
</ul>
<h3 id="2、重点题型-6">2、重点题型</h3>
<ul>
<li>
<h4 id="LC144-二叉树的前序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">LC144.二叉树的前序遍历</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 递归法:</span></span><br><span class="line"><span class="comment">     * 分析：递归法三要素</span></span><br><span class="line"><span class="comment">	 * 1、确定递归函数的参数和返回值：因为每一次遍历都要记录下节点的值，需要使用vector来存储，其次还需要传入要遍历的节点；不需要有返回值，返回值类型为void</span></span><br><span class="line"><span class="comment">	 * 2、确认终止条件：当前遍历节点为空就返回</span></span><br><span class="line"><span class="comment">	 * 3、单层递归的逻辑：前序遍历顺序为中左右，先记录当前节点的值，再递归遍历左子树和右子树的值</span></span><br><span class="line"><span class="comment">	 * 综上：void traversal(TreeNode *root, vector&lt;int&gt; &amp;res);  </span></span><br><span class="line"><span class="comment">	 * 函数类型和给出的函数类型不同，需要单独定义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ; <span class="comment">// 终止条件</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res); <span class="comment">// 左，递归遍历左子树</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res); <span class="comment">// 右，递归遍历左子树</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 递归遍历二叉树的左右子树只能是栈来存储树的节点，同时按照遍历顺序逆序放入栈中，前序遍历需要先放右节点再放左节点，弹出时就可以先遍历左子树，后遍历右子树</span></span><br><span class="line"><span class="comment">         * 使用迭代方法需要处理两个过程：</span></span><br><span class="line"><span class="comment">         * 1、处理：将元素放进res数组中</span></span><br><span class="line"><span class="comment">         * 2、访问：遍历节点</span></span><br><span class="line"><span class="comment">         * 前序遍历的顺序和存放元素的顺序是一致的，先访问中间节点再处理中间节点，不需要额外变量辅助</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stack&lt;TreeNode *&gt; sta; </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sta.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode *cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line">            <span class="comment">// 只记录非空节点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) sta.<span class="built_in">push</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) sta.<span class="built_in">push</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC145-二叉树的后序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">LC145.二叉树的后序遍历</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res); <span class="comment">// 左：递归遍历左子树</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res); <span class="comment">// 右：递归遍历右子树</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 后续遍历是在前序遍历的基础上改造即可，按照中右左的顺序遍历，将得到的结果翻转即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode *&gt; sta;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sta.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode *cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">// 中</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) sta.<span class="built_in">push</span>(cur-&gt;left); <span class="comment">// 左</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) sta.<span class="built_in">push</span>(cur-&gt;right); <span class="comment">// 右</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC589-N-叉树的前序遍历"><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">LC589.N 叉树的前序遍历</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : root-&gt;children) <span class="built_in">traversal</span>(i, res);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorder</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        stack&lt;Node*&gt; sta;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sta.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            Node *cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = cur-&gt;children.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) { <span class="comment">// 逆序插入栈中，最左边的需要最先取出</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;children[i] != <span class="literal">nullptr</span>) sta.<span class="built_in">push</span>(cur-&gt;children[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC590-N-叉树的后序遍历"><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">LC590.N 叉树的后序遍历</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(Node *root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : root-&gt;children) <span class="built_in">traversal</span>(i, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorder</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        stack&lt;Node*&gt; sta;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        sta.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            Node *cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : cur-&gt;children) sta.<span class="built_in">push</span>(i); <span class="comment">// 和前序遍历相反的顺序</span></span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC94-二叉树的中序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">LC94.二叉树的中序遍历</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode *root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left, res); <span class="comment">// 左：递归遍历左子树</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val); <span class="comment">// 右：递归遍历右子树</span></span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right, res); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">traversal</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 使用迭代方法需要处理两个过程：</span></span><br><span class="line"><span class="comment">         * 1、处理：将元素放进res数组中</span></span><br><span class="line"><span class="comment">         * 2、访问：遍历节点</span></span><br><span class="line"><span class="comment">         * 中序遍历的顺序和存放元素的顺序是不一致的，先访问最左节点再处理节点，需要额外变量辅助</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode *&gt; sta;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) {</span><br><span class="line">                sta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    } </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC102-二叉树的层序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">LC102.二叉树的层序遍历</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 层序队列使用队列进行节点保存</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC107-二叉树的层序遍历-II"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">LC107.二叉树的层序遍历 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) {</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC199-二叉树的右视图"><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">LC199.二叉树的右视图</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == size - <span class="number">1</span>) res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC637-二叉树的层平均值"><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">LC637.二叉树的层平均值</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>; <span class="comment">// 定义成double，方便后面做除法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                sum += cur-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum / size);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC515-在每个树行中找最大值"><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">LC515.在每个树行中找最大值</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> temp = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                temp = <span class="built_in">max</span>(temp, cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC116-填充每个节点的下一个右侧节点指针"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">LC116.填充每个节点的下一个右侧节点指针</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) {}</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                Node *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i != size - <span class="number">1</span>) cur-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC117-填充每个节点的下一个右侧节点指针-II"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">LC117.填充每个节点的下一个右侧节点指针 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) {}</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">       queue&lt;Node*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                Node *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i != size - <span class="number">1</span>) cur-&gt;next = que.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC226-翻转二叉树"><a href="https://leetcode-cn.com/problems/invert-binary-tree/">LC226.翻转二叉树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right); <span class="comment">// 中</span></span><br><span class="line">        root-&gt;left = <span class="built_in">invertTree</span>(root-&gt;left); <span class="comment">// 左</span></span><br><span class="line">        root-&gt;right = <span class="built_in">invertTree</span>(root-&gt;right); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        stack&lt;TreeNode*&gt; sta;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        sta.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode *cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(cur-&gt;left, cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) sta.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) sta.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/* 每一个节点都要翻转它的左右子树，使用栈或者队列都可以，需要把所有节点走一遍*/</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(cur-&gt;left, cur-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC101-对称二叉树"><a href="https://leetcode-cn.com/problems/symmetric-tree/">LC101.对称二叉树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">symmetric</span><span class="params">(TreeNode *left, TreeNode *right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">symmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">symmetric</span>(left-&gt;right, right-&gt;left);  </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">symmetric</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 迭代法使用栈或者队列都可以，只要是成对取元素即可</span></span><br><span class="line"><span class="comment">         * 使用队列：是按照层遍历进行比较</span></span><br><span class="line"><span class="comment">         * 使用栈：是按照树的深度，沿着一棵树递归遍历比较，但最后所有的对称点都可以遍历到</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode *left = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode *right = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;right); <span class="comment">// 注意顺序</span></span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC100-相同的树"><a href="https://leetcode-cn.com/problems/same-tree/">LC100.相同的树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(p);</span><br><span class="line">        que.<span class="built_in">push</span>(q);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode *left = que.<span class="built_in">front</span>(); </span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode *right = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC104-二叉树的最大深度"><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">LC104.二叉树的最大深度</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 求最大深度 == 求树的根节点的高度</span></span><br><span class="line"><span class="comment">         * 求高度是从底层往高层计算，需要通过后序遍历的顺序求解，当前节点的高度 = 1 + max(左节点, 右节点)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)); </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 直接求每个节点的深度，比较得出最大深度</span></span><br><span class="line"><span class="comment">     * 求深度需要从上层往下层遍历，采用前序遍历的顺序</span></span><br><span class="line"><span class="comment">     * 采用回溯的思想，对于递归函数中的参数depth是来指定当前节点的深度，如果求左节点的深度改变了，对于同一层的右节点的深度也被改变了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getDepth</span><span class="params">(TreeNode *node, <span class="keyword">int</span> depth)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> ; <span class="comment">// 终止条件</span></span><br><span class="line">        result = <span class="built_in">max</span>(result, depth); <span class="comment">// 中</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) <span class="built_in">getDepth</span>(node-&gt;left, depth + <span class="number">1</span>); <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) <span class="built_in">getDepth</span>(node-&gt;right, depth + <span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">getDepth</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 层序遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> count;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC559-N叉树的最大深度"><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">LC559.N叉树的最大深度</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>; <span class="comment">// 此处不能使用全局变量，否则没调用一个节点的递归函数height就会递增1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : root-&gt;children) {</span><br><span class="line">            height = <span class="built_in">max</span>(height, <span class="built_in">maxDepth</span>(i)); <span class="comment">// 左右</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> height + <span class="number">1</span>; <span class="comment">// 中</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getDepth</span><span class="params">(Node *root, <span class="keyword">int</span> depth)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        res = <span class="built_in">max</span>(res, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : root-&gt;children) {</span><br><span class="line">            <span class="built_in">getDepth</span>(i, depth + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>{</span><br><span class="line">        <span class="built_in">getDepth</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() {}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 层序遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue&lt;Node*&gt; que;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                Node *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> i : cur-&gt;children) que.<span class="built_in">push</span>(i); </span><br><span class="line">            }</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC111-二叉树的最小深度"><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">LC111.二叉树的最小深度</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 画图帮助理解</span></span><br><span class="line"><span class="comment">         * 按照高度求最小深度，和普通二叉树高度不同，此题说的高度是相对于每个叶子节点来计算的高度，在每一层选举高度最小的节点作为最小深度的节点</span></span><br><span class="line"><span class="comment">         * 同样按照后序遍历的顺序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left), <span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 层序遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> count;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> count; <span class="comment">// 最小深度处</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC222-完全二叉树的节点个数"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">LC222.完全二叉树的节点个数</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 递归算法采用后序遍历的顺序，当前节点所包含的节点数 = 左子树节点数目 + 右子树节点数目 + 1，需要先遍历左右子树，再遍历中间节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>; <span class="comment">// 左，右，中</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 层序遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                result += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 将完全二叉树分解为完美二叉树，通过完美二叉树节点的计算方式求完全二叉树的节点数目</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode *left = root-&gt;left;</span><br><span class="line">        TreeNode *right = root-&gt;right;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = <span class="number">0</span>, rightHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left) { <span class="comment">// 求左子树最左边的高度</span></span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">            leftHeight += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (right) { <span class="comment">// 求右子树最右边的高度</span></span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">            rightHeight += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == rightHeight) <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftHeight) - <span class="number">1</span>; <span class="comment">// 此时说明是完美二叉树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right) + <span class="number">1</span>; <span class="comment">// 将完全二叉树划分为完美二叉树</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC110-平衡二叉树"><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">LC110.平衡二叉树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode *root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = <span class="built_in">getHeight</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightHeight = <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span> ? <span class="number">-1</span> : <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC257-二叉树的所有路径"><a href="https://leetcode-cn.com/problems/binary-tree-paths/">LC257.二叉树的所有路径</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 递归 + 回溯</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, string path, vector&lt;string&gt; &amp;res)</span> </span>{ <span class="comment">// 此处不能是string &amp;，string &amp;不能绑定表达式上</span></span><br><span class="line">        path += <span class="built_in">to_string</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) {</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) <span class="built_in">traversal</span>(cur-&gt;left, path + <span class="string">"-&gt;"</span>, res); <span class="comment">// 回溯思想，保证cur-&gt;right的遍历还是从path开始</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) <span class="built_in">traversal</span>(cur-&gt;right, path + <span class="string">"-&gt;"</span>, res);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC404-左叶子之和"><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">LC404.左叶子之和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">// 采用前序或后续遍历都可以</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 左叶子节点的判断</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left-&gt;right == <span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;left-&gt;val + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right); <span class="comment">// 如果当前节点左节点是叶子节点，只需要再递归遍历右子树查找左叶子节点即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right); <span class="comment">// 左右节点都不是叶子节点，就递归遍历查找</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 迭代法</span></span><br><span class="line"><span class="comment">         * 按照前序遍历的顺序，如果是左叶子节点就加入结果中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        stack&lt;TreeNode *&gt; sta;</span><br><span class="line">        sta.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode *cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;left-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;left-&gt;right == <span class="literal">nullptr</span>) res += cur-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) sta.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) sta.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC513-找树左下角的值"><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">LC513.找树左下角的值</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 递归算法</span></span><br><span class="line"><span class="comment">     * 通过附加参数当前节点的深度来确定最底层的最左边的叶子节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> maxLen = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> maxleftVal;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode *root, <span class="keyword">int</span> leftLen)</span> </span>{</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) { </span><br><span class="line">            <span class="keyword">if</span> (leftLen &gt; maxLen) { <span class="comment">// 当遇到更深节点，由于先遍历左子树，后遍历右子树，可以保证在同一层中记录的是最左边的节点</span></span><br><span class="line">                maxLen = leftLen;</span><br><span class="line">                maxleftVal = root-&gt;val;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历顺序不能变，需要先遍历左子树，如果是题目是选择最右边的节点，需要先遍历右子树</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">traversal</span>(root-&gt;left, leftLen + <span class="number">1</span>); <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">traversal</span>(root-&gt;right, leftLen + <span class="number">1</span>); <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">traversal</span>(root, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> maxleftVal;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 迭代法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">                TreeNode *cur = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) res = cur-&gt;val; <span class="comment">// 不断的更新，直到最后一层</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC112-路径总和"><a href="https://leetcode-cn.com/problems/path-sum/">LC112.路径总和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 递归法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、计数通过递减的方式传递</span></span><br><span class="line"><span class="comment">         * 2、叶子节点对应的计数值达到要求就终止，此时已找到符合要求的路径</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == root-&gt;val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val); <span class="comment">// 还有回溯的思想</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC113-路径总和-II"><a href="https://leetcode-cn.com/problems/path-sum-ii/">LC113.路径总和 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 不能以root == nullptr为条件, 要不然遍历root-&gt;left会产生一次path，遍历root-&gt;right产生一次path</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == root-&gt;val) {</span><br><span class="line">            path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 由于path用的全局变量，下一轮回溯中不应该有root-&gt;val，要不然使用局部变量传参进来</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">traversal</span>(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">traversal</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) {</span><br><span class="line">        <span class="built_in">traversal</span>(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC106-从中序与后序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">LC106.从中序与后序遍历序列构造二叉树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inorderLeft, <span class="keyword">int</span> inorderRight, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> postorderLeft, <span class="keyword">int</span> postorderRight)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (inorderLeft &gt;= inorderRight) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = postorder[postorderRight - <span class="number">1</span>];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(midVal);</span><br><span class="line">        <span class="keyword">int</span> midIndex = inorderLeft;</span><br><span class="line">        <span class="keyword">while</span> (inorder[midIndex] != midVal) midIndex += <span class="number">1</span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(inorder, inorderLeft, midIndex, postorder, postorderLeft, postorderLeft + midIndex - inorderLeft);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(inorder, midIndex + <span class="number">1</span>, inorderRight, postorder, postorderLeft + midIndex - inorderLeft, postorderRight - <span class="number">1</span>); <span class="comment">// 注意位置的变换</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (inorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC105-从前序与中序遍历序列构造二叉树"><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LC105.从前序与中序遍历序列构造二叉树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归构造树都需要有返回值</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> preorderLeft, <span class="keyword">int</span> preorderRight, vector&lt;<span class="keyword">int</span>&gt; &amp;inorder, <span class="keyword">int</span> inorderLeft, <span class="keyword">int</span> inorderRight)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (preorderRight - preorderLeft == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = preorder[preorderLeft];</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(midVal);</span><br><span class="line">        <span class="keyword">int</span> midIndex = inorderLeft;</span><br><span class="line">        <span class="keyword">while</span> (inorder[midIndex] != midVal) midIndex += <span class="number">1</span>;</span><br><span class="line">        root-&gt;left =  <span class="built_in">traversal</span>(preorder, preorderLeft + <span class="number">1</span>, preorderLeft + midIndex - inorderLeft + <span class="number">1</span>, inorder, inorderLeft, midIndex);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(preorder, preorderLeft + midIndex - inorderLeft + <span class="number">1</span>, preorderRight, inorder, midIndex + <span class="number">1</span>, inorderRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (preorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>(), inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC654-最大二叉树"><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">LC654.最大二叉树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode *<span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = left; <span class="comment">// </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[maxIndex] &lt; nums[i]) maxIndex = i;</span><br><span class="line">        }</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxIndex]);</span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums, left, maxIndex);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums, maxIndex + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC617-合并二叉树"><a href="https://leetcode-cn.com/problems/merge-two-binary-trees">LC617.合并二叉树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>{</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        que.<span class="built_in">push</span>(root1);</span><br><span class="line">        que.<span class="built_in">push</span>(root2);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            TreeNode *leftNode = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode *rightNode = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            leftNode-&gt;val += rightNode-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (leftNode-&gt;left &amp;&amp; rightNode-&gt;left) {</span><br><span class="line">                que.<span class="built_in">push</span>(leftNode-&gt;left);</span><br><span class="line">                que.<span class="built_in">push</span>(rightNode-&gt;left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (leftNode-&gt;right &amp;&amp; rightNode-&gt;right) {</span><br><span class="line">                que.<span class="built_in">push</span>(leftNode-&gt;right);</span><br><span class="line">                que.<span class="built_in">push</span>(rightNode-&gt;right);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (leftNode-&gt;left == <span class="literal">nullptr</span> &amp;&amp; rightNode-&gt;left != <span class="literal">nullptr</span>) leftNode-&gt;left = rightNode-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (leftNode-&gt;right == <span class="literal">nullptr</span> &amp;&amp; rightNode-&gt;right != <span class="literal">nullptr</span>) leftNode-&gt;right = rightNode-&gt;right; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC700-二叉搜索树中的搜索"><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">LC700.二叉搜索树中的搜索</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchBST</span>(root-&gt;left, val);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (root) {</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val == val) <span class="keyword">return</span> root;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> root = root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC98-验证二叉搜索树"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">LC98.验证二叉搜索树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre = LONG_MIN;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>{ <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> leftNode = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="keyword">bool</span> rightNode = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> leftNode &amp;&amp; rightNode;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>{ <span class="comment">// 中序遍历</span></span><br><span class="line">        stack&lt;TreeNode*&gt; sta;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) {</span><br><span class="line">                sta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;val &lt;= pre-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC530-二叉搜索树的最小绝对差"><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">LC530.二叉搜索树的最小绝对差</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> minVal = INT_MAX;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>) minVal = <span class="built_in">min</span>(minVal, root-&gt;val - pre-&gt;val);</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> minVal;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        stack&lt;TreeNode *&gt; sta;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) {</span><br><span class="line">                sta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>) res = <span class="built_in">min</span>(res, cur-&gt;val - pre-&gt;val);</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC501-二叉搜索树中的众数"><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">LC501.二叉搜索树中的众数</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == root-&gt;val) count += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (count == maxCount) res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) {</span><br><span class="line">            maxCount = count;</span><br><span class="line">            res.<span class="built_in">clear</span>(); <span class="comment">// res永远保存的是当前遍历过的众数</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        } </span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        stack&lt;TreeNode *&gt; sta;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !sta.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>) {</span><br><span class="line">                sta.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                cur = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == cur-&gt;val) count += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (count == maxCount) res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (count &gt; maxCount) {</span><br><span class="line">                    maxCount = count;</span><br><span class="line">                    res.<span class="built_in">clear</span>();</span><br><span class="line">                    res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                }</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            }  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC236-二叉树的最近公共祖先"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">LC236.二叉树的最近公共祖先</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 求公共祖先需要从底往上遍历，使用后续遍历</span></span><br><span class="line"><span class="comment">     * 此题需要遍历整棵树，因为需要根据left和right做判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q || root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">// 如果先遍历到了p，那么q要么在p的子树上，要么在别的树上，反之一样</span></span><br><span class="line">        TreeNode *left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="comment">// 此时left和right的值只有两种可能：nullptr 或 p,q所在的节点</span></span><br><span class="line">        <span class="comment">// 将目标逐层上传</span></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> root; <span class="comment">// root是p,q的父节点</span></span><br><span class="line">        <span class="comment">// right是目标，用目标覆盖当前节点，继续上传</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span>) <span class="keyword">return</span> right; <span class="comment">// left = nullptr right != nullptr 此时right一定为p或q</span></span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// 同理此时left一定是p或q， 或者left right都为nullptr</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC235-二叉搜索树的最近公共祖先"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">LC235.二叉搜索树的最近公共祖先</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (root) {</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC701-二叉搜索树中的插入操作"><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">LC701.二叉搜索树中的插入操作</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        TreeNode *cur = root, *pre = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) {</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val &gt; val) cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (val &lt; pre-&gt;val) pre-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">else</span> pre-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC450-删除二叉搜索树中的节点"><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">LC450.删除二叉搜索树中的节点</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">preccedeNode</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;right) root = root-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    } </span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 叶子节点或只有一个子节点的节点</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> || root-&gt;right == <span class="literal">nullptr</span>) {</span><br><span class="line">                TreeNode *temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> root;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> { <span class="comment">// 含有两个子节点的节点</span></span><br><span class="line">                TreeNode *temp = <span class="built_in">preccedeNode</span>(root-&gt;left);</span><br><span class="line">                root-&gt;val = temp-&gt;val;</span><br><span class="line">                root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, temp-&gt;val);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC669-修剪二叉搜索树"><a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/">LC669. 修剪二叉搜索树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high) <span class="keyword">return</span> <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC108-将有序数组转换为二叉搜索树"><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">LC108.将有序数组转换为二叉搜索树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> midIndex = left + (right - left) / <span class="number">2</span>;  </span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[midIndex]);</span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums, left, midIndex);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums, midIndex + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC538-把二叉搜索树转换为累加树"><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">LC538.把二叉搜索树转换为累加树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 右中左的遍历顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">nullptr</span>) {</span><br><span class="line">            root-&gt;val += pre-&gt;val;</span><br><span class="line">        }</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="3、二叉树总结">3、二叉树总结</h3>
<ul>
<li><strong>二叉搜索树中涉及到跟前后值的，借用<code>pre</code>指向前一个节点</strong></li>
<li><strong>求高度实际是按照层序遍历从底往上求</strong></li>
<li><strong>递归只需要确定函数的参数和返回值以及终止条件，其他的对于二叉树来说基本都是操作左、中、右三个节点，分析清楚操作顺序，直接写即可</strong></li>
<li><strong>递归中的参数可以通过全局变量来代替也可以</strong></li>
<li>使用迭代法同时处理两棵树时，把两个树的节点<code>同时</code>加入队列进行比较</li>
</ul>
<h2 id="回溯算法">回溯算法</h2>
<h3 id="1、回溯算法的理论要点">1、回溯算法的理论要点</h3>
<ul>
<li>何时需要<code>startIndex</code>
<ul>
<li>如果是一个集合求组合的话，需要<code>strtIndex</code></li>
<li>如果是多个集合去组合，各个集合之间相互不影响，不需要<code>startIndex</code></li>
</ul>
</li>
<li><code>for</code>是树层操作，递归是树枝操作</li>
</ul>
<h3 id="2、重点题型-7">2、重点题型</h3>
<ul>
<li>
<h4 id="LC77-组合"><a href="https://leetcode-cn.com/problems/combinations/">LC77.组合</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="comment">// 要把n, k传进来，同时使用startIndex来标记起始位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) {</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) { <span class="comment">// 剪枝操作，保证能够取满K个数</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i); </span><br><span class="line">            <span class="built_in">backtracing</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 纵向递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="built_in">backtracing</span>(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC216-组合总和-III"><a href="https://leetcode-cn.com/problems/combination-sum-iii/">LC216.组合总和 III</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> sum, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) {</span><br><span class="line">            <span class="keyword">if</span> (sum == n) res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>; i++) { <span class="comment">// 剪枝操作</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracing</span>(k, n, sum + i, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) {</span><br><span class="line">        <span class="built_in">backtracing</span>(k, n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC17-电话号码的字母组合"><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">LC17.电话号码的字母组合</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> string letterMap[<span class="number">10</span>] = { <span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>};</span><br><span class="line">    string path; <span class="comment">//</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(<span class="keyword">const</span> string&amp;digits, <span class="keyword">int</span> index)</span> </span>{ <span class="comment">// index标记访问到digits的第几个字符</span></span><br><span class="line">        <span class="keyword">if</span> (index == digits.<span class="built_in">size</span>()) {</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> digit = digits[index] - <span class="string">'0'</span>; <span class="comment">// 表示第index个字符代表的数字</span></span><br><span class="line">        string letters = letterMap[digit];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.<span class="built_in">size</span>(); i++) { <span class="comment">// 横向遍历这一层</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(letters[i]);</span><br><span class="line">            <span class="built_in">backtracing</span>(digits, index + <span class="number">1</span>); </span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">    } </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">backtracing</span>(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC39-组合总和"><a href="https://leetcode-cn.com/problems/combination-sum/">LC39.组合总和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) {</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracing</span>(candidates, target - candidates[i], i); <span class="comment">// 起始位置不变，可以重复使用该元素</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="built_in">backtracing</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC40-组合总和-II"><a href="https://leetcode-cn.com/problems/combination-sum-ii/">LC40.组合总和 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 根据题意知，同一个组合中是可以重复的，但两个组合不能相同</span></span><br><span class="line"><span class="comment">     * 把回溯过程抽象成一棵树，允许树枝重复，但不允许树层重复，对树层去重</span></span><br><span class="line"><span class="comment">     * 对树层去重需要对数组排序</span></span><br><span class="line"><span class="comment">     * used[i] == true 表示同一树枝使用过</span></span><br><span class="line"><span class="comment">     * used[i] == false 表示同一树层使用过</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) {</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; candidates.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; candidates[i - <span class="number">1</span>] == candidates[i] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>; <span class="comment">// 对于同一树层之前有使用过的，本层直接退出</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// 告知本树枝后面的元素可以重复该元素</span></span><br><span class="line">            <span class="built_in">backtracing</span>(candidates, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) {</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracing</span>(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC131-分割回文串"><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">LC131.分割回文串</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    vector&lt;string&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPartion</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ <span class="comment">// 判断回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = r; i &lt; j; i++, j--) {</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 切割问题就是组合问题</span></span><br><span class="line"><span class="comment">     * 字符串的分隔符 == startIndex</span></span><br><span class="line"><span class="comment">     * 当startIndex &gt;= s.size(), 表示切割线已到最后，结束递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> startIndex)</span> </span>{ </span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= s.<span class="built_in">size</span>()) { <span class="comment">// 终止条件</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) { </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isPartion</span>(s, startIndex, i)) path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(startIndex, i - startIndex + <span class="number">1</span>)); </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">traversal</span>(s, i + <span class="number">1</span>); <span class="comment">// 起始位置后移，保证不重复</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) {</span><br><span class="line">        <span class="built_in">traversal</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC93-复原-IP-地址"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">LC93.复原 IP 地址</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(string s, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> pointNum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (pointNum == <span class="number">3</span>) { <span class="comment">// 必须以.为判断依据</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, s.<span class="built_in">size</span>() - <span class="number">1</span>)) res.<span class="built_in">push_back</span>(s); <span class="comment">// 判断第4段是否正确</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(s, startIndex, i)) {</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>, <span class="string">'.'</span>);</span><br><span class="line">                <span class="built_in">backtracing</span>(s, i + <span class="number">2</span>, pointNum + <span class="number">1</span>); <span class="comment">// 由于插入.，下一个startIndex需要从i+2开始</span></span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>); <span class="comment">// 回溯</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> string&amp; s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>{ </span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == <span class="string">'0'</span> &amp;&amp; l != r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) {</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="string">'0'</span> || s[i] &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">255</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="built_in">backtracing</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC78-子集"><a href="https://leetcode-cn.com/problems/subsets/">LC78.子集</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="comment">// 求子集的问题需要把所有的节点的结果记录下来，不像组合的题目需要在叶子节点才记录结果</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path); <span class="comment">// 需要放在终止条件上面</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracing</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">backtracing</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><a href="https://leetcode-cn.com/problems/subsets-ii/">LC90.子集 II </a></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由题意知，需要在上一题的基础上去重，使不同的子集不能重复，子集内的元素可以重复，类似组合去重的思想一样</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">15</span>] ={<span class="number">0</span>};</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        res.<span class="built_in">push_back</span>(path); <span class="comment">// 子集问题需要记录每一个节点的结果</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>; <span class="comment">// 避免树层上出现重复元素，去重 </span></span><br><span class="line">            used[i] = <span class="literal">true</span>; <span class="comment">// 保证树枝上可以出现重复元素</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracing</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); </span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracing</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC491-递增子序列"><a href="https://leetcode-cn.com/problems/increasing-subsequences/">LC491.递增子序列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 本题类似于上一题，但是不能用上一题的方法，此题不能对原数组进行排序</span></span><br><span class="line"><span class="comment">     * 需要使用别的方式给树层去重</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> startIndex)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) res.<span class="built_in">push_back</span>(path); <span class="comment">// 和求子集的一样</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span> ; <span class="comment">// 终止条件</span></span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; uset; <span class="comment">// 按树枝的方向，梅递归一次就要重新初始化uset，这样在同一树枝可以保证可以重复使用元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> ((!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="built_in">back</span>()) || uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) <span class="keyword">continue</span>; <span class="comment">// 如果当前不是增序或者同一层中前面有使用过，直接跳过，对树层进行去重</span></span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]); <span class="comment">// 标记此树层已经使用，同一树层不会被重新初始化，只有换层才会初始化，并且此处后面不用erase，因为每次递归都会重新初始化</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracing</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">backtracing</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC46-全排列"><a href="https://leetcode-cn.com/problems/permutations/">LC46.全排列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> used[<span class="number">10</span>] = {<span class="number">0</span>}; <span class="comment">// 去重数组</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) { <span class="comment">// 终止条件：全排类</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) { <span class="comment">// 每层都是从0开始</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// 如果此层使用过了，后面的就不能使用了</span></span><br><span class="line">            used[i]  = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracing</span>(nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">backtracing</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC47-全排列-II"><a href="https://leetcode-cn.com/problems/permutations-ii/">LC47.全排列 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 在上一题的基础上，在树层上还需要去重,树层去重需要排序</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">10</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="keyword">bool</span> uset[<span class="number">10</span>] = {<span class="number">0</span>};</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracing</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) { <span class="comment">// 终止条件</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) { </span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span> || used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// 树层去重避免选择相同值的不同位置的元素，只有树层方向的遍历有关，不影响树枝的操作，上一个树枝递归结束后used[i - 1] = false，又因为i是按照顺序进行的，说明前面nums[i-1]在本层已经使用过了</span></span><br><span class="line">            <span class="comment">// used[i] == true 树枝避免重复选择某一个位置的元素，只与树枝方向的递归有关</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracing</span>(nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) {</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracing</span>(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC332-重新安排行程"><a href="https://leetcode-cn.com/problems/reconstruct-itinerary/">LC332.重新安排行程</a></h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/2020111518065555.png" alt="332.重新安排行程1"></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, map&lt;string, <span class="keyword">int</span>&gt;&gt; targets; <span class="comment">// map可以满足排序问题</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> ticketsNum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (ticketsNum + <span class="number">1</span> == res.<span class="built_in">size</span>()) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ticket : targets[res[res.<span class="built_in">size</span>() - <span class="number">1</span>]]) {</span><br><span class="line">            <span class="keyword">if</span> (ticket.second &gt; <span class="number">0</span>) {</span><br><span class="line">                res.<span class="built_in">push_back</span>(ticket.first);</span><br><span class="line">                ticket.second -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">backtracking</span>(ticketsNum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                ticket.second += <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">findItinerary</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : tickets) targets[i[<span class="number">0</span>]][i[<span class="number">1</span>]] += <span class="number">1</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(<span class="string">"JFK"</span>);  <span class="comment">// 加入起点</span></span><br><span class="line">        <span class="built_in">backtracking</span>(tickets.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC51-N-皇后"><a href="https://leetcode-cn.com/problems/n-queens/">LC51.N 皇后</a></h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/20210130182532303.jpg" alt="51.N皇后"></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 纵向用递归，横向用遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, vector&lt;string&gt;&amp; path)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (row == n) { <span class="comment">// 终止条件：</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) { <span class="comment">// 每一层都从头遍历，验证是否合适</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isValid</span>(path, row, col, n)) {</span><br><span class="line">                path[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                <span class="built_in">backtracking</span>(n, row + <span class="number">1</span>, path);</span><br><span class="line">                path[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; path, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">// 不需要行检查，因为每一行只会选择一个元素，上一个元素选择完后会回复之前的棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) { <span class="comment">// 列检查</span></span><br><span class="line">            <span class="keyword">if</span> (path[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) { <span class="comment">// 135°方向</span></span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) { <span class="comment">// 45°方向</span></span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) {</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">path</span><span class="params">(n, string(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(n, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC37-解数独"><a href="https://leetcode-cn.com/problems/sudoku-solver/">LC37.解数独</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> k = <span class="string">'1'</span>; k &lt;= <span class="string">'9'</span>; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">isValid</span>(board, i, j, k)) {</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">backtracking</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//  </span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> k)</span> </span>{</span><br><span class="line">        <span class="comment">// 行检查</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (row / <span class="number">3</span> * <span class="number">3</span>), ii = <span class="number">0</span>; ii &lt; <span class="number">3</span>; i++, ii++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (col / <span class="number">3</span> * <span class="number">3</span>), jj = <span class="number">0</span>; jj &lt; <span class="number">3</span>; j++, jj++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>{</span><br><span class="line">        <span class="built_in">backtracking</span>(board);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="贪心算法">贪心算法</h2>
<h3 id="1、重点题型-2">1、重点题型</h3>
<ul>
<li>
<h4 id="LC455-分发饼干"><a href="https://leetcode-cn.com/problems/assign-cookies/">LC455.分发饼干</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 思想：大饼干优先给大胃口的孩子</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 以胃口为基准，找到符合饼干的胃口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; g[i] &lt;= s[j]) {</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                j--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = g.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 以饼干为基础，找到符合饼干的最大胃口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] &lt; g[j]) j--; <span class="comment">// 找到最大的饼干能满足的最大胃口</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC376-摆动序列"><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">LC376.摆动序列</a></h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/20201124174327597.png" alt="376.摆动序列"></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 思想：删除单调坡上的节点 ==&gt;&gt; 只需记录有峰值变化的地方，出现峰值的地方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> preDif = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curDif = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) {</span><br><span class="line">            curDif = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (preDif &lt;= <span class="number">0</span> &amp;&amp; curDif &gt; <span class="number">0</span> || (preDif &gt;= <span class="number">0</span> &amp;&amp; curDif &lt; <span class="number">0</span>)) {</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                preDif = curDif;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC53-最大子数组和"><a href="https://leetcode-cn.com/problems/maximum-subarray/">LC53.最大子数组和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前的sum &lt; 0时，从头开始计数，要不然只会拉低总和	</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum, sum);</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC122-买卖股票的最佳时机-II"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LC122.买卖股票的最佳时机 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 思想：只需记录差值为正值得情况</span></span><br><span class="line"><span class="comment">     * 利益是可以拆解的，prices[3] - prices[0] = prices[3] - prices[2] + prices[2] - prices[1] + prices[1] - prices[0]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (prices[i + <span class="number">1</span>] - prices[i] &gt; <span class="number">0</span>) {</span><br><span class="line">                sum += prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC55-跳跃游戏"><a href="https://leetcode-cn.com/problems/jump-game/">LC55.跳跃游戏</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 处理特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 只需求能够跳跃的最远距离是否会覆盖掉终点，不用追求每次跳几步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxIndex; i++) {</span><br><span class="line">            <span class="keyword">if</span> (maxIndex &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            maxIndex = <span class="built_in">max</span>(i + nums[i], maxIndex);  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC45-跳跃游戏-II"><a href="https://leetcode-cn.com/problems/jump-game-ii/">LC45.跳跃游戏 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> curDis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nextDis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 从前往后遍历，只要是当前位置的最远距离能覆盖终点，就结束查找</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) {</span><br><span class="line">            nextDis = <span class="built_in">max</span>(nextDis, nums[i] + i);</span><br><span class="line">            <span class="keyword">if</span> (i == curDis) { <span class="comment">// 遍历到当前最远覆盖位置</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) { <span class="comment">// 如果没有覆盖终点的话，就需要增加一步</span></span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    curDis = nextDis;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> curDis = <span class="number">0</span>, nextDis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 把所有的元素都遍历一遍，肯定能覆盖终点，一步确定能最远的距离，每次到达最远覆盖位置就要增加一步</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) {</span><br><span class="line">            nextDis = <span class="built_in">max</span>(nums[i] + i, nextDis);</span><br><span class="line">            <span class="keyword">if</span> (i == curDis) {</span><br><span class="line">                curDis = nextDis;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC1005-K-次取反后最大化的数组和"><a href="https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/">LC1005.K 次取反后最大化的数组和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(a) &lt; <span class="built_in">abs</span>(b);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) {</span><br><span class="line">                nums[i] *= <span class="number">-1</span>;</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            } </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) nums[<span class="number">0</span>] *= <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC134-加油站"><a href="https://leetcode-cn.com/problems/gas-station/">LC134.加油站</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; gas, vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 情况1：总油都不够用</span></span><br><span class="line"><span class="comment">         * 情况2：最小剩余油量都是大于0的，起始位置就是0</span></span><br><span class="line"><span class="comment">         * 情况3：最小剩余油量小于0，从后往前找能够填补掉min的位置，因为总量是够用的，前面缺油后面肯定剩油，并且剩的油肯定能填补前面缺少的油</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minRest = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">int</span> rest = gas[i] - cost[i];</span><br><span class="line">            curSum += rest;</span><br><span class="line">            minRest = <span class="built_in">min</span>(curSum, minRest);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (minRest &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gas.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            minRest += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (minRest &gt;= <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; gas, vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 从局部最优出发，如果当前油的总剩余量&lt;0，说明当前位置和之前的所有位置都是不能用的，只能从下一个位置重新开始</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>, totalSum = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">int</span> rest = gas[i] - cost[i];</span><br><span class="line">            totalSum += rest;</span><br><span class="line">            curSum += rest;</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) {</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                index = i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC135-分发糖果"><a href="https://leetcode-cn.com/problems/candy/">LC135.分发糖果</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</span></span><br><span class="line"><span class="comment">         * 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">candies</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) candies[i] = candies[i - <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 从左往右遍历，只能改变右边的糖果，否则后面改变了，前面也改变不了</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) candies[i] = <span class="built_in">max</span>(candies[i + <span class="number">1</span>] + <span class="number">1</span>, candies[i]); <span class="comment">// 从右往左遍历，只能改变左边的糖果</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : candies) sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC860-柠檬水找零"><a href="https://leetcode-cn.com/problems/lemonade-change/">LC860.柠檬水找零</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 情况一：账单是5，直接收下</span></span><br><span class="line"><span class="comment">		 * 情况二：账单是10，消耗一个5，增加一个10</span></span><br><span class="line"><span class="comment">		 * 情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> cntFive = <span class="number">0</span>, cntTen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bills.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) cntFive += <span class="number">1</span>; <span class="comment">// 账单是5，直接收下</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) { <span class="comment">// 账单是10，消耗一个5，增加一个10</span></span><br><span class="line">                <span class="keyword">if</span> (cntFive &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cntFive -= <span class="number">1</span>;</span><br><span class="line">                cntTen += <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">20</span>) { <span class="comment">// 账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</span></span><br><span class="line">                <span class="keyword">if</span> (cntTen &gt;= <span class="number">1</span> &amp;&amp; cntFive &gt;= <span class="number">1</span>) {</span><br><span class="line">                    cntFive -= <span class="number">1</span>;</span><br><span class="line">                    cntTen -= <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (cntFive &gt;= <span class="number">3</span>) {</span><br><span class="line">                    cntFive -= <span class="number">3</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC406-根据身高重建队列"><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">LC406.根据身高重建队列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; people) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 两个维度：身高和属性</span></span><br><span class="line"><span class="comment">         * 思路：每次只处理一个维度</span></span><br><span class="line"><span class="comment">         * 步骤：先处理身高，按照身高由高向低排序，相同身高的按照属性由低向高排序，因为身高高的受其他的影响小，先固定升高高的，属性越少证明前面越靠前</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; people.<span class="built_in">size</span>(); i++) { <span class="comment">// 从前往后遍历，依次按照属性插入</span></span><br><span class="line">            que.<span class="built_in">insert</span>(que.<span class="built_in">begin</span>() + people[i][<span class="number">1</span>], people[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> que;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC452-用最少数量的箭引爆气球"><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">LC452.用最少数量的箭引爆气球</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>{</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curMax = points[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// curMax是同一支箭射下来所经过的气球的最短直径，也就代表箭的最右边的位置，如果有气球的直径起始位置在箭能发射的最右边的位置还要靠右，就需要重新一支箭了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (curMax &lt; points[i][<span class="number">0</span>]) { <span class="comment">// </span></span><br><span class="line">                curMax = points[i][<span class="number">1</span>];</span><br><span class="line">                count += <span class="number">1</span>; </span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (curMax &gt; points[i][<span class="number">1</span>]) curMax = points[i][<span class="number">1</span>]; <span class="comment">// curMax不断更新同</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC435-无重叠区间"><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">LC435.无重叠区间</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 排序：按照右边界排序，右边界越小，后面的可选区间就越大，才能保证移除的区间数量最少</span></span><br><span class="line"><span class="comment">         * 遍历方向：从左往右</span></span><br><span class="line"><span class="comment">         * 通过求最大非重复区间个数来求</span></span><br><span class="line"><span class="comment">       	 * 需要分割点来做标记</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>]; <span class="comment">// end作为分割点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (end &lt;= intervals[i][<span class="number">0</span>]) { </span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>]; <span class="comment">// 此处越远更新end，代表end越小，对于后面的区间越有利</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> intervals.<span class="built_in">size</span>() - count;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC763-划分字母区间"><a href="https://leetcode-cn.com/problems/partition-labels/">LC763.划分字母区间</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：提前处理字符串，记录每个字母最后出现的位置</span></span><br><span class="line"><span class="comment">         * 标记：使用right用来标记当前遍历过的所有元素的最远位置，当遍历到最远位置right时就可以作为一个分段</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> hash[<span class="number">30</span>] = {<span class="number">0</span>};</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) hash[s[i] - <span class="string">'a'</span>] = i; <span class="comment">//记录每个元素出现的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) { </span><br><span class="line">            right = <span class="built_in">max</span>(right, hash[s[i] - <span class="string">'a'</span>]); <span class="comment">//记录最远位置</span></span><br><span class="line">            <span class="keyword">if</span> (i == right) { <span class="comment">// 遍历到最远位置就就行分段</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(i - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC56-合并区间"><a href="https://leetcode-cn.com/problems/merge-intervals/">LC56.合并区间</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals) {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：按照左边界排序，这样就可以确定起点，然后比对下一个区间的开始和上一个区间的结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 记录最后一个区间是否合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">int</span> start = intervals[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> end = intervals[i - <span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 根据下一个区间更新终点</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; intervals.<span class="built_in">size</span>() &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= end) {</span><br><span class="line">                end = <span class="built_in">max</span>(end, intervals[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (i == intervals.<span class="built_in">size</span>() - <span class="number">1</span>) flag = <span class="literal">true</span>; <span class="comment">// 说明最后一个区间被合并了</span></span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;{start, end});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) {</span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;{intervals.<span class="built_in">back</span>()[<span class="number">0</span>], intervals.<span class="built_in">back</span>()[<span class="number">1</span>]});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC738-单调递增的数字"><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">LC738.单调递增的数字</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：从后往前遍历，如果strNum[i - 1] &gt; strNUm[i]，strNum[i - 1] -= 1，同时strNum[i]及其之后所有的位数都可以变为9，用flag记录最左边的9位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        string strNum = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="keyword">int</span> flag = strNum.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = strNum.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) {</span><br><span class="line">            <span class="keyword">if</span> (strNum[i - <span class="number">1</span>] &gt; strNum[i]) {</span><br><span class="line">                strNum[i - <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">                flag = i; <span class="comment">// 记录最左边9的位置</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = flag; i &lt; strNum.<span class="built_in">size</span>(); i++) strNum[i] = <span class="string">'9'</span>; <span class="comment">// 把flag之后的所有位置换为9</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(strNum);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC714-买卖股票的最佳时机含手续费"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LC714.买卖股票的最佳时机含手续费</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 情况一：收获利润的这一天并不是收获利润区间里的最后一天（不是真正的卖出，相当于持有股票），所以后面要继续收获利润</span></span><br><span class="line"><span class="comment">         * 情况二：前一天是收获利润区间里的最后一天（相当于真正的卖出了），今天要重新记录最小价格</span></span><br><span class="line"><span class="comment">         * 情况三：不作操作，保持原有状态（买入，卖出，不买不卖）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (minPrice &gt; prices[i]) minPrice = prices[i]; <span class="comment">// 情况二：</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt;= minPrice &amp;&amp; prices[i] &lt;= minPrice + fee) <span class="keyword">continue</span>; <span class="comment">// 情况三：只有有利润了，才卖出</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; minPrice + fee) { <span class="comment">// 情况一</span></span><br><span class="line">                res += prices[i] - minPrice - fee;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 1、如果minPrice不改变，就是连续收益，此时fee只要第一次时扣除，直到真正卖出为止</span></span><br><span class="line"><span class="comment">                 * 2、如果minPrice改变，情况二中，因为是重新买股票，需要手续费，由minPrice &gt; Prices[i] ==&gt;&gt; prices[i] - minPrice - fee &lt; prices[i] - minPrice' - fee ==&gt;&gt; 此时利润会更大</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                minPrice = prices[i] - fee; <span class="comment">// 下一次算利润时就可以不算手续费</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC968-监控二叉树"><a href="https://leetcode-cn.com/problems/binary-tree-cameras/">LC968.监控二叉树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 思路：摄像头不能放在叶子节点，需要放在树的中间层，才能保证摄像头数量最少</span></span><br><span class="line"><span class="comment">     * 遍历方式：后续遍历</span></span><br><span class="line"><span class="comment">     * 转移方式：一个接节点只有3种状态：0代表无覆盖，1代表有摄像头，2代表有覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 空节点假定为有覆盖2，同时它的兄弟节点也是2，这样它的父节点就不用放摄像头，否则像叶子节点要放摄像头</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="built_in">traversal</span>(root-&gt;left); <span class="comment">// 后序遍历：左</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">traversal</span>(root-&gt;right); <span class="comment">// 后序遍历：右</span></span><br><span class="line">		<span class="comment">// 后序遍历：中</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 情况一：左右孩子都有覆盖，该节点不需要放摄像头，可以通过该节点的父节点放摄像头来覆盖本节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) { <span class="comment">// 情况二：左右节点有一个无覆盖，需要在该节点放摄像头</span></span><br><span class="line">            result += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span> || right == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 情况三：左右节点有摄像头，该节点就是有覆盖</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">traversal</span>(root) == <span class="number">0</span>) result += <span class="number">1</span>; <span class="comment">// 情况四：特殊处理头节点</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="动态规划">动态规划</h2>
<h3 id="1、动态规划的理论要点">1、动态规划的理论要点</h3>
<ul>
<li>动态规划的解题步骤：
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
</li>
<li>背包类型划分：<img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/20210117171307407.png" alt="416.分割等和子集1"></li>
</ul>
<h3 id="2、重点题型-8">2、重点题型</h3>
<ul>
<li>
<h4 id="LC509-斐波那契数"><a href="https://leetcode-cn.com/problems/fibonacci-number/">LC509.斐波那契数</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、dp[i]：当前值的斐波那契数值</span></span><br><span class="line"><span class="comment">         * 2、dp[i] = dp[i - 1] + dp[i - 2]</span></span><br><span class="line"><span class="comment">         * 3、由递推公式得知需初始化dp[0] dp[1]</span></span><br><span class="line"><span class="comment">         * 4、有递推公式知从前往后遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) {</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC70-爬楼梯"><a href="https://leetcode-cn.com/problems/climbing-stairs/">LC70.爬楼梯</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、dp[i]：到达当前台阶的方法数量</span></span><br><span class="line"><span class="comment">         * 2、dp[i] = dp[i - 1] + dp[i - 2] ：上一个台阶和上上个台阶的方法数量决定</span></span><br><span class="line"><span class="comment">         * 3、由递推公式得知需初始化dp[1] dp[2]，dp[0]无意义</span></span><br><span class="line"><span class="comment">         * 4、有递推公式知从前往后遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC746-使用最小花费爬楼梯"><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">LC746.使用最小花费爬楼梯</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、dp[i]：只要往上爬，就需要消耗体力，第一步就需要消耗体力，到达i台阶的最小代价</span></span><br><span class="line"><span class="comment">         * 2、dp[i] = dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])：上一个台阶和上上个台阶的到达本台阶的最小代价</span></span><br><span class="line"><span class="comment">         * 3、由递推公式得知需初始化dp[0] dp[1]</span></span><br><span class="line"><span class="comment">         * 4、有递推公式知从前往后遍历</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span>  dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC62-不同路径"><a href="https://leetcode-cn.com/problems/unique-paths/">LC62.不同路径</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、dp[i][j]：到达[i,j]位置的路径总量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化：只能向下移动，只有一种方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>; <span class="comment">// 初始化：只能向右移动，只有一种方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]; <span class="comment">// 递推公式</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC63-不同路径-II"><a href="https://leetcode-cn.com/problems/unique-paths-ii/">LC63.不同路径 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、dp[i][j]：到达[i,j]位置的路径总量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 初始化：只能向下移动，只有一种方法，如果遇到障碍，下面的都到达不了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span>; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>; <span class="comment">// 初始化：只能向右移动，只有一种方法，如果遇到障碍，右面的都到达不了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 遇到障碍，保持0，说明从此方向的路径总量为0</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC343-整数拆分"><a href="https://leetcode-cn.com/problems/integer-break/">LC343.整数拆分</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、dp[i]：拆分i可以获得的最大乘积</span></span><br><span class="line"><span class="comment">         * 2、dp[i]主要来源是dp[i - j] * j或(i - j) * j，(i - j) * j说明把i分解为两个数，dp[i - j] * j说明把i分解为多个数，dp[i - j]在前面遍历中已经确定</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) {</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(dp[i - j] * j, (i - j) * j)); <span class="comment">// 在指定不同的j时，对应dp[i]也不同，需要max(dp[i],  )</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC96-不同的二叉搜索树"><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">LC96.不同的二叉搜索树</a></h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/20210107093226241.png" alt="96.不同的二叉搜索树2"></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、dp[i]：1到i为节点组成二叉树搜索树的个数</span></span><br><span class="line"><span class="comment">         * 2、dp[i] += dp[j - 1] * dp[i - j]：以不同值为头节点的情况总和，看上图</span></span><br><span class="line"><span class="comment">         * 3、dp[0] = 1，由递推公式知，只需要初始化dp[0]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) {</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC416-分割等和子集"><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">LC416.分割等和子集</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 由题意知，只需判断是否存在某几个数之和恰好为总和的一半，可以使用0-1背包，以和为背包容量，每个数代表物品，数的大小代表物品的价值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) sum += i;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 特殊判断</span></span><br><span class="line">        target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= nums[i]; j--) {</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC1049-最后一块石头的重量-II"><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">LC1049.最后一块石头的重量 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 由题意知，只要划分为相等两组时，此时结果才会最小，可以使用0-1背包，和为背包容量，石头为物品，石头的大小为价值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : stones) sum += i;</span><br><span class="line">        target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; j &gt;= stones[i]; j--) {</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum - dp[target] - dp[target]; <span class="comment">// 由于target是下取整，sum - dp[target] &gt;= dp[target]</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC494-目标和"><a href="https://leetcode-cn.com/problems/target-sum/">LC494.目标和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：a = b + target ==&gt;&gt; a + a = a + b + target ==&gt;&gt; a = (a + b + target) / 2</span></span><br><span class="line"><span class="comment">         * 判断nums中有哪几种组合可以组合出(a + b + target) / 2的情况</span></span><br><span class="line"><span class="comment">         * dp[j]: 当前容量下，最多有几种方法</span></span><br><span class="line"><span class="comment">         * dp[j] += dp[j - nums[i]]: 背包解决排列组合问题的通用递推公式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, bagCol = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : nums) sum += i;</span><br><span class="line">        <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="built_in">abs</span>(target)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 特殊情况</span></span><br><span class="line">        bagCol = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(bagCol + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = bagCol; j &gt;= nums[i]; j--) {</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[bagCol];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC474-一和零"><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">LC474.一和零</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;str : strs) {</span><br><span class="line">            <span class="keyword">int</span> zeroNum = <span class="number">0</span>, oneNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ch : str) {</span><br><span class="line">                <span class="keyword">if</span> (ch == <span class="string">'0'</span>) zeroNum += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> oneNum += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= zeroNum; i--) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= oneNum; j--) {</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC518-零钱兑换-II"><a href="https://leetcode-cn.com/problems/coin-change-2/">LC518.零钱兑换 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 组合问题的完全背包需要先遍历物品，这样可以保证同一背包下不会出现重复情况，组合是没有顺序的</span></span><br><span class="line"><span class="comment">         * 排列问题的完全背包需要先遍历背包，这样可以保证排列出所有的情况，排列是有顺序的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) {</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC377-组合总和-Ⅳ"><a href="https://leetcode-cn.com/problems/combination-sum-iv/">LC377. 组合总和 Ⅳ</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 组合问题的完全背包需要先遍历物品，这样可以保证同一背包下不会出现重复情况，组合是没有顺序的</span></span><br><span class="line"><span class="comment">         * 排列问题的完全背包需要先遍历背包，这样可以保证排列出所有的情况，排列是有顺序的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= target; i++) { <span class="comment">// 此题是排列问题</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                 <span class="comment">// 此处需要注意：答案保证最终答案的组合数在32位范围内，但是如果在taraget之前的数字组合数是可能超过INT_MAX的，甚至更大，但因为最终答案不会超过，所以target肯定不会利用到这些超过INT_MAX的数据的，所以忽略掉那些会超过INT_MAX的就可以</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt;= nums[j] &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) dp[i] += dp[i - nums[j]];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC322-零钱兑换"><a href="https://leetcode-cn.com/problems/coin-change/">LC322.零钱兑换</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) {</span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != INT_MAX) <span class="comment">// 避免整形溢出 </span></span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC279-完全平方数"><a href="https://leetcode-cn.com/problems/perfect-squares/">LC279.完全平方数</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i * i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (dp[j - i * i] != INT_MAX) dp[j] = <span class="built_in">min</span>(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC139-单词拆分"><a href="https://leetcode-cn.com/problems/word-break/">LC139.单词拆分</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i]: 字符串s从0到i位置是否是wordDict的子集</span></span><br><span class="line"><span class="comment">         * 背包: 字符串</span></span><br><span class="line"><span class="comment">         * 物品: 单词</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 需要先遍历背包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                string word = s.<span class="built_in">substr</span>(j, i - j);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.<span class="built_in">find</span>(word) != wordSet.<span class="built_in">end</span>() &amp;&amp; dp[j]) <span class="comment">// dp[j]</span></span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC198-打家劫舍"><a href="https://leetcode-cn.com/problems/house-robber/">LC198.打家劫舍</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]; <span class="comment">// dp[i - 2]，这里需要单独判断</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC213-打家劫舍-II"><a href="https://leetcode-cn.com/problems/house-robber-ii/">LC213. 打家劫舍 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 拆分为不包含头或不包含尾两种情况的打家劫舍I的问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="built_in">robRange</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>); <span class="comment">// 不包含尾</span></span><br><span class="line">        <span class="keyword">int</span> res2 = <span class="built_in">robRange</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>()); <span class="comment">// 不包含头</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">robRange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (end == start + <span class="number">1</span>) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(end - start + <span class="number">1</span>)</span></span>; <span class="comment">// 这里不能是end - start，对于[1, nums.size()]来说，dp[i]是从下标1开始的</span></span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt; end; i++) {</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[end - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC337-打家劫舍-III"><a href="https://leetcode-cn.com/problems/house-robber-iii/">LC337.打家劫舍 III </a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 此题为树形dp，此题需要后序遍历，dp[2]用来记录每个节点偷与不偷的情况，使用后序遍历从底层将结果逐层向上递归传递vector&lt;int&gt; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res = <span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 下标0代表不偷的情况，下标1代表偷的情况</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode *root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;{<span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; left = <span class="built_in">robTree</span>(root-&gt;left); <span class="comment">// 遍历左子树</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; right = <span class="built_in">robTree</span>(root-&gt;right); <span class="comment">// 遍历右子树</span></span><br><span class="line">        <span class="keyword">int</span> val1 = root-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>]; <span class="comment">// 偷</span></span><br><span class="line">        <span class="keyword">int</span> val2 = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]); <span class="comment">// 不偷</span></span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;{val2, val1}; </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC121-买卖股票的最佳时机"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">LC121.买卖股票的最佳时机</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划：</span></span><br><span class="line"><span class="comment">     * 现金从最开始为0，买入股票现金为-prices[i]，卖出股票现金为所得利润</span></span><br><span class="line"><span class="comment">     * dp[i][0]：持有股票，所得的现金</span></span><br><span class="line"><span class="comment">     *	 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</span></span><br><span class="line"><span class="comment">     *   第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]</span></span><br><span class="line"><span class="comment">     * dp[i][1]：不持有股票，所得的现金</span></span><br><span class="line"><span class="comment">     *   第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</span></span><br><span class="line"><span class="comment">     *   第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0] </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]); <span class="comment">// 0代表持有股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]); <span class="comment">// 1代表不持有股票</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 最后肯定是不持有股票</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 贪心算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> low = INT_MAX, maxPro = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            low = <span class="built_in">min</span>(low, prices[i]); <span class="comment">// 记录最左边的最小值</span></span><br><span class="line">            maxPro = <span class="built_in">max</span>(maxPro, prices[i] - low);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxPro;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC122-买卖股票的最佳时机-II-2"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">LC122.买卖股票的最佳时机 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：动态规划，dp[i][0]持有股票，dp[i][1]不持有股票</span></span><br><span class="line"><span class="comment">         * 递推公式：</span></span><br><span class="line"><span class="comment">         * dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])</span></span><br><span class="line"><span class="comment">         *   第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]</span></span><br><span class="line"><span class="comment">         *	 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]  </span></span><br><span class="line"><span class="comment">         * dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])</span></span><br><span class="line"><span class="comment">         *	 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]</span></span><br><span class="line"><span class="comment">         *	 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>] ; <span class="comment">// 持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 不持有股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC123-买卖股票的最佳时机-III"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">LC123.买卖股票的最佳时机 III</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1、确定dp数组以及下标的含义：一天一共就有五个状态， 0. 没有操作</span></span><br><span class="line"><span class="comment">		 *			第一次买入</span></span><br><span class="line"><span class="comment">		 *			第一次卖出</span></span><br><span class="line"><span class="comment">		 *			第二次买入</span></span><br><span class="line"><span class="comment">		 *			第二次卖出</span></span><br><span class="line"><span class="comment">		 *		dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。</span></span><br><span class="line"><span class="comment">		 * 2、递推公式：</span></span><br><span class="line"><span class="comment">		 *	  dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1])</span></span><br><span class="line"><span class="comment">		 *		操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]</span></span><br><span class="line"><span class="comment">		 *		操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]</span></span><br><span class="line"><span class="comment">		 *	  dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])</span></span><br><span class="line"><span class="comment">		 *		操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]</span></span><br><span class="line"><span class="comment">		 *		操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// dp[i][0] = dp[i - 1][0]; // 没有操作，就不考虑此处是否</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span> - prices[i]); <span class="comment">// 因为是第一次买入股票，所以前面的dp[i][0] = 0，当前的现金是0 - prices[i]</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC188-买卖股票的最佳时机-IV"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">LC188.买卖股票的最佳时机 IV</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 延续买卖股票的最佳时机III的思路</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span> * k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * k; i += <span class="number">2</span>) dp[<span class="number">0</span>][i] -= prices[<span class="number">0</span>]; <span class="comment">// 只有买入时需要考虑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) { </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) { <span class="comment">// j的位置</span></span><br><span class="line">                <span class="comment">// 不需要考虑dp[i][0]的情况，dp[i][0]至对于dp[i][1]有影响，而dp[i][1]表示第一次买入，相对应的dp[i][0]肯定为0，啥操作也没有</span></span><br><span class="line">                dp[i][j + <span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]); <span class="comment">// 奇数就是买入的情况</span></span><br><span class="line">                dp[i][j + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]); <span class="comment">// 偶数就是卖出的情况</span></span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC309-最佳买卖股票时机含冷冻期"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">LC309.最佳买卖股票时机含冷冻期</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i][j]: 第i天状态为j，所剩的最多现金为dp[i][j]</span></span><br><span class="line"><span class="comment">         *      状态一 0：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</span></span><br><span class="line"><span class="comment">         *      卖出股票状态，这里就有两种卖出股票状态</span></span><br><span class="line"><span class="comment">         *         状态二 1：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</span></span><br><span class="line"><span class="comment">         *         状态三 2：今天卖出了股票</span></span><br><span class="line"><span class="comment">         *      状态四 3：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 递推公式：</span></span><br><span class="line"><span class="comment">             * 1、达到买入的状态: dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i])</span></span><br><span class="line"><span class="comment">             *      操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0]</span></span><br><span class="line"><span class="comment">             *      操作二：今天买入了，有两种情况</span></span><br><span class="line"><span class="comment">             *          前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]</span></span><br><span class="line"><span class="comment">             *          前一天是"保持"卖出股票状态（状态二），dp[i - 1][1] - prices[i]</span></span><br><span class="line"><span class="comment">             * 2、达到"保持"卖出的状态：dp[i][1] = max(dp[i - 1][1], dp[i - 1][4])</span></span><br><span class="line"><span class="comment">             *      操作一：前一天就是状态二</span></span><br><span class="line"><span class="comment">             *      操作二：前一天是冷冻期（状态四）</span></span><br><span class="line"><span class="comment">             * 3、达到今天就卖出的状态：dp[i][2] = dp[i - 1][0] + prices[i]</span></span><br><span class="line"><span class="comment">             *      操作一：昨天一定是买入股票状态（状态一），今天卖出</span></span><br><span class="line"><span class="comment">             * 4、达到冷冻期状态: dp[i][3] = dp[i - 1][2]</span></span><br><span class="line"><span class="comment">             *      操作一：昨天卖出了股票（状态三）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]) - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>], <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">2</span>], dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC714-买卖股票的最佳时机含手续费-2"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">LC714.买卖股票的最佳时机含手续费</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：买卖股票的最佳时机 II的基础上，只需要在卖出时减去fee</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>] ; <span class="comment">// 持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 不持有股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC300-最长递增子序列"><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">LC300.最长递增子序列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i]：i之前包括i的最长上升子序列的长度</span></span><br><span class="line"><span class="comment">         * 递推公式：dp[i] = max(dp[i], dp[j] + 1)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) { <span class="comment">// 通过j去更新dp[i]</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            result = <span class="built_in">max</span>(dp[i], result); <span class="comment">// 记录中间最大值</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC674-最长连续递增序列"><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">LC674.最长连续递增序列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i]：以下标i为结尾的数组的连续递增子序列长度</span></span><br><span class="line"><span class="comment">         * dp[i] = dp[i - 1] + 1 或者 dp[i] = 1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            result = <span class="built_in">max</span>(dp[i], result);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC718-最长重复子数组"><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">LC718.最长重复子数组</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i][j]：以下标i-1为结尾的nums1，和以下标j-1为结尾的nums2，最长重复子数组的长度</span></span><br><span class="line"><span class="comment">         * 如果dp[i][j]表示以下标i为结尾的nums1，和以下标j为结尾的nums2，最长重复子数组的长度的话，对于最后一个元素是无法记录下来的         </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++) { <span class="comment">// &lt;=</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="built_in">size</span>(); j++) { <span class="comment">// &lt;= 这样才能统计到最后一个元素是否重复的情况</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i <span class="number">-1</span>] == nums2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[i][j]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC1143-最长公共子序列"><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">LC1143.最长公共子序列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意区分子数组和子序列：</p>
<ul>
<li>子数组：连续的元素</li>
<li>子序列：只是元素顺序和原数组的顺序相同，但可以不连续</li>
</ul>
</blockquote>
</li>
<li>
<h4 id="LC1035-不相交的线"><a href="https://leetcode-cn.com/problems/uncrossed-lines/">LC1035.不相交的线</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; text1, vector&lt;<span class="keyword">int</span>&gt;&amp; text2)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度</span></span><br><span class="line"><span class="comment">         * dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(text2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC53-最大子数组和-2"><a href="https://leetcode-cn.com/problems/maximum-subarray/">LC53.最大子数组和</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="comment">// dp[i]：包括下标i之前的最大连续子序列和为dp[i]</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> result = dp[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC392-判断子序列"><a href="https://leetcode-cn.com/problems/is-subsequence/">LC392.判断子序列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 思路：和最长重复子数组的思路是一样的，寻找连续公共的部分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i- <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">1</span>]; <span class="comment">// 不等时，需要删除t串中的当前元素</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC115-不同的子序列"><a href="https://leetcode-cn.com/problems/distinct-subsequences/">LC115.不同的子序列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j] &lt;&lt;&lt;&lt;这是一个连续的问题，不管i这个位置有没有和j这个位置匹配，最少可以保持i-1位置上的个数&gt;&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(t.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 根据推导公式得出，需要初始化的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * s[i - 1] == t[j - 1]的情况：包括两种情况</span></span><br><span class="line"><span class="comment">                 * 		1、一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">                 *		2、一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。</span></span><br><span class="line"><span class="comment">                 *	这两种情况不会出现重叠的部分，比如s：bagg 和 t：bag</span></span><br><span class="line"><span class="comment">                 *		s[2] == t[2]: 此时dp[i][j] = dp[i - 1][j - 1]的情况，考虑的是a这个位置的个数情况</span></span><br><span class="line"><span class="comment">                 *		s[3] == t[2]: 此时dp[i][j] = dp[i - 1][j]的情况，在i-2结尾的情况，已经匹配到j-1这个位置的个数情况</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) { </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC583-两个字符串的删除操作"><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">LC583.两个字符串的删除操作</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * word1[i - 1] == word2[j - 1]的情况：如果相等就不需要删除任何元素</span></span><br><span class="line"><span class="comment">                 * word1[i - 1] != word2[j - 1]的情况：</span></span><br><span class="line"><span class="comment">                 *		1、需要删除word1[i - 1]时：dp[i][j] = dp[i - 1][j] + 1</span></span><br><span class="line"><span class="comment">                 *		2、需要删除word2[j - 1]时：dp[i][j] = dp[i][j - 1] + 1</span></span><br><span class="line"><span class="comment">                 *		3、需要删除word1[i - 1]和word2[j - 1]时：dp[i][j] = dp[i - 1][j - 1] + 2</span></span><br><span class="line"><span class="comment">                 *		取这三种情况的最小值</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC72-编辑距离"><a href="https://leetcode-cn.com/problems/edit-distance/">LC72.编辑距离</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i][j]：以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) dp[i][<span class="number">0</span>] = i; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) dp[<span class="number">0</span>][j] = j; <span class="comment">// 此时需要在word1中执行插入操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 1、如果word1[i - 1] == word2[j - 1]，则什么也不用做dp[i][j] = dp[i - 1][j - 1]</span></span><br><span class="line"><span class="comment">                 * 2、如果word1[i - 1] != word2[j - 1]，则有三种情况：</span></span><br><span class="line"><span class="comment">                 *		1、删除word1[i - 1]，则dp[i][j] = dp[i - 1][j] + 1</span></span><br><span class="line"><span class="comment">                 *		2、插入word1[i - 1]，就相当于删除word2[j - 1]，两者操作次数是相等的，则dp[i][j] = dp[i][j - 1] + 1</span></span><br><span class="line"><span class="comment">                 *		3、替换word1[i - 1]，则dp[i][j] = dp[i - 1][j - 1] + 1</span></span><br><span class="line"><span class="comment">                 *	  取三种情况中的最小值，就是最小操作次数</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC647-回文子串"><a href="https://leetcode-cn.com/problems/palindromic-substrings/">LC647.回文子串</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="comment">// dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 遍历顺序：会用到没有计算过的dp[i + 1][j - 1]，也就是根据不确定是不是回文的区间[i+1,j-1]，来判断了[i,j]是不是回文，所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 1、当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false</span></span><br><span class="line"><span class="comment">                 * 2、当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</span></span><br><span class="line"><span class="comment">                 * 		情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</span></span><br><span class="line"><span class="comment">                 *		情况二：下标i 与 j相差为1，例如aa，也是文子串</span></span><br><span class="line"><span class="comment">                 *		情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) {</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) {</span><br><span class="line">                        result += <span class="number">1</span>;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) {</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        result += <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC516-最长回文子序列"><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">LC516.最长回文子序列</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), vector&lt;<span class="keyword">int</span>&gt;(s.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]是依赖于dp[i + 1][j - 1] 和 dp[i + 1][j]，遍历i的时候一定要从下到上遍历，这样才能保证，下一行的数据是经过计算的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) {</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 1、如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2</span></span><br><span class="line"><span class="comment">                 * 2、如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列，dp[i][j]一定是取最大的</span></span><br><span class="line"><span class="comment">                 *		加入s[j]的回文子序列长度为dp[i + 1][j]</span></span><br><span class="line"><span class="comment">                 *		加入s[i]的回文子序列长度为dp[i][j - 1]</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="深度搜索与广度搜索">深度搜索与广度搜索</h2>
<h3 id="1、深搜与广搜的理论要点">1、深搜与广搜的理论要点</h3>
<h3 id="2、重点题型-9">2、重点题型</h3>
<ul>
<li>
<h4 id="HZOJ535-瓷砖"><a href="http://oj.haizeix.com/problem/535">HZOJ535.瓷砖</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>}; <span class="comment">// 对应上下左右四个方向</span></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy, ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="comment">// 深搜就是递归，沿着一条路径一直递归下去</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) { <span class="comment">// 遍历当前位置的每一个方向上的下一个位置</span></span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'.'</span>) { <span class="comment">// 遇到黑色瓷砖</span></span><br><span class="line">            mmap[xx][yy] = <span class="string">'0'</span>; <span class="comment">// 标记已经计算过该位置，防止重复记录</span></span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">func</span>(xx, yy); <span class="comment">// 递归下一个位置</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'@'</span>) { <span class="comment">// 记录起点信息</span></span><br><span class="line">                sx = i;</span><br><span class="line">                sy = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">func</span>(sx, sy);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ397-僵尸来袭"><a href="http://oj.haizeix.com/problem/397">HZOJ397.僵尸来袭</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> m, n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] != <span class="number">0</span>) {</span><br><span class="line">            mmap[xx][yy] = <span class="number">0</span>; <span class="comment">// 将一波僵尸全部置为0</span></span><br><span class="line">            <span class="built_in">func</span>(xx, yy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] != <span class="number">0</span>) { </span><br><span class="line">                ans += <span class="number">1</span>; <span class="comment">// 一波将是算一次</span></span><br><span class="line">                mmap[i][j] = <span class="number">0</span>; <span class="comment">// 深搜整个一波僵尸</span></span><br><span class="line">                <span class="built_in">func</span>(i, j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ536-最大黑色区域"><a href="http://oj.haizeix.com/problem/536">HZOJ536.最大黑色区域</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> temp, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'1'</span>) {</span><br><span class="line">            temp += <span class="number">1</span>;</span><br><span class="line">            mmap[xx][yy] = <span class="string">'0'</span>;</span><br><span class="line">            <span class="built_in">func</span>(xx, yy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                mmap[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">func</span>(i, j);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, temp);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC200-岛屿数量"><a href="https://leetcode-cn.com/problems/number-of-islands/">LC200.岛屿数量</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, n, m;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt; &amp;mmap)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx == n || yy == m) <span class="keyword">continue</span>; <span class="comment">// 考虑边界问题</span></span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'1'</span>) {</span><br><span class="line">                mmap[xx][yy] = <span class="string">'0'</span>;</span><br><span class="line">                <span class="built_in">func</span>(xx, yy, mmap);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        n = grid.<span class="built_in">size</span>();</span><br><span class="line">        m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) {</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">                    <span class="built_in">func</span>(i, j, grid);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ406-水坑数量"><a href="http://oj.haizeix.com/problem/406">HZOJ406.水坑数量</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, ans;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'#'</span>) {</span><br><span class="line">            mmap[xx][yy] = <span class="string">'.'</span>;</span><br><span class="line">            <span class="built_in">func</span>(xx, yy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'#'</span>) {</span><br><span class="line">                mmap[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">func</span>(i, j);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ396-填涂颜色"><a href="http://oj.haizeix.com/problem/396">HZOJ396. 填涂颜色</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：将外层的0改为3，这样这个图只有被1包围的地方是0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line"><span class="keyword">int</span> mmap[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || xx &gt; n + <span class="number">1</span> || yy &gt; n + <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 只需要把范围之内的0全部改为3即可，否则会把定义的整个数 组多余的部分也都改为了0，浪费时间</span></span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] == <span class="number">0</span>) {</span><br><span class="line">            mmap[xx][yy] = <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">func</span>(xx, yy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 先把外层的0全部改成3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            j != <span class="number">1</span> &amp;&amp; cout &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="number">0</span>) cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mmap[i][j] == <span class="number">3</span>) cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ405-01迷宫"><a href="http://oj.haizeix.com/problem/405">HZOJ405.01迷宫</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 思路：因为是多组查询，可以将每一个位置上的情况都统计出来，然后直接查询结果，这样一次性统计出查询结果，会利用彼此间的位置关系，比一次已查询节省很多时间</span></span><br><span class="line"><span class="comment"> * 	1、通过mmap数组存储迷宫地图</span></span><br><span class="line"><span class="comment"> *	2、通过ans数组记录每个位置的查询结果</span></span><br><span class="line"><span class="comment"> *	3、使用顺序结构queue存储相连的位置，最后好一起更新ans值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, k, cnt;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>{ <span class="comment">// 更新所有的连接在一起的ans值</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        ans[temp.x][temp.y] = cnt;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; m || yy &gt; n || ans[xx][yy] != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 需要考虑边界问题，以及ans[xx][yy]如果已经更新过答案的话，就不需要访问了</span></span><br><span class="line">        <span class="keyword">if</span> (mmap[xx][yy] != mmap[x][y]) {</span><br><span class="line">            cnt += <span class="number">1</span>; </span><br><span class="line">            ans[xx][yy] = <span class="number">1</span>; <span class="comment">// 标记此位置访问过了</span></span><br><span class="line">            que.<span class="built_in">push</span>(node{xx, yy}); <span class="comment">// 将所有连接的位置统统放入队列，最后一起更新ans值</span></span><br><span class="line">            <span class="built_in">func</span>(xx, yy);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;m, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;mmap[i][<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            <span class="keyword">if</span> (ans[i][j] == <span class="number">0</span>) { <span class="comment">// 当前位置没访问过</span></span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                ans[i][j] = <span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(node{i, j});</span><br><span class="line">                <span class="built_in">func</span>(i, j);</span><br><span class="line">                <span class="built_in">save</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[a][b]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ541-相遇问题"><a href="http://oj.haizeix.com/problem/541">HZOJ541.相遇问题</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *   1、使用邻接矩阵记录牧场之间的花费时间：arr[2][20][20]，由于是两个人走，需要分别记录两个人走路的时间花费，2的位置代表哪一 个人走的</span></span><br><span class="line"><span class="comment"> *   2、ans[2][1000005]：记录每一个人从1号仓库到达本仓库的总花费情况</span></span><br><span class="line"><span class="comment"> *   3、cnt[n]：用于记录每一个人总共走了几种方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">2</span>][<span class="number">20</span>][<span class="number">20</span>], ans[<span class="number">2</span>][<span class="number">1000005</span>], cnt[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> person, <span class="keyword">int</span> now, <span class="keyword">int</span> cost)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (now == n) { <span class="comment">// 走到尽头了</span></span><br><span class="line">        ans[person][cnt[person]] = cost;</span><br><span class="line">        cnt[person] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = now + <span class="number">1</span>; i &lt;= n; i++) { <span class="comment">// 从当前仓库一直递归下去</span></span><br><span class="line">        <span class="keyword">if</span> (arr[person][now][i] != <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">func</span>(person, i, cost + arr[person][now][i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        arr[<span class="number">0</span>][a][b] = arr[<span class="number">0</span>][b][a] = c; <span class="comment">// 两个方向都需要记录</span></span><br><span class="line">        arr[<span class="number">1</span>][a][b] = arr[<span class="number">1</span>][b][a] = d;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sort</span>(ans[<span class="number">0</span>], ans[<span class="number">0</span>] + cnt[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">sort</span>(ans[<span class="number">1</span>], ans[<span class="number">1</span>] + cnt[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">0</span>]; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt[<span class="number">1</span>]; j++) {</span><br><span class="line">            <span class="keyword">if</span> (ans[<span class="number">0</span>][i] == ans[<span class="number">1</span>][j]) {</span><br><span class="line">                cout &lt;&lt; ans[<span class="number">0</span>][i] &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"IMPOSSIBLE"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ542-奶酪"><a href="http://oj.haizeix.com/problem/542">HZOJ542.奶酪</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// xyz记录每个点的x,y,z坐标值，mark标记哪个点被访问过了，arr邻接矩阵记录点与点之间是否联通，</span></span><br><span class="line"><span class="comment">// s记录所有的起点，cnt记录起点的个数，e记录所有的终点，是终点的位置标记为1</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t, n, h, r, xyz[<span class="number">1005</span>][<span class="number">3</span>], mark[<span class="number">1005</span>], arr[<span class="number">1005</span>][<span class="number">1005</span>], s[<span class="number">1005</span>], cnt, e[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> now)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (e[now] == <span class="number">1</span>) { <span class="comment">// 遍历到终点，表示可以实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) { </span><br><span class="line">        <span class="keyword">if</span> (arr[now][i] == <span class="number">1</span> &amp;&amp; mark[i] == <span class="number">0</span>) { <span class="comment">// 如果联通，并且没被访问过</span></span><br><span class="line">            mark[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">func</span>(i) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) { </span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mark)); <span class="comment">// 因为要进行t次查询，每次都需要清零重新来</span></span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(e));</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; h &gt;&gt; r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            cin &gt;&gt; xyz[i][<span class="number">0</span>] &gt;&gt; xyz[i][<span class="number">1</span>] &gt;&gt; xyz[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (xyz[i][<span class="number">2</span>] &lt;= r) { <span class="comment">// 记录起点</span></span><br><span class="line">                s[cnt] = i;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (xyz[i][<span class="number">2</span>] + r &gt;= h) { <span class="comment">// 记录终点</span></span><br><span class="line">                e[i] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) { <span class="comment">// 判断点与点之间是否联通</span></span><br><span class="line">                <span class="keyword">int</span> t1 = xyz[i][<span class="number">0</span>] - xyz[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> t2 = xyz[i][<span class="number">1</span>] - xyz[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> t3 = xyz[i][<span class="number">2</span>] - xyz[j][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">double</span> t4 = <span class="built_in">sqrt</span>(t1 * t1 + t2 * t2 + t3 * t3);</span><br><span class="line">                <span class="keyword">if</span> (t4 &lt;= <span class="number">2</span> * r) {</span><br><span class="line">                    arr[i][j] = arr[j][i] = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) { <span class="comment">// 遍历所有的起点</span></span><br><span class="line">            <span class="keyword">if</span> (mark[s[i]] == <span class="number">0</span>) {</span><br><span class="line">                mark[s[i]] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">func</span>(s[i]) == <span class="number">1</span>) {</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    cout &lt;&lt; <span class="string">"Yes"</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) cout &lt;&lt; <span class="string">"No"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ538-图的遍历"><a href="http://oj.haizeix.com/problem/538">HZOJ538.图的遍历</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, flag;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">25</span>][<span class="number">25</span>], ans[<span class="number">25</span>], mark[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) { <span class="comment">// 用来标记是否是第一次</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">    }</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) { <span class="comment">// 遍历所有点，找到与此点相连的点进行深搜遍历</span></span><br><span class="line">        <span class="keyword">if</span> (arr[x][i] == <span class="number">1</span> &amp;&amp; mark[i] == <span class="number">0</span>) {</span><br><span class="line">            mark[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">func</span>(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) { <span class="comment">// 以所有的点为起点进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (mark[i] == <span class="number">0</span>) {</span><br><span class="line">            mark[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">func</span>(i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<blockquote>
<p><strong>总结</strong>：岛屿数量这题需要考虑边界问题，其他海贼的题目不用考虑，因为多定义分边界之外的地方，有避免无限递归的问题， 图的搜索问题笔记</p>
</blockquote>
<hr>
<ul>
<li>
<h4 id="HZOJ304-骑士风度的牛"><a href="http://oj.haizeix.com/problem/304">HZOJ304.骑士风度的牛</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, startX, startY, endX, endY;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">1</span>};</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 注意题目顺序中给的顺序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'K'</span>) { <span class="comment">// 记录起点</span></span><br><span class="line">                startX = i;</span><br><span class="line">                startY = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{startX, startY, <span class="number">0</span>});</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; m || yy &gt; n || mmap[xx][yy] == <span class="string">'*'</span>) <span class="keyword">continue</span>; <span class="comment">// 边界判断</span></span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'H'</span>) {</span><br><span class="line">                cout &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'.'</span>) {</span><br><span class="line">                que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>});</span><br><span class="line">                mmap[xx][yy] = <span class="string">'*'</span>; <span class="comment">// 去重</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ398-马的遍历"><a href="http://oj.haizeix.com/problem/398">HZOJ398.马的遍历</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n, m, x, y;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">450</span>][<span class="number">450</span>];</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans)); <span class="comment">// 初始化为-1，如果初始化为0，对于起点的去重无法判断</span></span><br><span class="line">    ans[x][y] = <span class="number">0</span>; <span class="comment">// 起点</span></span><br><span class="line">    que.<span class="built_in">push</span>(node{x, y, <span class="number">0</span>}); <span class="comment">// 将起点压入队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) { <span class="comment">// 遍历8个方向</span></span><br><span class="line">            <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || ans[xx][yy] != <span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">// 边界判断，以及去重判断</span></span><br><span class="line">            ans[xx][yy] = temp.step + <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>});</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            j != <span class="number">1</span> &amp;&amp; cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            cout &lt;&lt; ans[i][j];</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ401-奇怪的象棋游戏升级版"><a href="http://oj.haizeix.com/problem/401">HZOJ401.奇怪的象棋游戏升级版</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, x, y;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">12</span>][<span class="number">2</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>}; <span class="comment">// 12种方向</span></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">505</span>][<span class="number">505</span>]; <span class="comment">// 去重</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>});</span><br><span class="line">    ans[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">-1</span>; <span class="comment">// 不能设置为0，否则无法去重</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; <span class="number">500</span> || yy &gt; <span class="number">500</span> || ans[xx][yy] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans[xx][yy] = temp.step + <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>});</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        cout &lt;&lt; ans[x][y] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ303-矩阵距离一"><a href="http://oj.haizeix.com/problem/303">HZOJ303.矩阵距离一</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y , step;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'1'</span>) { <span class="comment">// 以值为1的点往外扩展</span></span><br><span class="line">                ans[i][j] = <span class="number">-1</span>; <span class="comment">// 方便后面的去重</span></span><br><span class="line">                que.<span class="built_in">push</span>(node{i, j, <span class="number">0</span>}); <span class="comment">// 将所有的起点压入队列</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || xx &gt; n || yy &gt; m || ans[xx][yy] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ans[xx][yy] = temp.step + <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>});</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            j != <span class="number">1</span> &amp;&amp; cout &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans[i][j] == <span class="number">-1</span>) cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; ans[i][j];</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ529-龙与虫"><a href="http://oj.haizeix.com/problem/529">HZOJ529.龙与虫</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  1、以终点为起点向八个方向进行延长，能够到达的位置check值标记为2，都是终点</span></span><br><span class="line"><span class="comment"> *  2、以虫的位置为起点广搜遍历，遇到2即可消灭敌人</span></span><br><span class="line"><span class="comment"> *  3、由于多组测试数据，不能改原地图，需要使用标记数组，1代表广搜遍历过了，2代表终点，0代表越界</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, check[<span class="number">150</span>][<span class="number">150</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = {<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>};</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">150</span>][<span class="number">150</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="comment">// 以敌人为起点向8个方向延长，将所经过点标记为终点</span></span><br><span class="line">    check[x][y] = <span class="number">2</span>; <span class="comment">// 先将敌人标记为终点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) { <span class="comment">// 遍历八个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; <span class="number">1</span>; j++) { <span class="comment">// 延长的深度</span></span><br><span class="line">            <span class="keyword">int</span> xx = x + dir[i][<span class="number">0</span>] * j; </span><br><span class="line">            <span class="keyword">int</span> yy = y + dir[i][<span class="number">1</span>] * j;</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] != <span class="string">'O'</span>) <span class="keyword">break</span>; <span class="comment">// 越界或者遇到障碍物这个方向就没必要继续往下延长了</span></span><br><span class="line">            check[xx][yy] = <span class="number">2</span>; <span class="comment">// 延长遍历到的位置标记为终点</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="comment">// 以虫为起点，广搜找到终点</span></span><br><span class="line">    <span class="keyword">if</span> (check[x][y] == <span class="number">2</span>) { <span class="comment">// 起点即是终点</span></span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{x, y, <span class="number">0</span>});</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (check[xx][yy] == <span class="number">2</span>) { <span class="comment">// 遇到终点就结束</span></span><br><span class="line">                cout &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'O'</span> &amp;&amp; check[xx][yy] == <span class="number">0</span>) { <span class="comment">// 地图上此位置可遍历并且没有被遍历过</span></span><br><span class="line">                check[xx][yy] = <span class="number">1</span>; <span class="comment">// 标记为已遍历</span></span><br><span class="line">                que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"Impossible!"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(check)); <span class="comment">// 多次遍历，需要重置标记数组</span></span><br><span class="line">    <span class="built_in">init</span>(a, b); <span class="comment">// 初始化终点</span></span><br><span class="line">    <span class="built_in">bfs</span>(c, d); <span class="comment">// 广搜找结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        cin &gt;&gt; &amp;mmap[i][<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">func</span>()) {}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ81-小明回家"><a href="http://oj.haizeix.com/problem/81">HZOJ81.小明回家</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  1、因为需要来回走，不能更改地图，需要使用标记数组check，0代表没有走过，1代表没手机走过，2表示有手机走过，3表示有手机和没手机都走过</span></span><br><span class="line"><span class="comment"> * 使用flag用来标记该点是有手机走过还是没有手机走过</span></span><br><span class="line"><span class="comment"> * 去重操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step, flag;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, check[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    queue&lt;node&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'S'</span>) {</span><br><span class="line">                que.<span class="built_in">push</span>(node{i, j, <span class="number">0</span>, <span class="number">0</span>}); <span class="comment">// 将起点压入队列中</span></span><br><span class="line">                check[i][j] = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'T'</span> &amp;&amp; temp.flag == <span class="number">1</span>) { <span class="comment">// 如果有手机并遇到重点，结束</span></span><br><span class="line">                cout &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (((check[xx][yy] &amp; <span class="number">1</span>) &amp;&amp; temp.flag == <span class="number">0</span>) || ((check[xx][yy] &amp; <span class="number">2</span>) &amp;&amp; temp.flag == <span class="number">1</span>)) <span class="keyword">continue</span>; <span class="comment">// 避免没手机时 重复走过某一点，或者 有手机时重复走过某一点</span></span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'.'</span> || mmap[xx][yy] == <span class="string">'S'</span> || mmap[xx][yy] == <span class="string">'T'</span>) { <span class="comment">//</span></span><br><span class="line">                check[xx][yy] += temp.flag + <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">                que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>, temp.flag});</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'P'</span>) { <span class="comment">// 经过手机店</span></span><br><span class="line">                check[xx][yy] = <span class="number">3</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>, <span class="number">1</span>});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ527-飞跃原野"><a href="http://oj.haizeix.com/problem/527">HZOJ527.飞跃原野</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：将飞和走两种情况都遍历一遍，先遍历飞的情况，因为飞一次可以是好几步，但只看作一次</span></span><br><span class="line"><span class="comment"> * 去重：check[x][y][d]，d代表在当前能量下是否访问过该位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step, d;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n, d, check[<span class="number">105</span>][<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>};</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, d});</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) { <span class="comment">// 对于起点来说，不管是否有能量，都尽量不要再走一遍起点</span></span><br><span class="line">        check[<span class="number">1</span>][<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= temp.d; j++) { <span class="comment">// 先飞，飞的距离受能量的影响</span></span><br><span class="line">                <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>] * j;</span><br><span class="line">                <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>] * j;</span><br><span class="line">                <span class="keyword">if</span> (mmap[xx][yy] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 越界直接终止该方向后面的尝试</span></span><br><span class="line">                <span class="keyword">if</span> (xx == m &amp;&amp; yy == n) { <span class="comment">// 飞到终点上</span></span><br><span class="line">                    cout &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'P'</span> &amp;&amp; check[xx][yy][temp.d - j] == <span class="number">0</span>) { <span class="comment">// 飞到平地上，并且在当前能量下之前没经过</span></span><br><span class="line">                    check[xx][yy][temp.d - j] = <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>, temp.d - j});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>]; <span class="comment">// 进行走的遍历</span></span><br><span class="line">            <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xx == m &amp;&amp; yy == n) { <span class="comment">// 走到终点上了</span></span><br><span class="line">                cout &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'P'</span> &amp;&amp; check[xx][yy][temp.d] == <span class="number">0</span>) { <span class="comment">// 走不需要能耗</span></span><br><span class="line">                check[xx][yy][temp.d] = <span class="number">1</span>;</span><br><span class="line">                que.<span class="built_in">push</span>(node{xx, yy , temp.step + <span class="number">1</span>, temp.d});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"impossible"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ402-奇怪的电梯"><a href="http://oj.haizeix.com/problem/402">HZOJ402.奇怪的电梯</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *  之前存的是当前位置x,y值，此处直接存楼层now，以及最小步数step</span></span><br><span class="line"><span class="comment"> *  方向数组不需要，因为只有两个方向，要不然上，要不然下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> now, step;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a, b, num[<span class="number">205</span>], mark[<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">    }</span><br><span class="line">    queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{a, <span class="number">0</span>}); <span class="comment">// 先将起点压入队列</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (temp.now == b) { <span class="comment">// 如果当前位置就是目标点，则直接结束遍历</span></span><br><span class="line">            cout &lt;&lt; temp.step &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> xx = temp.now + num[temp.now]; <span class="comment">// 向下</span></span><br><span class="line">        <span class="keyword">int</span> yy = temp.now - num[temp.now]; <span class="comment">// 向上</span></span><br><span class="line">        <span class="keyword">if</span> (xx &lt;= n &amp;&amp; mark[xx] == <span class="number">0</span>) { <span class="comment">// 向下运行</span></span><br><span class="line">            mark[xx] = <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(node{xx, temp.step + <span class="number">1</span>});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (yy &gt;= <span class="number">1</span> &amp;&amp; mark[yy] == <span class="number">0</span>) { <span class="comment">// 向上运行</span></span><br><span class="line">            mark[yy] = <span class="number">1</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(node{yy, temp.step + <span class="number">1</span>});</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"-1"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ530-警察找车"><a href="http://oj.haizeix.com/problem/530">HZOJ530.警察找车</a></h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20220116084229462.png" alt="image-20220116084229462"></p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, sx, sy, dir_num, mark[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = {<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line">queue&lt;node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'*'</span>) { <span class="comment">// 记录起点，并把起点置为.，因为起点后面也有可能遍历到</span></span><br><span class="line">                sx = i;</span><br><span class="line">                sy = j;</span><br><span class="line">                mmap[i][j] = <span class="string">'.'</span>; <span class="comment">//</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    que.<span class="built_in">push</span>(node{sx, sy});</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span> (k--) {</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">"NORTH"</span>) dir_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">"SOUTH"</span>) dir_num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">"WEST"</span>) dir_num = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="string">"EAST"</span>) dir_num = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mark)); <span class="comment">// 每一层都需要单独标记，同一个位置可以通过不同的方向走法经过，但同一方向时只允许经过一次</span></span><br><span class="line">        <span class="keyword">int</span> cnt = que.<span class="built_in">size</span>(); <span class="comment">// 需要记录当前的队列元素数量，要不然使用que.size是一直变动的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) {</span><br><span class="line">            node temp = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; <span class="number">1</span>; j++) {</span><br><span class="line">                <span class="keyword">int</span> xx = temp.x + dir[dir_num][<span class="number">0</span>] * j;</span><br><span class="line">                <span class="keyword">int</span> yy = temp.y + dir[dir_num][<span class="number">1</span>] * j;</span><br><span class="line">                <span class="keyword">if</span> (mmap[xx][yy] != <span class="string">'.'</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (mark[xx][yy] == <span class="number">0</span>) {</span><br><span class="line">                    mark[xx][yy] = <span class="number">1</span>;</span><br><span class="line">                    que.<span class="built_in">push</span>(node{xx, yy});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) { <span class="comment">// 到达树的最后一行</span></span><br><span class="line">        node temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        mmap[temp.x][temp.y] = <span class="string">'*'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            cout &lt;&lt; mmap[i][j];</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>启发式广度搜索</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：对于每一个方向的遍历都要优先考虑权值大的方向，这样就可以避免不必要的搜索</span></span><br><span class="line"><span class="comment"> * 权值：该位置与终点的距离越近越好，使用欧式距</span></span><br><span class="line"><span class="comment"> * 方法：使用优先队列按照欧氏距离的大小进行排序</span></span><br><span class="line"><span class="comment"> * 优点：较少非必要的的搜索过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> x, y, step;</span><br><span class="line">    <span class="keyword">double</span> h; <span class="comment">// 欧式距</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> { <span class="comment">// priority_queue重载的是&lt;，这里需要反着写</span></span><br><span class="line">        <span class="keyword">return</span> step + h &gt; b.step + b.h;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy, ex, ey;</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>}; <span class="comment">// 8个方向遍历</span></span><br><span class="line"><span class="keyword">char</span> mmap[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{ <span class="comment">// 求欧式距</span></span><br><span class="line">    <span class="keyword">int</span> t1 = x - ex, t2 = y - ey;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(t1 * t1 + t2 * t2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>{ <span class="comment">// 输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"------------------"</span> &lt;&lt; cnt &lt;&lt; <span class="string">"--------------------------"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            cout &lt;&lt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'x'</span>) {</span><br><span class="line">                mmap[i][j] = <span class="string">'~'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------------------  ----------"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) {</span><br><span class="line">            cin &gt;&gt; mmap[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'S'</span>) { <span class="comment">// 记录起点位置</span></span><br><span class="line">                sx = i, sy = j;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mmap[i][j] == <span class="string">'T'</span>) { <span class="comment">// 记录终点位置</span></span><br><span class="line">                ex = i, ey = j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    priority_queue&lt;node&gt; que; </span><br><span class="line">    que.<span class="built_in">push</span>(node{sx, sy, <span class="number">0</span>, <span class="built_in">dis</span>(sx, sy)}); <span class="comment">// 先存入起点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {</span><br><span class="line">            <span class="keyword">int</span> xx = temp.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yy = temp.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'T'</span>) { <span class="comment">// 到达终点就结束搜索</span></span><br><span class="line">                cout &lt;&lt; temp.step + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">print</span>(cnt);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (mmap[xx][yy] == <span class="string">'.'</span>) {</span><br><span class="line">                mmap[xx][yy] = <span class="string">'x'</span>; <span class="comment">// 去重</span></span><br><span class="line">                que.<span class="built_in">push</span>(node{xx, yy, temp.step + <span class="number">1</span>, <span class="built_in">dis</span>(xx, yy)});</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt % <span class="number">5</span> == <span class="number">0</span>) {</span><br><span class="line">                    <span class="built_in">print</span>(cnt);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<blockquote>
<p><strong>说明</strong>：广搜主要解决最少步数问题，对于多次查询的题目，需要将整个地图的情况遍历完，类似于线下更新，线上查询的效果，这样可以再遍历时通过位置与位置之间的关系，减少时间</p>
</blockquote>
<h2 id="最短路">最短路</h2>
<h3 id="1、最短路的理论要点">1、最短路的理论要点</h3>
<p>1、负环</p>
<p>2、邻接矩阵的优缺点：图论算法1，用来解决floyd</p>
<p>3、连接表的优缺点：图论算法1，用来解决djksta</p>
<p>4、djksta：无负边</p>
<p>5、链式前向星：</p>
<ul>
<li>边集（e, v, next）:next表示同一起点的上一条边的边号</li>
<li>head数组：某一个点为起点的最后一条边的边号</li>
</ul>
<p>6、Bellman-fold：通过边，用边起点的最短路+边的权值去更新终点的答案</p>
<p>7、基于队列的Bellman-fold算法的优化：只有上一轮更新过的点才能影响下一轮的答案</p>
<h3 id="2、重点题型-10">2、重点题型</h3>
<ul>
<li>
<h4 id="HZOJ746-最短路"><a href="http://oj.haizeix.com/problem/746">HZOJ746.最短路</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * floyed算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr)); <span class="comment">// </span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (arr[a][b] &gt; c) { <span class="comment">// 有重边，需要选权值最小的情况</span></span><br><span class="line">            arr[a][b] = c;</span><br><span class="line">            arr[b][a] = c;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) { <span class="comment">// i作为中转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) {</span><br><span class="line">                arr[j][k] = <span class="built_in">min</span>(arr[j][k], arr[j][i] + arr[i][k]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        arr[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[s][i] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; arr[s][i] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * djksta</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span> <span class="comment">// 算法过程中状态</span></span><br><span class="line">    <span class="keyword">int</span> now, dis; <span class="comment">// 当前位置，从起点到达当前位置的长度</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;dis &gt; a.dis;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>{</span> <span class="comment">// 连接表存边信息</span></span><br><span class="line">    <span class="keyword">int</span> e, v; <span class="comment">// 终点和权值</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> n, m, s, ans[<span class="number">100005</span>];</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    vector&lt;vector&lt;edge&gt;&gt; <span class="built_in">edg</span>(n + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edg[a].<span class="built_in">push_back</span>(edge{b, c}); <span class="comment">// 无向边两个方向都要存</span></span><br><span class="line">        edg[b].<span class="built_in">push_back</span>(edge{a, c});</span><br><span class="line">    }</span><br><span class="line">    priority_queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{s, <span class="number">0</span>}); <span class="comment">// 从起点开始查找</span></span><br><span class="line">    ans[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (ans[temp.now] &lt; temp.dis) <span class="keyword">continue</span>; <span class="comment">// 证明这个点已经走过了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edg[temp.now].<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">int</span> e = edg[temp.now][i].e, v = edg[temp.now][i].v;</span><br><span class="line">            <span class="keyword">if</span> (ans[e] &gt; temp.dis + v) { <span class="comment">// 更新最短路径</span></span><br><span class="line">                ans[e] = temp.dis + v;</span><br><span class="line">                que.<span class="built_in">push</span>(node{e, ans[e]}); <span class="comment">// 继续压入优先队列中</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 链式前向星 + djksta</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> {</span> <span class="comment">// 链式前向星的边信息</span></span><br><span class="line">    <span class="keyword">int</span> e, v, next; <span class="comment">// e是终点，v是代价，next是同一起点的上一条边</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span> <span class="comment">// djksta的信息存储</span></span><br><span class="line">    <span class="keyword">int</span> now, dis; </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;dis &gt; a.dis;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">edge edg[<span class="number">200005</span>]; <span class="comment">// 无向图，正方方向都要存储边，edg用来存储链式前向星的边信息</span></span><br><span class="line"><span class="keyword">int</span> n, m, s, cnt, ans[<span class="number">100005</span>], head[<span class="number">100005</span>]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_edge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> v)</span> </span>{  <span class="comment">// 数据更新顺序不能变</span></span><br><span class="line">    edg[cnt].e = e; </span><br><span class="line">    edg[cnt].v = v;</span><br><span class="line">    edg[cnt].next = head[s]; <span class="comment">// head记录的是当前i为起点的最后一条边的终点</span></span><br><span class="line">    head[s] = cnt; <span class="comment">// 此时head已经变了</span></span><br><span class="line">    cnt += <span class="number">1</span>; <span class="comment">// 因为是无向图，需要记录两条边的信息。使用cnt帮助记录边情况</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add_to_edge</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add_to_edge</span>(b, a, c);</span><br><span class="line">    }</span><br><span class="line">    priority_queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{s, <span class="number">0</span>});</span><br><span class="line">    ans[s] = <span class="number">0</span>; <span class="comment">// 标记起点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (ans[temp.now] &lt; temp.dis) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[temp.now]; i != <span class="number">-1</span>; i = edg[i].next) { <span class="comment">// 像链表的遍历方式</span></span><br><span class="line">            <span class="keyword">int</span> e = edg[i].e, v = edg[i].v;</span><br><span class="line">            <span class="keyword">if</span> (ans[temp.now] + v &lt; ans[e]) {</span><br><span class="line">                ans[e] = ans[temp.now] + v;</span><br><span class="line">                que.<span class="built_in">push</span>(node{e, ans[e]});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">"-1"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bellman-fold：单源、慢、负权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> {</span> <span class="comment">// 边信息</span></span><br><span class="line">    <span class="keyword">int</span> s, e, v; <span class="comment">// 起点，终点，权值</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">edge edg[<span class="number">20005</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, s, cnt, ans[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>{ <span class="comment">// 存边</span></span><br><span class="line">    edg[cnt].s = a;</span><br><span class="line">    edg[cnt].e = b;</span><br><span class="line">    edg[cnt].v = c;</span><br><span class="line">    cnt += <span class="number">1</span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add_to_edge</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add_to_edge</span>(b, a, c);</span><br><span class="line">    }</span><br><span class="line">    ans[s] = <span class="number">0</span>; <span class="comment">// 一定要初始化起点</span></span><br><span class="line">    <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) { <span class="comment">// 遍历循环的次数</span></span><br><span class="line">        f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) { <span class="comment">// 遍历所有的边</span></span><br><span class="line">            <span class="keyword">if</span> (ans[edg[j].e] &gt; ans[edg[j].s] + edg[j].v) { <span class="comment">// 更新结果</span></span><br><span class="line">                ans[edg[j].e] = ans[edg[j].s] + edg[j].v;</span><br><span class="line">                f = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">"-1"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基于队列优化的Bellman-fold算法：更新特定起点的最短路，需要采用邻接表或链式前向星存储边的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> {</span> </span><br><span class="line">    <span class="keyword">int</span> e, v, next;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">edge edg[<span class="number">20005</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, s, cnt, head[<span class="number">10005</span>], ans[<span class="number">10005</span>], mark[<span class="number">10005</span>]; <span class="comment">// mark用来每一轮去重用的，同一个对于一轮来说，只需要放入队列一次</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">    edg[cnt].e = b;</span><br><span class="line">    edg[cnt].v = c;</span><br><span class="line">    edg[cnt].next = head[a];</span><br><span class="line">    head[a] = cnt;</span><br><span class="line">    cnt += <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add_to_edge</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add_to_edge</span>(b, a, c);</span><br><span class="line">    }</span><br><span class="line">    que.<span class="built_in">push</span>(s);</span><br><span class="line">    ans[s] = <span class="number">0</span>;</span><br><span class="line">    mark[s] = <span class="number">1</span>; <span class="comment">// 第一轮，将起点标记为已经添加队列了</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">int</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        mark[temp] = <span class="number">0</span>; <span class="comment">// 后面有可能继续更新  ********************</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[temp]; i != <span class="number">-1</span>; i = edg[i].next) {</span><br><span class="line">            <span class="keyword">int</span> e = edg[i].e, v = edg[i].v;</span><br><span class="line">            <span class="keyword">if</span> (ans[e] &gt; ans[temp] + v) {</span><br><span class="line">                ans[e] =  ans[temp] + v;</span><br><span class="line">                <span class="keyword">if</span> (mark[e] == <span class="number">0</span>) { <span class="comment">// 只有没添加过的点才可以添加</span></span><br><span class="line">                    que.<span class="built_in">push</span>(e);</span><br><span class="line">                    mark[e] = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">if</span> (ans[i] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">"-1"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LUOGU-P1364-医院设置"><a href="https://www.luogu.com.cn/problem/P1364">LUOGU.P1364.医院设置</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">105</span>][<span class="number">105</span>], num[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a) {</span><br><span class="line">            arr[i][a] = <span class="number">1</span>;</span><br><span class="line">            arr[a][i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (b) {</span><br><span class="line">            arr[i][b] = <span class="number">1</span>;</span><br><span class="line">            arr[b][i] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        arr[i][i] = <span class="number">0</span>; <span class="comment">// 把对角线上的元素初始化为0</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) { <span class="comment">// 先用floyd算法，找到最短路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) {</span><br><span class="line">                arr[j][k] = <span class="built_in">min</span>(arr[j][k], arr[j][i] + arr[i][k]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) {</span><br><span class="line">            t += arr[i][j] * num[j];</span><br><span class="line">        }</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, t);</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LUOGU-P1119-灾后重建"><a href="https://www.luogu.com.cn/problem/P1119">LUOGU.P1119.灾后重建</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思想：多源最短路问题，采用floyd算法</span></span><br><span class="line"><span class="comment"> * 由题意知，floyd算法的中间转折点i是需要在时间允许的条件下才能作为周转点，也就是说要把floyd的第一层循环给拆解开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> n, m, q, now, num[<span class="number">205</span>], arr[<span class="number">205</span>][<span class="number">205</span>]; <span class="comment">// now是当前修改到了哪一个点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(arr));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) { <span class="comment">// 存储每个村庄所需的修复时间</span></span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">        arr[i][i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) { <span class="comment">// 存储边的信息</span></span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        arr[a][b] = c;</span><br><span class="line">        arr[b][a] = c;</span><br><span class="line">    }</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) {</span><br><span class="line">        <span class="keyword">int</span> x, y, t;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (num[now] &lt;= t &amp;&amp; now &lt; n) { <span class="comment">// 拆解第一层循环i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) {</span><br><span class="line">                    arr[j][k] = <span class="built_in">min</span>(arr[j][k], arr[j][now] + arr[now][k]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            now += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (num[x] &gt; t || num[y] &gt; t || arr[x][y] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 需要特殊处理，特殊考虑</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; arr[x][y] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LUOGU-P1629-邮递员送信"><a href="https://www.luogu.com.cn/problem/P1629">LUOGU.P1629.邮递员送信</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *	1、从节点1出发时是单源最短路</span></span><br><span class="line"><span class="comment"> * 	2、从各节点返回到节点1时，是多源最短路问题，需要用到floyd算法，但容易超时，可以转换思想，从A到B，等价于从B到A，这里可以等价于从节点1到各节点</span></span><br><span class="line"><span class="comment"> * 总结：使用基于队列优化的Bellman—flod算法进行单源最短路的求解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> {</span> <span class="comment">// 链式前向星的边集定义</span></span><br><span class="line">    <span class="keyword">int</span> e, v, next;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans[<span class="number">2</span>][<span class="number">1005</span>], head[<span class="number">2</span>][<span class="number">1005</span>], mark[<span class="number">10005</span>]; <span class="comment">// 由于考虑到去和回来，需要存两次，这里开一个二维数组进行存储，而mark标记数组可以在每一轮进行初始化</span></span><br><span class="line">edge edg[<span class="number">2</span>][<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_edge</span><span class="params">(<span class="keyword">int</span> cnt, <span class="keyword">int</span> index, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> v)</span> </span>{</span><br><span class="line">    edg[cnt][index].e = e;</span><br><span class="line">    edg[cnt][index].v = v;</span><br><span class="line">    edg[cnt][index].next = head[cnt][s];</span><br><span class="line">    head[cnt][s] = index;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>{ <span class="comment">// Bellman-fold算法</span></span><br><span class="line">    <span class="built_in">memset</span>(mark, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mark)); <span class="comment">// 每一轮都需要初始化</span></span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    ans[cnt][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 添加起点</span></span><br><span class="line">    mark[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">int</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        mark[temp] = <span class="number">0</span>; <span class="comment">// ******** 下一轮有可能继续更新，这里要解放当前位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[cnt][temp]; i != <span class="number">-1</span>; i = edg[cnt][i].next) {</span><br><span class="line">            <span class="keyword">int</span> e = edg[cnt][i].e, v = edg[cnt][i].v;</span><br><span class="line">            <span class="keyword">if</span> (ans[cnt][e] &gt; ans[cnt][temp] + v) {</span><br><span class="line">                ans[cnt][e] = ans[cnt][temp] + v;</span><br><span class="line">                <span class="keyword">if</span> (mark[e] == <span class="number">0</span>) {</span><br><span class="line">                    que.<span class="built_in">push</span>(e);</span><br><span class="line">                    mark[e] = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add_to_edge</span>(<span class="number">0</span>, i, a, b, c); <span class="comment">// 存两次边信息</span></span><br><span class="line">        <span class="built_in">add_to_edge</span>(<span class="number">1</span>, i, b, a, c);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        sum += ans[<span class="number">0</span>][i] + ans[<span class="number">1</span>][i]; <span class="comment">// 计算总值</span></span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LUOGU-P2865-USACO06NOV-Roadblocks-G"><a href="https://www.luogu.com.cn/problem/P2865">LUOGU.P2865.USACO06NOV\Roadblocks G</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 思想：单源最短路问题</span></span><br><span class="line"><span class="comment">     * 更新情况：</span></span><br><span class="line"><span class="comment">     *		1、最短路更新最短路</span></span><br><span class="line"><span class="comment">     *		2、最短路更新次短路</span></span><br><span class="line"><span class="comment">     *		3、次短路更新次短路</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">edge</span> {</span></span><br><span class="line">        <span class="keyword">int</span> e, v, next;</span><br><span class="line">    };</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m, cnt, ans[<span class="number">5005</span>], ans2[<span class="number">5005</span>], head[<span class="number">5005</span>], mark[<span class="number">5005</span>];</span><br><span class="line">    edge edg[<span class="number">200005</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_to_edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">        edg[cnt].e = b;</span><br><span class="line">        edg[cnt].v = c;</span><br><span class="line">        edg[cnt].next = head[a];</span><br><span class="line">        head[a] = cnt;</span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(ans2, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans2));</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add_to_edge</span>(a, b, c);</span><br><span class="line">            <span class="built_in">add_to_edge</span>(b, a, c);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">1</span> || b == <span class="number">1</span>) { <span class="comment">// 记录起点的次短路，就是与1相连的最短距离的来回</span></span><br><span class="line">                ans2[<span class="number">1</span>] = <span class="built_in">min</span>(ans2[<span class="number">1</span>], c * <span class="number">2</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        mark[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">            <span class="keyword">int</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            mark[temp] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[temp]; i != <span class="number">-1</span>; i = edg[i].next) { </span><br><span class="line">                <span class="keyword">int</span> e = edg[i].e, v = edg[i].v;</span><br><span class="line">                <span class="keyword">if</span> (ans[e] &gt; ans[temp] + v) { <span class="comment">// 最短路更新最短路</span></span><br><span class="line">                    ans2[e] = ans[e]; <span class="comment">// 被更新下来的最短路就变为次短路</span></span><br><span class="line">                    ans[e] = ans[temp] + v;</span><br><span class="line">                    <span class="keyword">if</span> (mark[e] == <span class="number">0</span>) {</span><br><span class="line">                        mark[e] = <span class="number">1</span>;</span><br><span class="line">                        que.<span class="built_in">push</span>(e);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (ans[temp] + v &lt; ans2[e] &amp;&amp; ans[temp] + v != ans[e]) { <span class="comment">// 最短路更新次短路</span></span><br><span class="line">                    ans2[e] = ans[temp] + v;</span><br><span class="line">                    <span class="keyword">if</span> (mark[e] == <span class="number">0</span>) {</span><br><span class="line">                        mark[e] = <span class="number">1</span>;</span><br><span class="line">                        que.<span class="built_in">push</span>(e);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (ans2[temp] + v &lt; ans2[e]) { <span class="comment">// 次短路更新次短路</span></span><br><span class="line">                    ans2[e] = ans2[temp] + v;</span><br><span class="line">                    <span class="keyword">if</span> (mark[e] == <span class="number">0</span>) {</span><br><span class="line">                        mark[e] = <span class="number">1</span>;</span><br><span class="line">                        que.<span class="built_in">push</span>(e);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; ans2[n] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="1、最小生成树的理论要点">1、最小生成树的理论要点</h3>
<p>边数=点数-1</p>
<p>2:04的位置</p>
<h3 id="2、重点题型-11">2、重点题型</h3>
<ul>
<li>
<h4 id="LUOGU-P3366-最小生成树"><a href="https://www.luogu.com.cn/problem/P3366">LUOGU.P3366.最小生成树</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * krusal算法：利用边信息，将边按照边权进行升序排列，利用并查集+最小边权进行建立最小生成树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> {</span> <span class="comment">// 存放边信息</span></span><br><span class="line">    <span class="keyword">int</span> s, e, v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge &amp;a) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;v &lt; a.v;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">edge edg[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, ans, my_union[<span class="number">5005</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>{ <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        my_union[i] = i;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{ <span class="comment">// 并查集查找父节点 + 路径优化</span></span><br><span class="line">    <span class="keyword">if</span> (my_union[x] == x) {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> my_union[x] = <span class="built_in">my_find</span>(my_union[x]); <span class="comment">// 路径压缩</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        cin &gt;&gt; edg[i].s &gt;&gt; edg[i].e &gt;&gt; edg[i].v;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sort</span>(edg, edg + m); <span class="comment">// 按边权进行排序</span></span><br><span class="line">    <span class="built_in">init</span>(); <span class="comment">// 初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">int</span> s = edg[i].s, e = edg[i].e, v = edg[i].v;</span><br><span class="line">        <span class="keyword">int</span> fa = <span class="built_in">my_find</span>(s), fb = <span class="built_in">my_find</span>(e); <span class="comment">// 找到起点和终点的父节点</span></span><br><span class="line">        <span class="keyword">if</span> (fa != fb) { </span><br><span class="line">            my_union[fa] = fb; <span class="comment">// 合并</span></span><br><span class="line">            ans += v;</span><br><span class="line">            cnt += <span class="number">1</span>; <span class="comment">// cnt来判断是否已经构成最小生成树</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) {</span><br><span class="line">                cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"orz"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * prim算法：利用点的信息，利用优先队列将已经遍历到的点所连接的边进行排序，每次选择最小代价的边进行延申</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span> <span class="comment">// 放在优先队列中打包排序用</span></span><br><span class="line">    <span class="keyword">int</span> e, v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;v &gt; a.v;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> {</span> <span class="comment">// 链式前向星用来存边信息</span></span><br><span class="line">    <span class="keyword">int</span> e, v, next;</span><br><span class="line">};</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * edge_cnt用来记录边信息</span></span><br><span class="line"><span class="comment"> * cnt用来记录已经生成最小数的边数</span></span><br><span class="line"><span class="comment"> * mark[]用来去重</span></span><br><span class="line"><span class="comment"> * num[x]用来记录连接x的边的权值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, edge_cnt, ans, head[<span class="number">5005</span>], mark[<span class="number">5005</span>], num[<span class="number">5005</span>]; </span><br><span class="line">edge edg[<span class="number">400005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>{</span><br><span class="line">    edg[edge_cnt].e = b;</span><br><span class="line">    edg[edge_cnt].v = c;</span><br><span class="line">    edg[edge_cnt].next = head[a];</span><br><span class="line">    head[a] = edge_cnt++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add_to_edge</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add_to_edge</span>(b, a, c);</span><br><span class="line">    }</span><br><span class="line">    priority_queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{n / <span class="number">2</span>, <span class="number">0</span>}); <span class="comment">// 以任一点为起点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (mark[temp.e] == <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// 已经访问过了</span></span><br><span class="line">        ans += temp.v; </span><br><span class="line">        mark[temp.e] = <span class="number">1</span>;</span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n) { <span class="comment">// 最小生成树已经生成</span></span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[temp.e]; i != <span class="number">-1</span>; i = edg[i].next) {</span><br><span class="line">            <span class="keyword">int</span> e = edg[i].e, v = edg[i].v;</span><br><span class="line">            <span class="keyword">if</span> (mark[e] == <span class="number">0</span> &amp;&amp; num[e] &gt; v) { <span class="comment">// 这里num加不加都可以，是用来优化代码的</span></span><br><span class="line">                que.<span class="built_in">push</span>(node{e, v});</span><br><span class="line">                num[e] = v;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"orz"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LUOGU-P1265-公路修建"><a href="https://www.luogu.com.cn/problem/P1265">LUOGU.P1265.公路修建</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 思路：用prim算法，因为本题数据量较大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">double</span> v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;v &gt; a.v;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> n, m, xy[<span class="number">5005</span>][<span class="number">2</span>], mark[<span class="number">5005</span>], cnt;</span><br><span class="line"><span class="keyword">double</span> num[<span class="number">5005</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t1 = xy[a][<span class="number">0</span>] - xy[b][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t2 = xy[a][<span class="number">1</span>] - xy[b][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(t1 * t1 + t2 * t2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">        cin &gt;&gt; xy[i][<span class="number">0</span>] &gt;&gt; xy[i][<span class="number">1</span>]; <span class="comment">// 因为只提供城市的坐标，对于城市间的距离需要通过计算得到</span></span><br><span class="line">        num[i] = <span class="number">999999999</span>; <span class="comment">// 为了后面优化使用，对于double不能使用memset，只能一个一个的初始化</span></span><br><span class="line">    }</span><br><span class="line">    priority_queue&lt;node&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(node{<span class="number">1</span>, <span class="number">0</span>});</span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) {</span><br><span class="line">        node temp = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (mark[temp.e] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans += temp.v;</span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">        mark[temp.e] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, ans);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (mark[i] == <span class="number">0</span> &amp;&amp; i != temp.e) {</span><br><span class="line">                <span class="keyword">double</span> t = <span class="built_in">func</span>(temp.e, i); <span class="comment">// 计算两点之间的距离</span></span><br><span class="line">                <span class="keyword">if</span> (num[i] &gt; t) { <span class="comment">// 算法优化</span></span><br><span class="line">                    num[i] = t;</span><br><span class="line">                    que.<span class="built_in">push</span>(node{i, t});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LUOGU-P1991-无线通讯网"><a href="https://www.luogu.com.cn/problem/P1991">LUOGU.P1991.无线通讯网</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LUOGU-P1144-最短路计数"><a href="https://www.luogu.com.cn/problem/P1144">LUOGU.P1144.最短路计数</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="拓扑排序">拓扑排序</h2>
<h3 id="1、拓扑排序的理论要点">1、拓扑排序的理论要点</h3>
<h3 id="2、重点题型-12">2、重点题型</h3>
<ul>
<li>
<h4 id="HZOJ641-拓扑排序"><a href="http://oj.haizeix.com/problem/641">HZOJ641.拓扑排序</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ635-神经网络"><a href="http://oj.haizeix.com/problem/635">HZOJ635.神经网络</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ636-旅游计划"><a href="http://oj.haizeix.com/problem/636">HZOJ636.旅游计划</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ640-食物链计数"><a href="http://oj.haizeix.com/problem/640">HZOJ640.食物链计数</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ637-排序"><a href="http://oj.haizeix.com/problem/637">HZOJ637.排序</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ638-最长路"><a href="http://oj.haizeix.com/problem/638">HZOJ638.最长路</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="HZOJ674-宿舍楼里的电竞赛"><a href="http://oj.haizeix.com/problem/674">HZOJ674.宿舍楼里的电竞赛</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="单调栈">单调栈</h2>
<h3 id="1、单调栈的理论要点">1、单调栈的理论要点</h3>
<ul>
<li><strong>单调栈的本质</strong>：空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素的元素，优点是只需要遍历一次</li>
<li><strong>单调栈里存放的元素</strong>：单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取</li>
<li><strong>单调栈里元素是递增呢？ 还是递减呢？</strong>：递增循序（再强调一下是指从栈头到栈底的顺序），因为只有递增的时候，加入一个元素i，才知道栈顶元素在数组中右面第一个比栈顶元素<code>大</code>的元素是i；递减栈就是求右边第一个比自己<code>小</code>的元素</li>
</ul>
<h3 id="2、重点题型-13">2、重点题型</h3>
<ul>
<li>
<h4 id="LC739-每日温度"><a href="https://leetcode-cn.com/problems/daily-temperatures/">LC739.每日温度</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; t)</span> </span>{</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>; <span class="comment">// 记录结果</span></span><br><span class="line">        sta.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (t[i] &lt; t[sta.<span class="built_in">top</span>()]) sta.<span class="built_in">push</span>(i); <span class="comment">// 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t[i] == t[sta.top]) sta.<span class="built_in">push</span>(i); <span class="comment">// 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</span></span><br><span class="line">            <span class="keyword">else</span> { <span class="comment">// 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</span></span><br><span class="line">                <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>() &amp;&amp; t[i] &gt; t[sta.<span class="built_in">top</span>()]) {</span><br><span class="line">                    res[sta.<span class="built_in">top</span>()] = i - sta.<span class="built_in">top</span>();</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; t)</span> </span>{</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(t.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        sta.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>() &amp;&amp; t[i] &gt; t[sta.<span class="built_in">top</span>()]) {</span><br><span class="line">                res[sta.<span class="built_in">top</span>()] = i - sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            sta.<span class="built_in">push</span>(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC496-下一个更大元素-I"><a href="https://leetcode-cn.com/problems/next-greater-element-i/">LC496.下一个更大元素 I</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>{</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(nums1.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) umap[nums1[i]] = i;</span><br><span class="line">        sta.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums2.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums2[i] &lt; nums2[sta.<span class="built_in">top</span>()]) sta.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums2[i] == nums2[sta.<span class="built_in">top</span>()]) sta.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[sta.<span class="built_in">top</span>()]) {</span><br><span class="line">                    <span class="keyword">if</span> (umap.<span class="built_in">find</span>(nums2[sta.<span class="built_in">top</span>()]) != umap.<span class="built_in">end</span>()) {</span><br><span class="line">                        result[umap[nums2[sta.<span class="built_in">top</span>()]]] = nums2[i];</span><br><span class="line">                    }</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                }</span><br><span class="line">                sta.<span class="built_in">push</span>(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC503-下一个更大元素-II"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">LC503.下一个更大元素 II</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        sta.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; i++) { <span class="comment">// 两次遍历数组，相当于循环遍历了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] &lt; nums[sta.<span class="built_in">top</span>()]) sta.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] == nums[sta.<span class="built_in">top</span>()]) sta.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="built_in">size</span>()] &gt; nums[sta.<span class="built_in">top</span>()]) {</span><br><span class="line">                    res[sta.<span class="built_in">top</span>()] = nums[i % nums.<span class="built_in">size</span>()];</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                }</span><br><span class="line">                sta.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC42-接雨水"><a href="https://leetcode-cn.com/problems/trapping-rain-water/">LC42.接雨水</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="comment">// 双指针法</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="comment">// 第一个柱子和最后一个柱子不接雨水</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == height.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> rHeight = height[i]; <span class="comment">// 左侧最高的柱子</span></span><br><span class="line">            <span class="keyword">int</span> lHeight = height[i]; <span class="comment">// 右侧最高的柱子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.<span class="built_in">size</span>(); j++) rHeight = <span class="built_in">max</span>(rHeight, height[j]); <span class="comment">// 寻找当前位置右侧最高的柱子：存在重复计算，导致超时</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) lHeight = <span class="built_in">max</span>(lHeight, height[j]); <span class="comment">// 寻找当前位置左侧最高的柱子</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="built_in">min</span>(rHeight, lHeight) - height[i]; <span class="comment">// 当前柱子可接的雨水量</span></span><br><span class="line">            <span class="keyword">if</span> (h &gt; <span class="number">0</span>) sum += h;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        <span class="comment">// 利用动态规划分别记录下来每一个位置最左最高和最右最高的情况</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxLeft</span><span class="params">(height.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxRight</span><span class="params">(height.size())</span></span>;</span><br><span class="line">        maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); i++) maxLeft[i] = <span class="built_in">max</span>(maxLeft[i - <span class="number">1</span>], height[i]); <span class="comment">// 最左最高</span></span><br><span class="line">        maxRight[height.<span class="built_in">size</span>() - <span class="number">1</span>] = height[height.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = height.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) maxRight[i] = <span class="built_in">max</span>(maxRight[i + <span class="number">1</span>], height[i]); <span class="comment">// 最右最高</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">int</span> count = <span class="built_in">min</span>(maxLeft[i], maxRight[i]) - height[i]; <span class="comment">// 取左右的最矮的</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) sum += count; </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>{</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; sta; <span class="comment">// 单调递增栈，存储下标值</span></span><br><span class="line">        sta.<span class="built_in">push</span>(<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[sta.<span class="built_in">top</span>()]) sta.<span class="built_in">push</span>(i); <span class="comment">// 当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (height[i] == height[sta.<span class="built_in">top</span>()]) { <span class="comment">// 前遍历的元素（柱子）高度等于栈顶元素的高度，要跟更新栈顶元素，因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度</span></span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                sta.<span class="built_in">push</span>(i);</span><br><span class="line">            } <span class="keyword">else</span> { <span class="comment">// 当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽了</span></span><br><span class="line">                <span class="keyword">while</span> (!sta.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[sta.<span class="built_in">top</span>()]) { <span class="comment">// 需要循环操作，类似于75536的情况</span></span><br><span class="line">                    <span class="comment">// 栈顶和栈顶的下一个元素以及要入栈的三个元素来接水</span></span><br><span class="line">                    <span class="keyword">int</span> mid = sta.<span class="built_in">top</span>();</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!sta.<span class="built_in">empty</span>()) { <span class="comment">// 有必要</span></span><br><span class="line">                        <span class="keyword">int</span> h = <span class="built_in">min</span>(height[i], height[sta.<span class="built_in">top</span>()]) - height[mid];</span><br><span class="line">                        <span class="keyword">int</span> w = i - sta.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                        sum += h * w;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                sta.<span class="built_in">push</span>(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC84-柱状图中最大的矩形"><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">LC84.柱状图中最大的矩形</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> right = i;</span><br><span class="line">            <span class="keyword">for</span> (; left &gt;= <span class="number">0</span>; left--) { <span class="comment">// 找到最左边的界限</span></span><br><span class="line">                <span class="keyword">if</span> (heights[left] &lt; heights[i]) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">for</span> (; right &lt; heights.<span class="built_in">size</span>(); right++) { <span class="comment">// 找到最右边的界限</span></span><br><span class="line">                <span class="keyword">if</span> (heights[right] &lt; heights[i]) <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">int</span> width = right - left - <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">int</span> height = heights[i];</span><br><span class="line">            sum = <span class="built_in">max</span>(sum, width * height);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>{</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxLeft</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxRight</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        maxLeft[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 避免死循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">int</span> t = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (t &gt;= <span class="number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) t = maxLeft[t]; <span class="comment">// 循环往前推，maxLeft[i]代表当前位置最左边界，这样可以减少循环次数 也可以 t -= 1;但会超时</span></span><br><span class="line">            maxLeft[i] = t;</span><br><span class="line">        }</span><br><span class="line">        maxRight[heights.<span class="built_in">size</span>() - <span class="number">1</span>] = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heights.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">            <span class="keyword">int</span> t = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (t &lt; heights.<span class="built_in">size</span>() &amp;&amp; heights[t] &gt;= heights[i]) t = maxRight[t]; <span class="comment">// 循环往后推，maxRight[i]代表当前位置最右边界，这样可以减少循环次数 也可以 t += 1;但会超时</span></span><br><span class="line">            maxRight[i] = t;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); i++) {</span><br><span class="line">            <span class="keyword">int</span> sum = heights[i] * (maxRight[i] - maxLeft[i] - <span class="number">1</span>); <span class="comment">// 高 * 宽</span></span><br><span class="line">            result = <span class="built_in">max</span>(sum, result);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>{</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// 在头部加入元素0</span></span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 在尾部加入元素0</span></span><br><span class="line">        sta.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>  (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.<span class="built_in">size</span>(); i++) { <span class="comment">// 需要找出当前位置左右两边最近的小于当前高度的位置，需要使用单调递减栈</span></span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[sta.<span class="built_in">top</span>()]) sta.<span class="built_in">push</span>(i); <span class="comment">// 情况一：当前遍历的元素heights[i]小于栈顶元素heights[st.top()]的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (heights[i] == heights[sta.<span class="built_in">top</span>()]) { <span class="comment">// 情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况</span></span><br><span class="line">                sta.<span class="built_in">pop</span>(); <span class="comment">// 记录最远的位置</span></span><br><span class="line">                sta.<span class="built_in">push</span>(i); </span><br><span class="line">            } <span class="keyword">else</span> {  <span class="comment">//情况二：当前遍历的元素heights[i]等于栈顶元素heights[st.top()]的情况</span></span><br><span class="line">                <span class="keyword">while</span> (heights[i] &lt; heights[sta.<span class="built_in">top</span>()]) {</span><br><span class="line">                    <span class="keyword">int</span> mid = sta.<span class="built_in">top</span>();</span><br><span class="line">                    sta.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">int</span> left = sta.<span class="built_in">top</span>();</span><br><span class="line">                    <span class="keyword">int</span> right = i;</span><br><span class="line">                    <span class="keyword">int</span> w = right - left - <span class="number">1</span>; <span class="comment">// 左右两边第一个小于当前高度的位置再往里就是都大于等于当前位置的高度</span></span><br><span class="line">                    <span class="keyword">int</span> h = heights[mid];</span><br><span class="line">                    result = <span class="built_in">max</span>(result, w * h);</span><br><span class="line">                }</span><br><span class="line">                sta.<span class="built_in">push</span>(i);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="大整数操作">大整数操作</h2>
<h3 id="1、大整数操作的理论要点">1、大整数操作的理论要点</h3>
<h3 id="2、重点题型-14">2、重点题型</h3>
<ul>
<li>
<h4 id="Euler13-大整数加法"><a href="http://pe-cn.github.io/13/">Euler13.大整数加法</a></h4>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="大整数乘法"><a href="">大整数乘法</a></h4>
 <figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="零碎题型">零碎题型</h2>
<h3 id="1、前缀和">1、前缀和</h3>
<ul>
<li>
<h4 id="LC303-区域和检索"><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">LC303.区域和检索</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<h4 id="LC304-二维区域和检索"><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">LC304.二维区域和检索</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="2、LRU缓存机制">2、LRU缓存机制</h3>
<ul>
<li>
<h4 id="LC146-LRU-缓存"><a href="https://leetcode-cn.com/problems/lru-cache/">LC146.LRU 缓存</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="3、线段树">3、线段树</h3>
<ul>
<li>
<h4 id="HZOJ223-线段树模板"><a href="http://oj.haizeix.com/problem/223">HZOJ223. 线段树模板</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="4、递归-记忆化">4、递归+记忆化</h3>
<ul>
<li>
<h4 id="Eluer14-递推"><a href="http://pe-cn.github.io/14/">Eluer14.递推</a></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="LC946-验证栈序列"><a href="https://leetcode-cn.com/problems/validate-stack-sequences/">LC946.验证栈序列</a></h4>
<h4 id="LC933-最近的请求次数"><a href="https://leetcode-cn.com/problems/number-of-recent-calls/">LC933.最近的请求次数</a></h4>
<h4 id="LC1021-删除最外层的括号"><a href="https://leetcode-cn.com/problems/remove-outermost-parentheses/">LC1021.删除最外层的括号</a></h4>
<h4 id="LC682-棒球比赛"><a href="https://leetcode-cn.com/problems/baseball-game/">LC682.棒球比赛</a></h4>
<h4 id="LC103-二叉树的锯齿形层序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">LC103.二叉树的锯齿形层序遍历</a></h4>
<h4 id="LC844-比较含退格的字符串-2"><a href="https://leetcode-cn.com/problems/backspace-string-compare/">LC844.比较含退格的字符串</a></h4>
]]></content>
      <categories>
        <category>笔记</category>
        <category>专业笔记</category>
        <category>算法刷题</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>技能</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - C版</title>
    <url>/post/b0f49719.html</url>
    <content><![CDATA[<h1>基础数据结构</h1>
<ul>
<li><strong>顺序表与链表</strong></li>
<li><strong>栈和队列</strong></li>
<li><strong>树与二叉树</strong></li>
<li><strong>排序与查找</strong></li>
<li><strong>堆与优先队列</strong></li>
<li><strong>森林和并查集</strong></li>
</ul>
<p><strong>程序 = 算法(时间) + 数据结构(空间)</strong></p>
<p><strong>程序设计 = 算法 + 数据结构 + 编程范式</strong></p>
<p><strong>数据结构 = 结构定义 + 结构操作</strong></p>
<h2 id="线性表">线性表</h2>
<h3 id="1、顺序表-vector">1、顺序表 - vector</h3>
<ul>
<li>
<p>顺序表是<code>存储结构</code>，是指用一组地址连续的存储单元，依次存储线性表中的数据元素，从而使得<strong>逻辑上相邻的两个元素在物理位置上也相邻</strong>。</p>
</li>
<li>
<p><strong>顺序表支持随机访问，访问的时间复杂度是</strong><code>O(1)</code></p>
</li>
</ul>
<h4 id="1-1、结构定义">1.1、结构定义</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20210106183317564.png" alt="image-20210106183317564"></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> {</span></span><br><span class="line">    Type *data;  <span class="comment">// 用来指向顺序表</span></span><br><span class="line">    <span class="keyword">int</span> size;  <span class="comment">// 顺序表的容量</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 元素个数，一开始初始化为0</span></span><br><span class="line">} Vec;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-2、构造操作">1.2、构造操作</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Vec* <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{ <span class="comment">// 传入顺序表的容量，用来初始化size</span></span><br><span class="line">    Vec *v = (Vec *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Vec));</span><br><span class="line">    v-&gt;data = (Type *)<span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(Type)); <span class="comment">// 给数据开辟空间，并指向data</span></span><br><span class="line">    v-&gt;length = <span class="number">0</span>;</span><br><span class="line">    v-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-3、回收操作">1.3、回收操作</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Vec *v)</span> </span>{  <span class="comment">// 传入顺序表结构</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;  <span class="comment">// 特殊判断</span></span><br><span class="line">    <span class="built_in">free</span>(v-&gt;data); <span class="comment">// 先释放数据域</span></span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-4、扩容操作">1.4、扩容操作</h4>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int expand(Vec * vec)</code></td>
<td style="text-align:center">扩大顺序表的容量</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Vec *v)</span> </span>{ <span class="comment">// 传入要扩展的顺序表</span></span><br><span class="line">    <span class="keyword">int</span> extr_size = v-&gt;size; <span class="comment">// 扩展为原来的两倍</span></span><br><span class="line">    Type *p; <span class="comment">// 由于reallow的机制，有可能创建不成功返回NULL，覆盖掉原来的数据，使用临时指针</span></span><br><span class="line">    <span class="keyword">while</span> (extr_size) { <span class="comment">// 采用妥协的策略，两倍的容量不能就慢慢减少</span></span><br><span class="line">        p = (Type*)<span class="built_in">realloc</span>(v-&gt;data, <span class="built_in"><span class="keyword">sizeof</span></span>(Type) * (v-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">break</span>; <span class="comment">// 判断当创建成功时，退出循环</span></span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>; <span class="comment">// 每次循环 extr_size / 2</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) {  <span class="comment">// 创建失败时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    v-&gt;size += extr_size;  <span class="comment">// 创建成功，更新顺序表容量大小</span></span><br><span class="line">    v-&gt;data = p; <span class="comment">// 将数据域头指针指向扩容后的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-5、插入操作O-n">1.5、插入操作<code>O(n)</code></h4>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int insert(Vec * v, int loc, Type val)</code></td>
<td style="text-align:center">将<code>val</code>插入到顺序表中下标为<code>loc</code>的位置</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Vec *v, <span class="keyword">int</span> loc, Type val)</span> </span>{   <span class="comment">// 传入要插入的顺序表、插入位置、插入元素值</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 1、特判顺序表未创建的情况</span></span><br><span class="line">    <span class="keyword">if</span> (loc &lt; <span class="number">0</span> || loc &gt; v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 2、特判插入位置是否合法插入位置必须和前面的连接起来</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;length == v-&gt;size) {   <span class="comment">// 3、顺序表满的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!expand(v)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 扩容是否成功</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = v-&gt;length; i &gt; loc; i--) {   <span class="comment">// 4、从最后面一个元素开始移动</span></span><br><span class="line">        v-&gt;data[i] = v-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    v-&gt;length++; <span class="comment">// 5、更新元素个数</span></span><br><span class="line">    v-&gt;data[loc] = val;<span class="comment">// 6、插入元素值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-6、删除操作O-n">1.6、删除操作<code>O(n)</code></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(Vec *v, <span class="keyword">int</span> loc)</span> </span>{  <span class="comment">// 传入要删除的顺序表，删除的位置</span></span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 1、特判顺序表是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (loc &lt; <span class="number">0</span> || loc &gt;= v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 2、特判删除位置是否合法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = loc; i &lt; v-&gt;length - <span class="number">1</span>; i++) {<span class="comment">// 3、从插入位置往后移动</span></span><br><span class="line">        v-&gt;data[i] = v-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    v-&gt;length--; <span class="comment">// 4、更新元素个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-7、测试代码">1.7、测试代码</h4>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tgmath.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_STR(a) _Generic((a), \ <span class="comment">// 泛型宏</span></span></span><br><span class="line">    <span class="keyword">int</span>: <span class="string">"%d"</span>, \</span><br><span class="line">    <span class="keyword">double</span>: <span class="string">"%lf"</span>, \</span><br><span class="line">    <span class="keyword">char</span>: <span class="string">"%c"</span>, \</span><br><span class="line">    <span class="keyword">char</span> *: <span class="string">"%s"</span> \</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLOR(a, b) <span class="meta-string">"\033["</span> #b <span class="meta-string">"m"</span> a <span class="meta-string">"\033[0m"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GREEN(a) COLOR(a, 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED(a) COLOR(a, 31)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> {</span></span><br><span class="line">    Type *data;</span><br><span class="line">    <span class="keyword">int</span> length, size;</span><br><span class="line">} Vec;</span><br><span class="line"></span><br><span class="line"><span class="function">Vec* <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">    Vec *v = (Vec *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Vec));</span><br><span class="line">    v-&gt;data = (Type *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(Type));</span><br><span class="line">    v-&gt;length = <span class="number">0</span>;</span><br><span class="line">    v-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(Vec *v)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> extr_size = v-&gt;size;</span><br><span class="line">    Type *p;</span><br><span class="line">    <span class="keyword">while</span> (extr_size) {</span><br><span class="line">        p = (Type*)<span class="built_in">realloc</span>(v-&gt;data, <span class="keyword">sizeof</span>(Type) * (v-&gt;size + extr_size));</span><br><span class="line">        <span class="keyword">if</span> (p) <span class="keyword">break</span>;</span><br><span class="line">        extr_size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"insucceed to expand!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    v-&gt;size += extr_size;</span><br><span class="line">    v-&gt;data = p;</span><br><span class="line">    <span class="built_in">printf</span>(GREEN(<span class="string">"succeed to expand! The new size = %d\n"</span>), v-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Vec *v, <span class="keyword">int</span> loc, Type val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt; <span class="number">0</span> || loc &gt; v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;length == v-&gt;size) {</span><br><span class="line">        <span class="keyword">if</span> (!expand(v)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = v-&gt;length; i &gt; loc; i--) {</span><br><span class="line">        v-&gt;data[i] = v-&gt;data[i - <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    v-&gt;length++;</span><br><span class="line">    v-&gt;data[loc] = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(Vec *v, <span class="keyword">int</span> loc)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt; <span class="number">0</span> || loc &gt;= v-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = loc + <span class="number">1</span>; i &lt; v-&gt;length; i++) {</span><br><span class="line">        v-&gt;data[i - <span class="number">1</span>] = v-&gt;data[i];</span><br><span class="line">    }</span><br><span class="line">    v-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(Vec *v)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">free</span>(v-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(v);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(Vec *v)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Vector : ["</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v-&gt;length; i++) {</span><br><span class="line">        <span class="function">i &amp;&amp; <span class="title">printf</span><span class="params">(<span class="string">","</span>)</span></span>;</span><br><span class="line">        <span class="built_in">printf</span>(TYPE_STR(v-&gt;data[i]), v-&gt;data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_N 20</span></span><br><span class="line">    Vec *v = init(<span class="number">1</span>);</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_N; i++) {</span><br><span class="line">        <span class="keyword">int</span> op, loc;</span><br><span class="line">        Type val;</span><br><span class="line">        op = rand() % <span class="number">4</span>;</span><br><span class="line">        loc = (rand() % (v-&gt;length + <span class="number">2</span>)) - <span class="number">1</span>;</span><br><span class="line">        val = rand() % <span class="number">42</span> + <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (op) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : </span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> :{</span><br><span class="line">                <span class="built_in">printf</span>(RED(<span class="string">"insert %c at %d = %d\n"</span>), val, loc, insert(v, loc, val));</span><br><span class="line">            } <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : {</span><br><span class="line">                <span class="built_in">printf</span>(RED(<span class="string">"erase a item at %d = %d\n"</span>), loc, erase(v, loc));</span><br><span class="line">            }<span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        output(v);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    clear(v);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_N</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-8、补充知识">1.8、补充知识</h4>
<ul>
<li>
<p><strong>泛型宏</strong>：可以根据<code>传入参数的数据类型</code>来操作，类似于<code>switch</code></p>
  <figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_STR(a) _Generic((a), \</span></span><br><span class="line"><span class="meta">    int: <span class="meta-string">"%d"</span>, \</span></span><br><span class="line"><span class="meta">    double: <span class="meta-string">"%lf"</span>, \</span></span><br><span class="line"><span class="meta">    char: <span class="meta-string">"%c"</span>, \</span></span><br><span class="line"><span class="meta">    char *: <span class="meta-string">"%s"</span> \</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="2、链表">2、链表</h3>
<h4 id="2-1、结构定义">2.1、结构定义</h4>
<p><strong>链表的元素是节点</strong></p>
<ul>
<li><strong>节点定义</strong></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    Type data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>链表结构</strong></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> {</span></span><br><span class="line">    Node head; <span class="comment">// 虚拟头节点, 是一个实在的节点，不能使用指针</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 记录链表的长度</span></span><br><span class="line">} List;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2、构造操作">2.2、构造操作</h4>
<ul>
<li><strong>节点构造</strong></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">getNewNode</span><span class="params">(Type val)</span> </span>{</span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = val;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>链表构造</strong></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">List* <span class="title">init_list</span><span class="params">()</span> </span>{</span><br><span class="line">    List *l = (List *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(List));</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-3、回收操作">2.3、回收操作</h4>
<ul>
<li><strong>节点回收</strong></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearNode</span><span class="params">(Node *node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>链表回收</strong></li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearList</span><span class="params">(List *l)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Node *p = l-&gt;head.next, *q; <span class="comment">// 此处不能从l-&gt;head开始回收，否则free(l)时会再次回收，出现错误</span></span><br><span class="line">    <span class="keyword">while</span> (p) { <span class="comment">// 删除每一个节点</span></span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        clearNode(p);</span><br><span class="line">        p = q;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4、插入操作">2.4、插入操作</h4>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *l, <span class="keyword">int</span> loc, Type val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt; <span class="number">0</span> || loc &gt; l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node *p = &amp;(l-&gt;head), *node = getNewNode(val);</span><br><span class="line">    <span class="keyword">while</span> (loc--) p = p-&gt;next;</span><br><span class="line">    node-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = node;</span><br><span class="line">    l-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-5、删除操作">2.5、删除操作</h4>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *l, <span class="keyword">int</span> loc)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt; <span class="number">0</span> || loc &gt;= l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node *p = &amp;(l-&gt;head), *q;</span><br><span class="line">    <span class="keyword">while</span> (loc--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    clearNode(q);</span><br><span class="line">    l-&gt;length -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-6、测试代码">2.6、测试代码</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(X) _Generic((X), \</span></span><br><span class="line"><span class="meta">    int : <span class="meta-string">"%d-&gt;"</span>, \</span></span><br><span class="line"><span class="meta">    double : <span class="meta-string">"%f-&gt;"</span>, \</span></span><br><span class="line"><span class="meta">    char : <span class="meta-string">"%c-&gt;"</span> \</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    Type data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">} Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> {</span></span><br><span class="line">    Node head; <span class="comment">// 虚拟头节点, 是一个实在的节点，不能使用指针</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 记录链表的长度</span></span><br><span class="line">} List;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">getNewNode</span><span class="params">(Type val)</span> </span>{</span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Node));</span><br><span class="line">    node-&gt;data = val;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">List* <span class="title">init_list</span><span class="params">()</span> </span>{</span><br><span class="line">    List *l = (List *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(List));</span><br><span class="line">    l-&gt;head.next = <span class="literal">NULL</span>;</span><br><span class="line">    l-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(List *l, <span class="keyword">int</span> loc, Type val)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt; <span class="number">0</span> || loc &gt; l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node *p = &amp;(l-&gt;head), *node = <span class="built_in">getNewNode</span>(val);</span><br><span class="line">    <span class="keyword">while</span> (loc--) p = p-&gt;next;</span><br><span class="line">    node-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = node;</span><br><span class="line">    l-&gt;length += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearNode</span><span class="params">(Node *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">erase</span><span class="params">(List *l, <span class="keyword">int</span> loc)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (loc &lt; <span class="number">0</span> || loc &gt;= l-&gt;length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node *p = &amp;(l-&gt;head), *q;</span><br><span class="line">    <span class="keyword">while</span> (loc--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">clearNode</span>(q);</span><br><span class="line">    l-&gt;length -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearNode</span><span class="params">(Node *node)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearList</span><span class="params">(List *l)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Node *p = l-&gt;head.next, *q;</span><br><span class="line">    <span class="keyword">while</span> (p) { <span class="comment">// 删除每一个节点</span></span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="built_in">clearNode</span>(p);</span><br><span class="line">        p = q;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(l);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(List *l)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Node *p = l-&gt;head.next;</span><br><span class="line">    <span class="keyword">while</span> (p) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="built_in">L</span>(p-&gt;data), p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    List *l = <span class="built_in">init_list</span>();</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAX_n 20</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_n; i++) {</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="built_in">rand</span>() % (l-&gt;length + <span class="number">3</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> op = <span class="built_in">rand</span>() % <span class="number">4</span>;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(op) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"insert %d at %d to List = %d\n"</span>, val, loc, <span class="built_in">insert</span>(l, loc, val));</span><br><span class="line">            } <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"erase a item at %d from List = %d\n"</span>, loc, <span class="built_in">erase</span>(l, loc));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">output</span>(l);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">clearList</span>(l);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> MAX_n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="字符串">字符串</h2>
<h3 id="1、字符串匹配">1、字符串匹配</h3>
<h4 id="1-1、问题">1.1、问题</h4>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211111224419474.png" alt="image-20211111224419474"></p>
<h4 id="1-2、解决方法">1.2、解决方法</h4>
<h5 id="1-2-1、暴力匹配算法">1.2.1、暴力匹配算法</h5>
<ul>
<li>
<p><strong>时间复杂度</strong>：最好<code>O(n)</code>，最差<code>O(n * m)</code></p>
</li>
<li>
<p><strong>算法思想</strong>：依次对齐<strong>模式串</strong>和<strong>母串</strong>的每一位，直到完全匹配。</p>
</li>
<li>
<p><strong>代码演示</strong>：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brute_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> s_size = s.size(), t_size() = t.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_size - t_size + <span class="number">1</span>; i++) { <span class="comment">//母串：减枝(i &lt; s_size - t_size + 1)</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; t[j]; j++) { <span class="comment">//模式串</span></span><br><span class="line">            <span class="keyword">if</span> (s[i + j] == t[j]) <span class="keyword">continue</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//匹配成功</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//匹配失败</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="1-2-2、KMP算法">1.2.2、KMP算法</h5>
<ul>
<li>
<p><strong>时间复杂度</strong>：<code>O(m + n)</code></p>
</li>
<li>
<p><strong>算法思想</strong>：</p>
<ol>
<li>
<p><strong>基础补充</strong>：</p>
<ul>
<li><strong>前缀</strong>：字符串的任意首部</li>
<li><strong>后缀</strong>：字符串的任意尾部</li>
<li><strong>真前缀</strong>：不包含尾部的前缀</li>
<li><strong>真后缀</strong>：不包含首部的后缀</li>
</ul>
</li>
<li>
<p><strong>算法引导</strong>：</p>
<p><strong>暴力算法</strong>是匹配不成功时，每次将<strong>模式串</strong>后移<code>1</code>位和母串重新对齐，再将模式串和母串进行比对。<strong>KMP算法</strong>是在暴力算法的基础上进行改进，通过将<strong>模式串</strong>预处理得出<strong>最长相等前后缀表</strong><code>next数组</code>，在和主串匹配不成功时，可以根据<code>next数组</code>得出最长匹配前后缀，从而移动模式串重新对齐母串。</p>
<p><strong>具体分析如下</strong>：</p>
<p><img src="https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211112164606738.png" alt="image-20211112164606738"></p>
<ul>
<li>
<p>如上图，母串<code>S</code>和模式串<code>T</code>在<code>5,6</code>的位置匹配失败，模式串<code>T</code>中的<code>3,4</code>是相等的前、后缀部分，模式串<code>T</code>可直接后移<code>7</code>的大小，由于<code>3 == 4 &amp;&amp; 2 == 4</code>，推出<code>2 == 3</code>，所以模式串<code>T'</code>和母串<code>S</code>就不需要从头开始匹配，可以直接从模式串<code>8</code>和母串<code>5</code>开始匹配，由此就减少<strong>暴力算法</strong>中一次移动一步的次数，具体推导过程见<a href="https://pan.baidu.com/s/1SNujD65uXdFflSHPfQKCFw">海贼科技 - 胡船长的证明</a>（提取码：1234）。</p>
</li>
<li>
<p>问题一：<code>7</code>的大小是多少</p>
<p>由模式串的前缀<code>3</code>和后缀<code>4</code>相等的最大长度<code>k</code>决定，移动距离为<code>i - k - 1</code>。</p>
</li>
<li>
<p>问题二：如何保证不漏</p>
<p><code>4</code>尽可能长，达到最长，同时<code>3 == 4</code>，<code>3</code>为最长匹配前缀，<code>4</code>为最长匹配后缀</p>
</li>
<li>
<p>问题三：模式串如何预处理</p>
<p>模式串的每一位之前都应该预处理出类似<code>3,4</code>这种最长匹配前后缀的长度信息</p>
</li>
</ul>
</li>
<li>
<p><strong><code>next[i]</code>数组的确定</strong>：</p>
<p><strong>定义</strong>：当位置<code>i</code>匹配成功，但<code>i+1</code>位置失配时，模式串中<strong>最长</strong>前缀的<strong>最后一个字符</strong>的下标</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4个步骤：</span></span><br><span class="line"><span class="comment"> *	1、初始化</span></span><br><span class="line"><span class="comment"> * 	2、前后缀不同的情况</span></span><br><span class="line"><span class="comment"> *	3、前后缀相同的情况</span></span><br><span class="line"><span class="comment"> * 	4、更新next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">next[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//next数组用来标记当前位置之前有多大长度的相同前缀后缀</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// j指向前缀末尾的下一位</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>; <span class="comment">// i指向后缀末尾的下一位</span></span><br><span class="line"><span class="keyword">for</span> ( ; t[i]; i++) {</span><br><span class="line">	<span class="comment">// 前后缀不同的情况 </span></span><br><span class="line">    <span class="comment">// 当i, j发生冲突时，要看发生冲突的前一位j - 1，回退到next[j - 1]的位置</span></span><br><span class="line">    <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; t[i] != t[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 前后缀相同的情况</span></span><br><span class="line">    <span class="keyword">if</span> (t[i] == t[j]) j += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 更新next</span></span><br><span class="line">    next[i] = j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
</li>
<li>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> *next, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span> </span>{</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">1</span>; t[i]l i++) {</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; t[i] != t[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (t[i] == t[j]) j += <span class="number">1</span>;</span><br><span class="line">        next[i] = j<span class="number">'</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> KMP(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *t) {</span><br><span class="line">    <span class="keyword">int</span> next[s.size()];</span><br><span class="line">    getNext(next, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; s[i]; i++) {</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; s[i] != t[j]) j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) j += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (t[j] == <span class="number">0</span>) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>专业笔记</category>
        <category>基础知识</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
