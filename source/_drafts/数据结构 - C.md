---
title: 数据结构 - C版
comments: false
tags: 数据结构
categories:
	- [笔记, 专业笔记, 基础知识, 数据结构]
description: >-
  本笔记主要讲解了基础数据结构和高级数据结构以及基于C语言的代码实现，主要包括顺序表、链表、队列、栈、树与二叉树、排序算法、查找算法、优先队列、森林与并查集、二叉排序树、AVL树、红黑树、字典树、字符匹配算法、哈夫曼编码。
abbrlink: b0f49719
date: 2021-11-05 22:45:20
---









## 字符串

### 1、字符串匹配

#### 1.1、问题

![image-20211111224419474](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211111224419474.png)

#### 1.2、解决方法

##### 1.2.1、暴力匹配算法

-   **时间复杂度**：最好`O(n)`，最差`O(n * m)`

-   **算法思想**：依次对齐**模式串**和**母串**的每一位，直到完全匹配。

-   **代码演示**：

    ```c
    int brute_force(const char *s, const char *t) {
        int s_size = s.size(), t_size() = t.size();
        for (int i = 0; i < s_size - t_size + 1; i++) { //母串：减枝(i < s_size - t_size + 1)
            int flag = 0;
            for (int j = 0; t[j]; j++) { //模式串
                if (s[i + j] == t[j]) continue;
                flag = 1;
                break;
            }
            if (flag == 0) return 1; //匹配成功
        }
        return -1; //匹配失败
    }
    ```

##### 1.2.2、KMP算法

-   **时间复杂度**：`O(m + n)`

-   **算法思想**：

    1.  **基础补充**：

        -   **前缀**：字符串的任意首部
        -   **后缀**：字符串的任意尾部
        -   **真前缀**：不包含尾部的前缀
        -   **真后缀**：不包含首部的后缀

    2.  **算法引导**：

        **暴力算法**是匹配不成功时，每次将**模式串**后移`1`位和母串重新对齐，再将模式串和母串进行比对。**KMP算法**是在暴力算法的基础上进行改进，通过将**模式串**预处理得出**最长匹配前缀表**`next数组`，在和主串匹配不成功时，可以根据`next数组`得出最长匹配前缀，从而移动模式串重新对齐母串。

        **具体分析如下**：

        ![image-20211112115605955](https://dongqing1903.oss-cn-shanghai.aliyuncs.com/img/image-20211112115605955.png)

